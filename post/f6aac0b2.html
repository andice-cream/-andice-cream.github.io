<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>NoSQL数据库 | 小肥龙吃大冰淇淋</title><meta name="keywords" content="前端,Node.js进阶"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NoSQL数据库课程介绍主要内容 Redis开发与实战(内存型) Memcached入门(内存型) MongoDb入门(存储型)  redis和memcached是同一类型，内存型。MongoDb是存储型。 着重讲解redis,存储性数据库还是mysql的天下。 学习目标 掌握非关系性数据库的特点以及使用 掌握NoSQL 技术在实际开发中的应用  NoSQL主要应用场景专门应对高并发，需要高速读写">
<meta property="og:type" content="article">
<meta property="og:title" content="NoSQL数据库">
<meta property="og:url" content="https://andice-cream.github.io/post/f6aac0b2.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="NoSQL数据库课程介绍主要内容 Redis开发与实战(内存型) Memcached入门(内存型) MongoDb入门(存储型)  redis和memcached是同一类型，内存型。MongoDb是存储型。 着重讲解redis,存储性数据库还是mysql的天下。 学习目标 掌握非关系性数据库的特点以及使用 掌握NoSQL 技术在实际开发中的应用  NoSQL主要应用场景专门应对高并发，需要高速读写">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212025.jpg">
<meta property="article:published_time" content="2021-11-19T14:39:00.000Z">
<meta property="article:modified_time" content="2022-11-27T09:16:39.393Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="Node.js进阶">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212025.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://andice-cream.github.io/post/f6aac0b2"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NoSQL数据库',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">178</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212025.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">NoSQL数据库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-19T14:39:00.000Z" title="发表于 2021-11-19 22:39:00">2021-11-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:39.393Z" title="更新于 2022-11-27 17:16:39">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/Node-js%E8%BF%9B%E9%98%B6/">Node.js进阶</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>54分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="NoSQL数据库"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h1><h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ul>
<li><strong>Redis开发与实战</strong>(内存型)</li>
<li><strong>Memcached入门</strong>(内存型)</li>
<li>MongoDb入门(存储型)</li>
</ul>
<p>redis和memcached是同一类型，内存型。MongoDb是存储型。</p>
<p><strong>着重讲解redis</strong>,存储性数据库还是mysql的天下。</p>
<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul>
<li>掌握非关系性数据库的特点以及使用</li>
<li>掌握NoSQL 技术在实际开发中的应用</li>
</ul>
<h3 id="NoSQL主要应用场景"><a href="#NoSQL主要应用场景" class="headerlink" title="NoSQL主要应用场景"></a>NoSQL主要应用场景</h3><p>专门应对高并发，需要高速读写的场景，而就Redis技术而言，它的性能十分优越，可以支持每秒十几万次的读/写操作，<strong>其性能远超数据库</strong>，并且还支持集群、分布式、主从同步等配置。</p>
<ul>
<li>天猫双11</li>
<li>抢红包，抢手机，抢火车票， 抢门票</li>
<li>ssr 服务端渲染</li>
</ul>
<h2 id="第一章-Redis"><a href="#第一章-Redis" class="headerlink" title="第一章 Redis"></a>第一章 Redis</h2><ul>
<li>特点</li>
<li>api</li>
<li>结合nodejs应用</li>
</ul>
<h3 id="历史与发展"><a href="#历史与发展" class="headerlink" title="历史与发展"></a>历史与发展</h3><blockquote>
<p> 2008年，意大利的一家创业公司Merzia[ <a target="_blank" rel="noopener" href="http://merzia.com/">http://merzia.com</a>]推出了一款基于MySQL的网站实时统计系统LLOOGG[ <a target="_blank" rel="noopener" href="http://lloogg.com/">http://lloogg.com</a>]，然而没过多久该公司的创始人Salvatore Sanfilippo便开始对MySQL的性能感到失望，于是他决定亲自为LLOOGG量身定做一个数据库，并于2009年开发完成，这个数据库就是Redis。不过Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望让更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源发布，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发，直到今天。</p>
</blockquote>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>redis究竟有什么魅力，吸引了如此多的用户?</strong></p>
<ul>
<li>存储结构特别-字典</li>
<li>内存存储与持久化- 缓存</li>
<li>功能丰富</li>
<li>简单稳定- 简单可依赖</li>
</ul>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>Redis是 REmote DIctionary Server (远程字典服务器)的缩写，它以<strong>字典</strong>结构存储数据。</p>
<blockquote>
<p>字典就是js中的object</p>
<p>在js中key只能是字符串</p>
</blockquote>
<p>同大多数语言中的字典一样，Redis字典的键值除了可以是字符串，也可以是其他数据类型。</p>
<ul>
<li>字符串</li>
<li>散列</li>
<li>列表</li>
<li>集合</li>
<li>有序集合</li>
</ul>
<blockquote>
<p>字典： 类似 js中的object就是一种典型的字典结构。</p>
</blockquote>
<h5 id="ex："><a href="#ex：" class="headerlink" title="ex："></a>ex：</h5><p>我们在post变量中存储了一篇文章的数据  (标题， 正文， 阅读量)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">post.titile = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">post.content = <span class="string">&#x27;balabala&#x27;</span></span><br><span class="line">post.views = <span class="number">0</span></span><br><span class="line">post.tags = [<span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;nodejs&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>假如需要通过tag检索出文章，关系型数据库mysql需要建3张表，而且查询非常复杂。</p>
<p>但是使用Redis可以对tags进行 交集，并集这样的集合运算操作。可以很轻易的实现对tags的各种查询要求。</p>
<h4 id="内存存储与持久化"><a href="#内存存储与持久化" class="headerlink" title="内存存储与持久化"></a>内存存储与持久化</h4><p>Redis数据库中所有的数据都存在内存中。一台普通的笔记本电脑，redis一秒可读写超过10万个键值对。</p>
<p>但是，数据存在内存中程序退出后会导致数据丢失。不过redis也提供了对数据持久化的支持。</p>
<blockquote>
<p>在浏览器里面数据持久化可以理解为： localStorage, cookie</p>
</blockquote>
<h4 id="功能丰富"><a href="#功能丰富" class="headerlink" title="功能丰富"></a>功能丰富</h4><p>应用场景丰富，redis名副其实的多面手。</p>
<ul>
<li>缓存</li>
<li>队列系统</li>
</ul>
<ol>
<li><p>redis可以为每个key设置生存时间，到期会自动删除，这一功能配合出色的性能能让它作为缓存系统来使用。由于redis支持持久化和丰富的数据类型，也使其成为了Memcached的竞争者。</p>
</li>
<li><p>作为缓存系统，redis还可以限定数据占的最大空间，超过后自动删除不需要的key。</p>
</li>
<li><p>redis的列表类型键还可以用来实现队列，并且支持阻塞式读取，可以很容易实现一个高性能的优先级队列。</p>
</li>
<li><p>redis还支持”发布/订阅”，可以基于此构建聊天室等系统。</p>
</li>
</ol>
<h4 id="简单稳定"><a href="#简单稳定" class="headerlink" title="简单稳定"></a>简单稳定</h4><p>即使功能再丰富，如果使用起来太复杂也很难吸引人。</p>
<ol>
<li>Redis直观的存储结构使得通过程序与Redis交互十分简单，在Redis中使用命令来读写数据，命令语句之于Redis就相当于SQL语言之于关系数据库。</li>
</ol>
<h5 id="ex"><a href="#ex" class="headerlink" title="ex:"></a>ex:</h5><p>在关系数据库中要获取posts表内id为1的记录的title字段的值可以使用如下SQL语句实现：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title <span class="keyword">FROM</span> posts <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> LIMIT <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>redis这么读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HGET post:1 title</span><br></pre></td></tr></table></figure>

<p>其中HGET就是一个命令。Redis提供了一百多个命令（如图1-2所示），听起来很多，但是常用的却只有十几个，并且每个命令都很容易记忆，其实比SQL语句要简单很多。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120141231.png" alt="image-20190609121349841"></p>
<ol start="2">
<li>Redis使用C语言开发，代码量只有3万多行。这降低了用户通过修改Redis源代码来使之更适合自己项目需要的门槛。对于希望“榨干”数据库性能的开发者而言，这无疑是一个很大的吸引力。</li>
</ol>
<h3 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h3><blockquote>
<p>“纸上得来终觉浅，绝知此事要躬行。”<br>——陆游《冬夜读书示子聿》</p>
</blockquote>
<ul>
<li>Mac OS</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Brew 就是 homebrew</p>
</blockquote>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<p>默认端口6379,修改端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server --port 6389</span><br></pre></td></tr></table></figure>

<h4 id="初始化配置文件"><a href="#初始化配置文件" class="headerlink" title="初始化配置文件"></a>初始化配置文件</h4><p>每次redis服务启动的时候都会读取 <code>redis.conf</code></p>
<p>mac os的路径在<code>/usr/local/etc/redis.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用守护进程后，Redis会把pid写到一个pidfile中，在/var/run/redis.pid</span></span><br><span class="line">daemonize no</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span></span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定Redis监听端口，默认端口为6379</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果指定0端口，表示Redis不监听TCP连接</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 绑定的主机地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接</span></span><br><span class="line">bind 127.0.0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也就是本机</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span></span><br><span class="line">timeout 0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> debug (很多信息, 对开发／测试比较有用)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> notice (moderately verbose, what you want <span class="keyword">in</span> production probably)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel verbose</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/null</span></span><br><span class="line">logfile stdout</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置数据库的数量，默认数据库为0，可以使用select &lt;dbid&gt;命令在连接上指定数据库id</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dbid是从0到‘databases’-1的数目</span></span><br><span class="line">databases 16</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################### SNAPSHOTTING  #################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Save the DB on disk:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#   save &lt;seconds&gt; &lt;changes&gt;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#   Will save the DB if both the given number of seconds and the given</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   number of write operations against the DB occurred.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#   满足以下条件将会同步数据:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   900秒（15分钟）内有1个更改</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   300秒（5分钟）内有10个更改</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   60秒内有10000个更改</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   Note: 可以把所有“save”行注释掉，这样就取消同步操作了</span></span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定本地数据库文件名，默认值为dump.rdb</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 工作目录.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定本地数据库存放目录，文件名由上一个dbfilename配置项指定</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Also the Append Only File will be created inside this directory.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意，这里只能指定一个目录，不能指定文件名</span></span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="redis-cli简易使用"><a href="#redis-cli简易使用" class="headerlink" title="redis-cli简易使用"></a>redis-cli简易使用</h4><p>类似node命令，交互式命令行客户端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure>

<p><strong>关闭连接</strong></p>
<p>考虑到Redis有可能正在将内存中的数据同步到硬盘中，强行终止Redis进程可能会导致数据丢失。正确停止Redis的方式应该是向Redis发送SHUTDOWN命令，方法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHUTDOWN</span><br></pre></td></tr></table></figure>

<h3 id="redis命令行客户端"><a href="#redis命令行客户端" class="headerlink" title="redis命令行客户端"></a>redis命令行客户端</h3><p>redis-cli执行时会自动按照默认配置（服务器地址为127.0.0.1，端口号为6379）连接Redis，通过-h和-p参数可以自定义地址和端口号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>
<h4 id="ex-1"><a href="#ex-1" class="headerlink" title="ex:"></a>ex:</h4><ul>
<li><p>ping</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PING</span><br></pre></td></tr></table></figure></li>
<li><p>Echo hi</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECHO hi</span><br></pre></td></tr></table></figure>
<h4 id="命令返回值"><a href="#命令返回值" class="headerlink" title="命令返回值"></a>命令返回值</h4><h5 id="状态回复"><a href="#状态回复" class="headerlink" title="状态回复"></a>状态回复</h5></li>
</ul>
<p>PING</p>
<blockquote>
<p>PONG</p>
</blockquote>
<h5 id="错误回复"><a href="#错误回复" class="headerlink" title="错误回复"></a>错误回复</h5><p>随便输入一个不存在的命令</p>
<blockquote>
<p> (error) ERR unknown command <code>asdasd</code>, with args beginning with:</p>
</blockquote>
<h5 id="整数回复"><a href="#整数回复" class="headerlink" title="整数回复"></a>整数回复</h5><p><strong>Redis Incr 命令将 key 中储存的数字值增一。</strong></p>
<p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。</p>
<p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
<p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">incr abc</span><br><span class="line">set abc 20</span><br><span class="line">incr abc</span><br></pre></td></tr></table></figure>

<h5 id="字符串回复"><a href="#字符串回复" class="headerlink" title="字符串回复"></a>字符串回复</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get foo</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h5 id="多行字符串回复"><a href="#多行字符串回复" class="headerlink" title="多行字符串回复"></a>多行字符串回复</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>也可以通过cli的方式去修改<code>/usr/local/etc/redis.conf</code>中的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config set loglevel warning</span><br></pre></td></tr></table></figure>

<h4 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h4><p>而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成一个独立的数据库。<br>每个数据库对外都是以一个从0开始的递增数字命名，Redis默认支持16个数据库，可以通过配置参数databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库，如要选择1号数据库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash">SELECT 1</span></span><br><span class="line">OK</span><br><span class="line">redis [1]&gt;GET foo</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>然而这些以数字命名的数据库又与我们理解的数据库有所区别。首先Redis不支持自定义数据库的名字，每个数据库都以编号命名，开发者必须自己记录哪些数据库存储了哪些数据。另外Redis也不支持为每个数据库己记录哪些数据库存储了哪些数据。<strong>另外Redis也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限访问。</strong>最重要的一点是多个数据库之间并不是完全隔离的，比如FLUSHALL命令可以清空一个Redis实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。<strong>比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据而使用1号数据库存储B应用的数据，不同的应用应该使用不同的Redis实例存储数据</strong>。由于redis非常轻量级，一个空Redis实例占用的内存只有1MB左右，所以不用担心多个Redis实例会额外占用很多内存。</p>
<h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h3><p>了解过redis基础知识后，进入真正的redis世界。</p>
<ol>
<li>获得符合规则的键名列表</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KEYS pattern</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120141149.png" alt="image-20190609121416367"></p>
<blockquote>
<p>keys会遍历redis中所有的键，当数量过多时会影响性能，不建议使用。</p>
<p>redis命令不区分大小写。</p>
</blockquote>
<ol start="2">
<li>判断一个键是否存在</li>
</ol>
<p><code>EXISTS key</code></p>
<p>如果键存在则返回整数类型1，否则返回0。</p>
<ol start="3">
<li>删除键</li>
</ol>
<p><code>DEL key [key …]</code></p>
<p>可以删除一个或多个键，返回值是删除的键的个数。</p>
<p><strong>如何删除多个key？</strong></p>
<p>  利用linux的管道 xargs。</p>
<ol start="4">
<li>获得键值的数据类型</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis＞SET foo 1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis＞TYPE foo</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">redis＞LPUSH bar 1</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis＞TYPE bar</span><br><span class="line">list</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>LPUSH命令的作用是向指定的列表类型键中增加一个元素，如果键不存在则创建它，后面会详细介绍。</p>
</blockquote>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><blockquote>
<p> 字符串类型是Redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据。你可以用其存储用户的邮箱、JSON化的对象甚至是一张图片。一个字符串类型键允许存储的数据的最大容量是512MB。</p>
<p>JSON化的对象： JSON.stringfy()</p>
</blockquote>
<h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><ol>
<li>赋值与取值</li>
</ol>
<p><code>SET key value</code></p>
<ol start="2">
<li>递增数字</li>
</ol>
<p><code>INCR num</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET foo bar</span><br><span class="line">INCR foo</span><br></pre></td></tr></table></figure>

<p>有同学可能会想到可以借助GET和SET两个命令自己实现incr函数，伪代码如下：</p>
<ol>
<li>会通过 key取值</li>
<li>判断是否有值</li>
<li>如果没有就归 0， 有呢就进行+1操作</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incr</span>(<span class="params">$key</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> $value = redis.get($key);</span><br><span class="line">  <span class="keyword">if</span>(!$value) &#123;</span><br><span class="line">     $value = <span class="number">0</span>;</span><br><span class="line"> 	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $value = $value + <span class="number">1</span>; <span class="comment">// $value = 5</span></span><br><span class="line">    <span class="keyword">return</span> $value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果 Redis 同时只连接了一个客户端，那么上面的代码没有任何问题（其实还没有加入错误处理，不过这并不是此处讨论的重点）。可当同一时间有多个客户端连接到Redis时则有可能出现竞态条件（race condition）[3] 。例如有两个客户端A 和B 都要执行我们自己实现的 incr 函数并准备将同一个键的键值递增，当它们恰好同时执行到代码第二行时二者读取到的键值是一样的，如“5”，而后它们各自将该值递增到“6”并使用 SET 命令将其赋给原键，结果虽然对键执行了两次递增操作，最终的键值却是“6”而不是预想中的“7”。这一部分跟 “事务”，举个例子： 付款与扣款，能讲整个流程的状态初始化。</p>
</blockquote>
<h5 id="ex-文章访问量统计-标题，-正文，访问量"><a href="#ex-文章访问量统计-标题，-正文，访问量" class="headerlink" title="ex: 文章访问量统计(标题， 正文，访问量)"></a>ex: 文章访问量统计(标题， 正文，访问量)</h5><p>博客的一个常见的功能是统计文章的访问量，我们可以为每篇文章使用一个名为post:文章ID:page.view的键来记录文章的访问量，每次访问文章的时候使用INCR命令使相应的键值递增。 </p>
<ul>
<li>以 post:文章id:page 存储文章信息</li>
<li>以post:文章id:page.view 存储访问量 </li>
</ul>
<blockquote>
<p>Redis 对于键的命名并没有强制的要求，但比较好的实践是用“对象类型:对象ID:对象属性”来命名一个键，如使用键user:1:friends来存储ID为1的用户的好友列表。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串 </span></span><br><span class="line"><span class="comment">// 存储过程</span></span><br><span class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> redis(&#123;</span><br><span class="line"><span class="comment">//一些配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $post_id = client.incr(<span class="string">&#x27;post:count&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $airticle = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    <span class="attr">views</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">client.set(<span class="string">`post:<span class="subst">$&#123;$post_id&#125;</span>:data <span class="subst">$&#123;$airticle&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取过程</span></span><br><span class="line"><span class="keyword">var</span> airticle = client.get(<span class="string">&#x27;post:1:data&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(airticle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次访问文章 都会调用 </span></span><br><span class="line"><span class="keyword">var</span> $post_id = client.incr(<span class="string">&#x27;post:count&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="命令扩展"><a href="#命令扩展" class="headerlink" title="命令扩展"></a>命令扩展</h5><ol>
<li>增加指定的整数</li>
</ol>
<p><code>INCRBY key increment</code> </p>
<ol start="2">
<li>减少指定的整数</li>
</ol>
<p><code>DECR key</code></p>
<p><code>DECRBY key decrememt</code></p>
<ol start="3">
<li>增加指定浮点数</li>
</ol>
<p><code>INCRBYFLOAT key increment</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> INCRBYFLOAT bar 2.7 <span class="string">&quot;6.7&quot;</span></span> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> INCRBYFLOAT bar 5E+4 <span class="string">&quot;50006.69999999999999929&quot;</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>向尾部追加值</li>
</ol>
<p><code>APPEND key value</code></p>
<p>APPEND作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。</p>
<ol start="5">
<li>获取字符串长度</li>
</ol>
<p><code>STRLEN key</code></p>
<blockquote>
<p>前面提到了字符串类型可以存储二进制数据，所以它可以存储任何编码的字符串。例子中Redis接收到的是使用UTF-8编码的中文，由于“你”和“好”两个字的UTF-8编码的长度都是3，所以此例中会返回6。</p>
</blockquote>
<ol start="6">
<li>获取/设置多个键值</li>
</ol>
<p><code>MGET</code> <code>MSET</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MSET key1 v1 key2 v2</span><br><span class="line">MGET key1 key2</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>位操作</li>
</ol>
<p><code>GETBIT key offset</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET foo bar</span><br></pre></td></tr></table></figure>

<p>b,a,r 对应的ASCII码分别为98，97，114。转换成二进制分别为 1100010， 1100001， 1110010。</p>
<blockquote>
<p>所有的文字： 英文 ，汉子，汉语，日语，符号。。。其实都是通过数字。</p>
</blockquote>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120141133.png" alt="image-20190609121432754"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GETBIT foo 0</span><br><span class="line">GETBIT foo 6</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用位操作可以非常紧凑的存储布尔值。比如如果需要存储 “男，女”。如果用数字0，1存储则需要 100万字节 约等于 1M， 但是如果用二进制存储只需要 100K左右, 只占用计算机的一个位。</p>
<p>再举个例子：</p>
<p>假如我们的id是从 1000000开始递增，我们则可以先减去1000000再进行递增存储，这样可以节约空间。</p>
</blockquote>
<h3 id="散列类型"><a href="#散列类型" class="headerlink" title="散列类型"></a>散列类型</h3><p>假设我只想读取文章的标题，但是会需要把所有文章相关的信息都拿过来反序列化(标题，正文，阅读量。。。)，会造成资源的浪费。</p>
<p>不仅读取有这个问题，修改也有这个问题。</p>
<p><strong>所以，散列解决了这个问题。</strong></p>
<h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>散列适合存储对象：使用对象类别和ID构成键名，使用字段表示对象的属性，而字段值则存储属性值。</p>
<h5 id="ex-汽车数据模型"><a href="#ex-汽车数据模型" class="headerlink" title="ex: 汽车数据模型"></a>ex: 汽车数据模型</h5><p>这是一种二维的数据结构。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120141120.png" alt="image-20190609121443762"></p>
<p>回想 mysql数据库结构。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120141110.png" alt="image-20190609121454590"></p>
<p>假设某些数据需要新增一个字段：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120141102.png" alt="image-20190609121504859"></p>
<p>对于2，3这两天数据来说data是多余的，这样会变得越来越难维护。为了解决这个问题，必须新建额外的表进行关联。</p>
<blockquote>
<p> 而redis的散列类型不存在这个问题，我们可以为任何键新增或删除字段而不影响其它。</p>
</blockquote>
<h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><ol>
<li>赋值与取值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; HSET car price 500 </span><br><span class="line">(integer) 1 </span><br><span class="line">redis&gt; HSET car name BMW </span><br><span class="line">(integer) 1 </span><br><span class="line">redis&gt; HGET car name &quot;BMW&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>HSET 命令的方便之处在于不区分插入和更新操作，这意味着修改数据时不用事先判断字段是否存在来决定要执行的是插入操作（update）还是更新操作（insert）。当执行的是插入操作时（即之前字段不存在）HSET命令会返回1，当执行的是更新操作时（即之前字段已经存在）HSET命令会返回0。更进一步，当键本身不存在时，HSET命令还会自动建立它。</p>
</blockquote>
<p>2.获取键中所有的字段和值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; HGETALL car </span><br><span class="line">1) &quot;price&quot; </span><br><span class="line">2) &quot;500&quot; </span><br><span class="line">3) &quot;name&quot; </span><br><span class="line">4) &quot;BMW&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不要担心结构不好用，在nodejs中会把返回值封装成js的object</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">redis.hgetall(<span class="string">&quot;car&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, car</span>) </span>&#123; </span><br><span class="line">	<span class="comment">//hgetall 方法的返回的值被封装成了 JavaScript的对象 </span></span><br><span class="line">	<span class="built_in">console</span>.log(car.price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.判断字段是否存在</p>
<p><code>HEXISTS key field</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HEXISTS car model</span> </span><br><span class="line">(integer) 0 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET car model C200</span> </span><br><span class="line">(integer) 1 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HEXISTS car model</span> </span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>增加数字</li>
</ol>
<p><code>HINCRBY key field increment</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HINCRBY person score 60</span> </span><br><span class="line">(integer) 60</span><br></pre></td></tr></table></figure>

<p>5.删除字段</p>
<p><code>HDEL key field [field …]</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HDEL car price</span> </span><br><span class="line">(integer) 1 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HDEL car price</span> </span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>刚才存储文章的例子，需要序列化和反序列化之后在进行读写。会造成2个问题：</p>
<ol>
<li>会产生竞态， 2个客户端同时操作会冲突，最终只有一个属性被修改。没有原子化操作</li>
<li>每次修改或者读取都需要反序列化，消耗性能。</li>
</ol>
<p>新增一个需求，一般文章都会有缩略名。比如文章的标题叫做”This is a great post”，它的缩略名可以为”this-is-a-greate-post”。缩略名可以用于生成文章的地址栏或者其它用处。</p>
<h5 id="使用散列改造"><a href="#使用散列改造" class="headerlink" title="使用散列改造"></a>使用散列改造</h5><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120141049.png" alt="image-20190609121516741"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 散列其实就是hash  hget hset</span></span><br><span class="line">var redis = require(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line">var client = <span class="keyword">new</span> redis(&#123;</span><br><span class="line"><span class="comment">//一些配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// # 1. 文章的赋值</span></span><br><span class="line"><span class="comment">// # 自增的id </span></span><br><span class="line">var $post_id = client.incr(<span class="string">&#x27;posts:count&#x27;</span>);</span><br><span class="line">var $slug = <span class="string">&#x27;hello-world&#x27;</span>;</span><br><span class="line">var $title = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">var $content = <span class="string">&#x27;xxxxxxxxxxxxx&#x27;</span>;</span><br><span class="line">var views = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// # 文章的缩略名和id互相有一个引用来维持关系  slug.to.id</span></span><br><span class="line"><span class="comment">// # HSETNX 也是赋值  如果这个值已经存在 则返回0，并且赋值失败  反之返回1， 赋值成功</span></span><br><span class="line">var isSlug = client.hsetnx(`slug.to.id $&#123;$slug&#125; $&#123;$post_id&#125;`);</span><br><span class="line"></span><br><span class="line"><span class="comment">// # 1.通过散列去存储文章</span></span><br><span class="line"><span class="keyword">if</span>(isSlug === <span class="number">0</span>) &#123;</span><br><span class="line">    client.<span class="built_in">exit</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    client.hmset(`post:$&#123;$post_id&#125; title $&#123;$title&#125; content $&#123;$content&#125; views $&#123;$views&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # 2. 读取文章</span></span><br><span class="line">var postID = client.hget(<span class="string">&#x27;slug.to.id $slug&#x27;</span>); </span><br><span class="line"><span class="keyword">if</span> (!postID) &#123;</span><br><span class="line">    client.<span class="built_in">exit</span>(<span class="string">&#x27;文章不存在&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    var post = client.hgetall(`post:$&#123;postID&#125;`, (err, data) =&gt; &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # 3.修改缩略名</span></span><br><span class="line"><span class="comment">// # 加入你要给id=42的文章  修改缩略名</span></span><br><span class="line">var newSlug = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">var isSlugExit = client.hsetnx(`slug.to.id $&#123;newSlug&#125; <span class="number">42</span>`) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isSlugExit === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="string">&#x27;缩略名已存在，请换其它&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    var oldSlug = client = client.hget(`post:<span class="number">42</span> slug`);</span><br><span class="line">    client.hset(`post:<span class="number">42</span> slug $&#123;newSlug&#125;`);</span><br><span class="line">    client.hdel(`slug.to.id $&#123;$oldSlug&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="命令补充"><a href="#命令补充" class="headerlink" title="命令补充"></a>命令补充</h4><ol>
<li>只获取字段名或字段值</li>
</ol>
<p><code>HKEYS key</code></p>
<p><code>HVALS key</code></p>
<ol start="2">
<li>获得字段数量</li>
</ol>
<p><code>HLEN key</code></p>
<h3 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>列表类型可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。</p>
<blockquote>
<p>列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为O(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的（和从只有20个元素的列表中获取头部或尾部的10条记录的速度是一样的）。不过使用链表的代价是通过索引访问元素比较慢。</p>
</blockquote>
<p>和js的数组有什么区别？</p>
<ul>
<li>在js里面数组其实也是对象，字典</li>
<li>redis的列表却是链表</li>
</ul>
<h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><ol>
<li>向列表两端增加元素</li>
</ol>
<p><code>LPUSH key value [value …]</code></p>
<p><code>RPUSH key value [value …]</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> LPUSH numbers 1</span> </span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从列表两端弹出元素</li>
</ol>
<p><code>LPOP key</code></p>
<p><code>RPOP key</code></p>
<ol start="3">
<li>获取列表中元素的个数</li>
</ol>
<p><code>LLEN key</code></p>
<ol start="4">
<li>获取列表片段</li>
</ol>
<p><code>LRANGE key start stop</code></p>
<blockquote>
<p>LRANGE 0 -1 可以获取列表中所有的元素</p>
</blockquote>
<ol start="5">
<li>删除列表中指定的值</li>
</ol>
<p><code>LREM key count value</code></p>
<p>LREM命令会删除列表中前count个值为value的元素，返回值是实际删除的元素个数。根据count值的不同，LREM命令的执行方式会略有差异。</p>
<p>（1）当 count &gt; 0时 LREM 命令会从列表左边开始删除前 count 个值为 value的元素。 </p>
<p>（2）当 count &lt; 0时 LREM 命令会从列表右边开始删除前|count|个值为 value 的元素。</p>
<p>（3）当 count = 0是 LREM命令会删除所有值为 value的元素。例如：</p>
<h4 id="ex：储存文章id列表"><a href="#ex：储存文章id列表" class="headerlink" title="ex：储存文章id列表"></a>ex：储存文章id列表</h4><p>新增需求： 我们存储的文章需要展示许多条，如何做分页功能。</p>
<blockquote>
<p>为了解决这个问题，我们使用列表类型键posts:list记录文章ID列表。当发布新文章时使用LPUSH命令把新文章的ID加入这个列表中，另外删除文章时也要记得把列表中的文章ID 删除，就像这样：LREM posts:list 1 要删除的文章 ID</p>
</blockquote>
<p>有了文章 ID列表，就可以使用 LRANGE命令来实现文章的分页显示了。伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> redis(&#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentPage = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listLength = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> start = (currentPage - <span class="number">1</span>) * listLength;</span><br><span class="line"><span class="keyword">var</span> end = currentPage * listLength - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> postIdArr = client.lrange(<span class="string">`post:list <span class="subst">$&#123;start&#125;</span> <span class="subst">$&#123;end&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">postIdArr.forEach(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    client.hgetall(<span class="string">`post:<span class="subst">$&#123;id&#125;</span>`</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>美中不足的一点是散列类型没有类似字符串类型的 MGET命令那样可以通过一条命令同时获得多个键的键值的版本，所以对于每个文章ID都需要请求一次数据库，也就都会产生一次往返时延（round-trip delay time）[11] ，之后我们会介绍使用管道和脚本来优化这个问题。</p>
<p>另外使用列表类型键存储文章ID列表有以下两个问题。 </p>
<p>（1）文章的发布时间不易修改：修改文章的发布时间不仅要修改post:文章ID中的time字段，还需要按照实际的发布时间重新排列posts:list中的元素顺序，而这一操作相对比较繁琐。 </p>
<p>（2）当文章数量较多时访问中间的页面性能较差：前面已经介绍过，列表类型是通过链表实现的，所以当列表元素非常多时访问中间的元素效率并不高。</p>
</blockquote>
<h4 id="ex-存储评论列表"><a href="#ex-存储评论列表" class="headerlink" title="ex: 存储评论列表"></a>ex: 存储评论列表</h4><p>在博客中还可以使用列表类型键存储文章的评论。由于博客不允许访客修改自己发表的评论，而且考虑到读取评论时需要获得评论的全部数据（评论者姓名，联系方式，评论时间和评论内容），不像文章一样有时只需要文章标题而不需要文章正文。所以适合将一条评论的各个元素序列化成字符串后作为列表类型键中的元素来存储。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> commentsStr = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    <span class="attr">author</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">time</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">client.lpush(<span class="string">&#x27;post:id:comment&#x27;</span>, commentsStr);</span><br></pre></td></tr></table></figure>

<h4 id="命令补充-1"><a href="#命令补充-1" class="headerlink" title="命令补充"></a>命令补充</h4><ol>
<li><p>获得/设置指定索引的元素值</p>
<p><code>LINDEX key index </code></p>
<p><code>LSET key index value</code></p>
</li>
<li><p>只保留列表指定片段</p>
<p><code>LTRIM</code> 命令可以删除指定索引范围之外的所有元素，其指定列表范围的方法和LRANGE命令相同。就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; LRANGE numbers 0 -1 </span><br><span class="line">1) &quot;1&quot; </span><br><span class="line">2) &quot;2&quot; </span><br><span class="line">3) &quot;7&quot; </span><br><span class="line">4) &quot;3&quot; </span><br><span class="line">redis&gt; LTRIM numbers 1 2 </span><br><span class="line">OK </span><br><span class="line">redis&gt; LRANGE numbers 0 1 </span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;7&quot;</span><br></pre></td></tr></table></figure>

<p>LTRIM命令常和LPUSH命令一起使用来限制列表中元素的数量，比如记录日志时我们希望只保留最近的100条日志，则每次加入新元素时调用一次LTRIM命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LPUSH logs $newLog </span><br><span class="line">LTRIM logs 0 99</span><br></pre></td></tr></table></figure></li>
<li><p>向列表中插入元素</p>
<p><code>LINSERT key BEFORE|AFTER pivot value</code></p>
<p>LINSERT 命令首先会在列表中从左到右查找值为 pivot 的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。 </p>
<p>LINSERT命令的返回值是插入后列表的元素个数。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; LRANGE numbers 0 -1 </span><br><span class="line">1) &quot;2&quot; </span><br><span class="line">2) &quot;7&quot;</span><br><span class="line">3) &quot;0&quot; </span><br><span class="line">redis&gt; LINSERT numbers AFTER 7 3 </span><br><span class="line">(integer) 4 </span><br><span class="line">redis&gt; LRANGE numbers 0 -1 </span><br><span class="line">1) &quot;2&quot; </span><br><span class="line">2) &quot;7&quot; </span><br><span class="line">3) &quot;3&quot; </span><br><span class="line">4) &quot;0&quot; </span><br><span class="line">redis&gt; LINSERT numbers BEFORE 2 1 </span><br><span class="line">(integer) 5 </span><br><span class="line">redis&gt; LRANGE numbers 0 -1 </span><br><span class="line">1) &quot;1&quot; </span><br><span class="line">2) &quot;2&quot; </span><br><span class="line">3) &quot;7&quot; </span><br><span class="line">4) &quot;3&quot; </span><br><span class="line">5) &quot;0&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>将元素从一个列表转到另一个列表</p>
<p><code>RPOPLPUSH source destination</code></p>
<p>RPOPLPUSH是个很有意思的命令，从名字就可以看出它的功能：先执行RPOP命令再执行LPUSH命令。RPOPLPUSH命令会先从source列表类型键的右边弹出一个元素，然后将其加入到destination列表类型键的左边，并返回这个元素的值，整个过程是原子的。</p>
<blockquote>
<p>当把列表类型作为队列使用时，RPOPLPUSH 命令可以很直观地在多个队列中传递数据。当source和destination相同时，RPOPLPUSH命令会不断地将队尾的元素移到队首，借助这个特性我们可以实现一个网站监控系统：使用一个队列存储需要监控的网址，然后监控程序不断地使用 RPOPLPUSH 命令循环取出一个网址来测试可用性。这里使用RPOPLPUSH命令的好处在于在程序执行过程中仍然可以不断地向网址列表中加入新网址，而且整个系统容易扩展，允许多个客户端同时处理队列。</p>
</blockquote>
</li>
</ol>
<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><p>Redis 有一种数据类型很适合存储文章的标签，它就是集合类型。</p>
<h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>集合的概念高中的数学课就学习过。在集合中的每个元素都是不同的，且没有顺序。一个集合类型（set）键可以存储至多2的32次方 −1个（相信这个数字对大家来说已经很熟悉了）字符串。 集合类型和列表类型有相似之处，但很容易将它们区分开来，</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120141036.png" alt="image-20190611135515274"></p>
<p>集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型在Redis内部是使用值为空的散列表（hash table）实现的，所以这些操作的时间复杂度都是O(1)。最方便的是多个集合类型键之间还可以进行并集、交集和差集运算，稍后就会看到灵活运用这一特性带来的便利。</p>
<h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><ol>
<li><p>增加/删除元素</p>
<p><code>SADD key member [member …] </code></p>
<p><code>SREM key member [member …]</code></p>
<p>SADD 命令用来向集合中增加一个或多个元素，如果键不存在则会自动创建。因为在一个集合中不能有相同的元素，所以如果要加入的元素已经存在于集合中就会忽略这个元素。本命令的返回值是成功加入的元素数量（忽略的元素不计算在内）。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD letters a</span> </span><br><span class="line">(integer) 1 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD letters a b c</span> </span><br><span class="line">(integer) 2 </span><br></pre></td></tr></table></figure>

<p>第二条SADD命令的返回值为2是因为元素“a”已经存在，所以实际上只加入了两个元素。</p>
<p>SREM命令用来从集合中删除一个或多个元素，并返回删除成功的个数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; SREM letters c d </span><br><span class="line">(integer) 1 </span><br></pre></td></tr></table></figure>

<p>由于元素“d”在集合中不存在，所以只删除了一个元素，返回值为1。</p>
</li>
</ol>
<p>2．获得集合中的所有元素 </p>
<p><code>           SMEMBERS key</code> </p>
<p>SMEMBERS命令会返回集合中的所有元素，例如： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; SMEMBERS letters </span><br><span class="line">1) &quot;b&quot; </span><br><span class="line">2) &quot;a&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>判断元素是否在集合中 </p>
<p><code>SISMEMBER key member</code></p>
<p> 判断一个元素是否在集合中是一个时间复杂度为O(1)的操作，无论集合中有多少个元素，SISMEMBER命令始终可以极快地返回结果。当值存在时判断一个元素是否在集合中是一个时间复杂度为O(1)的操作，无论集合中有多少个元素，SISMEMBER命令始终可以极快地返回结果。当值存在时 SISMEMBER命令返回1，当值不存在或键不存在时返回0，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SISMEMBER letters a</span> </span><br><span class="line">(integer) 1 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SISMEMBER letters d</span> </span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li>
</ol>
<p>4．集合间运算</p>
<p><code>SDIFF key [key „]</code></p>
<p><code>SINTER key [key „]</code> </p>
<p><code>SUNION key [key „]</code></p>
<p>接下来要介绍的3个命令都是用来进行多个集合间运算的。 </p>
<p>1）SDIFF命令用来对多个集合执行差集运算。集合A与集合B的差集表示为A−B，代表所有属于A且不属于B的元素构成的集合（如图3-13所示），即A−B ={x | x∈A且x∈B}。例如：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120140941.png" alt="image-20190611140833117"></p>
<p>{1, 2, 3} - {2, 3, 4} = {1} {2, 3, 4} - {1, 2, 3} = {4} SDIFF命令的使用方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD setA 1 2 3</span> </span><br><span class="line">(integer) 3 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD setB 2 3 4</span> </span><br><span class="line">(integer) 3 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SDIFF setA setB</span> </span><br><span class="line">1) &quot;1&quot; </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SDIFF setB setA</span> </span><br><span class="line">1) &quot;4&quot;</span><br></pre></td></tr></table></figure>

<p>SDIFF命令支持同时传入多个键，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD setC 2 3</span> </span><br><span class="line">(integer) 2 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SDIFF setA setB setC</span> </span><br><span class="line">1) &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p>（2）SINTER命令用来对多个集合执行交集运算。集合A与集合B的交集表示为A ∩ B，代表所有属于A 且属于B的元素构成的集合（如图3-14所示），即A ∩ B ={x | x ∈ A 且x ∈B}。</p>
<p>例如： {1, 2, 3} ∩ {2, 3, 4} = {2, 3} SINTER命令的使用方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SINTER setA setB</span> </span><br><span class="line">1) &quot;2&quot; </span><br><span class="line">2) &quot;3&quot;</span><br></pre></td></tr></table></figure>

<p>SINTER命令同样支持同时传入多个键，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SINTER setA setB setC</span> </span><br><span class="line">1) &quot;2&quot; </span><br><span class="line">2) &quot;3&quot;</span><br></pre></td></tr></table></figure>

<p>（3）SUNION命令用来对多个集合执行并集运算。集合A与集合B的并集表示为A∪B，代表所有属于A 或属于B的元素构成的集合（如图3-15所示）即A∪B ={x | x∈A或x ∈B}。</p>
<p>例如： {1, 2, 3} ∪{2, 3, 4} = {1, 2, 3, 4}</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120140931.png" alt="image-20190611141307449"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SUNION setA setB</span> </span><br><span class="line">1) &quot;1&quot; </span><br><span class="line">2) &quot;2&quot; </span><br><span class="line">3) &quot;3&quot; </span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure>

<p>SUNION命令同样支持同时传入多个键，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; SUNION setA setB setC </span><br><span class="line">1) &quot;1&quot; </span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot; </span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure>

<h4 id="ex-存储文章标签"><a href="#ex-存储文章标签" class="headerlink" title="ex: 存储文章标签"></a>ex: 存储文章标签</h4><p>考虑到一个文章的所有标签都是互不相同的，而且展示时对这些标签的排列顺序并没有要求，我们可以使用集合类型键存储文章标签。</p>
<p> 对每篇文章使用键名为post:文章ID:tags的键存储该篇文章的标签。具体操作如伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> redis(&#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.sadd(<span class="string">&#x27;post:42:tags 杂文 技术文章 java&#x27;</span>);</span><br><span class="line"></span><br><span class="line">client.srem(<span class="string">&#x27;post:42:tags 杂文&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tags = client.smembers(<span class="string">&#x27;post:42:tags&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用集合类型键存储标签适合需要单独增加或删除标签的场合。如在 WordPress博客程序中无论是添加还是删除标签都是针对单个标签的（如图 3-16 所示），可以直观地使用SADD和SREM命令完成操作。</p>
<p>另一方面，有些地方需要用户直接设置所有标签后一起上传修改，图3-17所示是某网站的个人资料编辑页面，用户编辑自己的爱好后提交，程序直接覆盖原来的标签数据，整个过程没有针对单个标签的操作，并未利用到集合类型的优势，所以此时也可以直接使用字符串类型键存储标签数据。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120140920.png" alt="image-20190611144733359"></p>
<blockquote>
<p> 之所以特意提到这个在实践中的差别是想说明对于 Redis 存储方式的选择并没有绝对的规则，比如之前介绍过使用列表类型存储访客评论，但是在一些特定的场合下散列类型甚至字符串类型可能更适合。</p>
</blockquote>
<h4 id="ex-通过标签搜索文章"><a href="#ex-通过标签搜索文章" class="headerlink" title="ex: 通过标签搜索文章"></a>ex: 通过标签搜索文章</h4><p>有时我们还需要列出某个标签下的所有文章，甚至需要获得同时属于某几个标签的文章列表，这种需求在传统关系数据库中实现起来比较复杂，下面举一个例子。 </p>
<p>现有3张表，即posts、tags和posts_tags，分别存储文章数据、标签、文章与标签的对应关系。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120140908.png" alt="image-20190611144910454"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120140859.png" alt="image-20190611144920479"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120140850.png" alt="image-20190611144927774"></p>
<p>为了找到同时属于“Java”、“MySQL”和“Redis”这3个标签的文章，需要使用如下的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.post_title <span class="keyword">FROM</span> posts_tags pt, posts p, tags t <span class="keyword">WHERE</span> pt.tag_id <span class="operator">=</span> t.tag_id <span class="keyword">AND</span> (t.tag_name <span class="keyword">IN</span> (<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;MySQL&#x27;</span>, <span class="string">&#x27;Redis&#x27;</span>)) <span class="keyword">AND</span> p.post_id <span class="operator">=</span> pt.post_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> p.post_id <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(p.post_id)<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很明显看到这样的 SQL 语句不仅效率相对较低，而且不易阅读和维护。而使用Redis可以很简单直接地实现这一需求。</p>
</blockquote>
<p>为每一个标签使用一个名为具体做法是为每个标签使用一个名为tag:标签名称:posts的集合类型键存储标有该标签的文章ID列表。假设现在有3篇文章，ID分别为1、2、3，其中ID为1的文章标签是“Java”，ID 为 2 的文章标签是“Java”、“MySQL”，ID 为 3 的文章标签是“Java”、“MySQL”和“Redis”。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120140842.png" alt="image-20190611145903697"></p>
<p>最简单的，当需要获取标记“MySQL”标签的文章时只需要使用命令 <code>SMEMBER Stag:MySQL:posts</code>即可。如果要实现找到同时属于Java、MySQL和Redis 3 个标签的文章，只需要将tag:Java:posts、tag:MySQL:posts和tag:Redis:posts这3个键取交集，借助SINTER命令即可轻松完成。</p>
<h4 id="命令补充-2"><a href="#命令补充-2" class="headerlink" title="命令补充"></a>命令补充</h4><ol>
<li>获取集合中的元素个数</li>
</ol>
<p><code>SCARD key</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; SMEMBERS letters </span><br><span class="line">1) &quot;b&quot; </span><br><span class="line">2) &quot;a&quot; </span><br><span class="line">redis&gt; SCARD letters </span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>进行集合运算并将结果存储</p>
<p><code>SDIFFSTORE destination key [key …] </code></p>
<p><code>SINTERSTORE destination key [key …]</code></p>
<p><code>SUNIONSTORE destination key [key …]</code></p>
</li>
</ol>
<p>SDIFFSTORE命令和SDIFF命令功能一样，唯一的区别就是前者不会直接返回运算结果，而是将结果存储在destination键中。 SDIFFSTORE命令常用于需要进行多步集合运算的场景中，如需要先计算差集再将结果和其他键计算交集。 SINTERSTORE和SUNIONSTORE命令与之类似，不再赘述。</p>
<ol start="3">
<li><p>随机获得集合中的元素</p>
<p><code>SRANDMEMBER key [count]</code></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; SRANDMEMBER letters </span><br><span class="line">&quot;a&quot; </span><br><span class="line">redis&gt; SRANDMEMBER letters </span><br><span class="line">&quot;b&quot; </span><br><span class="line">redis&gt; SRANDMEMBER letters </span><br><span class="line">&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>还可以传递count参数来一次随机获得多个元素，根据count的正负不同，具体表现也不同。</p>
<p>（1）当count为正数时，SRANDMEMBER会随机从集合里获得count个不重复的元素。如果count的值大于集合中的元素个数，则SRANDMEMBER会返回集合中的全部元素。 </p>
<p>（2）当count为负数时，SRANDMEMBER会随机从集合里获得|count|个的元素，这些元素有可能同。</p>
<p>4．从集合中弹出一个元素</p>
<p><code>SPOP key</code></p>
<p>我们学习过LPOP命令，作用是从列表左边弹出一个元素（即返回元素的值并删除它）。SPOP命令的作用与之类似，但由于集合类型的元素是无序的，<strong>所以 SPOP命令会从集合中随机选择一个元素弹出</strong>。</p>
<h3 id="有序集合类型"><a href="#有序集合类型" class="headerlink" title="有序集合类型"></a>有序集合类型</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>有序集合类型（sorted set）的特点从它的名字中就可以猜到，它与上一节介绍的集合类型的区别就是“有序”二字。</p>
<p>在集合类型的基础上有序集合类型为集合中的每个元素都关联了一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高（或最低）的前N个元素、获得指定分数范围内的元素等与分数有关的操作。虽然集合中每个元素都是不同的，但是它们的分数却可以相同。 有序集合类型在某些方面和列表类型有些相似。 </p>
<p>（1）二者都是有序的。 </p>
<p>（2）二者都可以获得某一范围的元素。</p>
<p> 但是二者有着很大的区别，这使得它们的应用场景也是不同的。</p>
<p>（1）列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会较慢，所以它更加适合实现如“新鲜事”或“日志”这样很少访问中间元素的应用。</p>
<p>（2）有序集合类型是使用散列表和跳跃表（Skip list）实现的，所以即使读取位于中间部分的数据速度也很快（时间复杂度是O(log(N))）。 </p>
<p>（3）列表中不能简单地调整某个元素的位置，但是有序集合可以（通过更改这个元素的分数）。 </p>
<p>（4）有序集合要比列表类型更耗费内存。</p>
<h4 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h4><ol>
<li>增加元素</li>
</ol>
<p><code>ZADD key score member [score member...]</code></p>
<p>ZADD 命令用来向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。ZADD命令的返回值是新加入到集合中的元素个数（不包含之前已经存在的元素）。 </p>
<p>假设我们用有序集合模拟计分板，现在要记录Tom、Peter和David三名运动员的分数（分别是89分、67分和100分）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD scoreboard 89 Tom 67 Peter 100 David</span> </span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>这时我们发现Peter的分数录入有误，实际的分数应该是76分，可以用ZADD命令修改Peter的分数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD scoreboard 76 Peter</span> </span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>分数不仅可以是整数，还支持双精度浮点数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; ZADD testboard 17E+307 a </span><br><span class="line">(integer) 1 </span><br><span class="line">redis&gt; ZADD testboard 1.5 b </span><br><span class="line">(integer) 1 </span><br><span class="line">redis&gt; ZADD testboard +inf c </span><br><span class="line">(integer) 1 </span><br><span class="line">redis&gt; ZADD testboard -inf d </span><br><span class="line">(integer) 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获得元素的分数</li>
</ol>
<p><code>ZSCORE key member</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; ZSCORE scoreboard Tom </span><br><span class="line">&quot;89&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>获得排名在某个范围的元素列表</li>
</ol>
<p><code>ZRANGE key start stop [WITHSCORES] </code></p>
<p><code>ZREVRANGE key start stop [WITHSCORES]</code></p>
<p>ZRANGE命令会按照元素分数从小到大的顺序返回索引从 start到stop之间的所有元素（包含两端的元素）。ZRANGE命令与LRANGE命令十分相似，如索引都是从0开始，负数代表从后向前查找（−1表示最后一个元素）。就像这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZRANGE scoreboard 0 2</span> </span><br><span class="line">1) &quot;Peter&quot; </span><br><span class="line">2) &quot;Tom&quot; </span><br><span class="line">3) &quot;David&quot; </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZRANGE scoreboard 1 -1</span> </span><br><span class="line">1) &quot;Tom&quot; </span><br><span class="line">2) &quot;David&quot;</span><br></pre></td></tr></table></figure>

<p><strong>如果需要同时获得元素的分数</strong>的话可以在 ZRANGE 命令的尾部加上 WITHSCORES 参数，这时返回的数据格式就从“元素1, 元素2, „, 元素n”变为了“元素1, 分数1, 元素2, 分数2, „, 元素n, 分数n”。</p>
<p>ZRANGE命令的时间复杂度为O(log n+m)（其中n为有序集合的基数，m为返回的元素个数）。</p>
<p>如果两个元素的分数相同，Redis会按照字典顺序（即”0”&lt;”9”&lt;”A”&lt;”Z”&lt;”a”&lt;”z”这样的顺序）来进行排列。再进一步，如果元素的值是中文怎么处理呢？答案是取决于中文的编码方式，如使用UTF-8编码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD chineseName 0 马华 0 刘墉 0 司马光 0 赵哲</span> </span><br><span class="line">(integer) 4 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZRANGE chineseName 0 -1</span></span><br><span class="line">1) &quot;\xe5\x88\x98\xe5\xa2\x89&quot; </span><br><span class="line">2) &quot;\xe5\x8f\xb8\xe9\xa9\xac\xe5\x85\x89&quot; </span><br><span class="line">3) &quot;\xe8\xb5\xb5\xe5\x93\xb2&quot; </span><br><span class="line">4) &quot;\xe9\xa9\xac\xe5\x8d\x8e&quot;</span><br></pre></td></tr></table></figure>

<p>可见此时Redis依然按照字典顺序排列这些元素。 <strong>ZREVRANGE命令和ZRANGE的唯一不同在于ZREVRANGE命令是按照元素分数从大到小的顺序给出结果的。</strong></p>
<ol start="4">
<li>获得指定分数范围的元素</li>
</ol>
<p><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></p>
<p>ZRANGEBYSCORE 命令参数虽然多，但是都很好理解。该命令按照元素分数从小到大的顺序返回分数在min和max之间（包含min和max）的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; ZRANGEBYSCORE scoreboard 80 100</span><br><span class="line">1) &quot;Tom&quot; </span><br><span class="line">2) &quot;David&quot;</span><br></pre></td></tr></table></figure>

<p>如果希望分数范围不包含端点值，可以在分数前加上“(”符号。例如，希望返回”80分到100分的数据，可以含80分，但不包含100分，则稍微修改一下上面的命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; ZRANGEBYSCORE scoreboard 80 (100 </span><br><span class="line">1) &quot;Tom&quot;</span><br></pre></td></tr></table></figure>

<p>min和max还支持无穷大，同ZADD命令一样，-inf和+inf分别表示负无穷和正无穷。比如你希望得到所有分数高于80分（不包含80分）的人的名单，但你却不知道最高分是多少（虽然有些背离现实，但是为了叙述方便，这里假设可以获得的分数是无上限的），这时就可以用上+inf了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; ZRANGEBYSCORE scoreboard (80 +inf </span><br><span class="line">1) &quot;Tom&quot;</span><br><span class="line">2) &quot;David&quot;</span><br></pre></td></tr></table></figure>

<p>WITHSCORES参数的用法与ZRANGE命令一样，不再赘述。 </p>
<p>了解 SQL 语句的读者对 LIMIT offset count 应该很熟悉，在本命令中 LIMIT offset count 与 SQL 中的用法基本相同，即在获得的元素列表的基础上向后偏移offset个元素，并且只获取前count个元素。为了便于演示，我们先向scoreboard键中再增加些元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; ZADD scoreboard 56 Jerry 92 Wendy 67 Yvonne </span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; ZRANGE scoreboard 0 -1 WITHSCORES </span><br><span class="line">1) &quot;Jerry&quot; </span><br><span class="line">2) &quot;56&quot; </span><br><span class="line">3) &quot;Yvonne&quot;</span><br><span class="line">4) &quot;67&quot; </span><br><span class="line">5) &quot;Peter&quot; </span><br><span class="line">6) &quot;76&quot; </span><br><span class="line">7) &quot;Tom&quot; </span><br><span class="line">8) &quot;89&quot; </span><br><span class="line">9) &quot;Wendy&quot; </span><br><span class="line">10) &quot;92&quot; </span><br><span class="line">11) &quot;David&quot; </span><br><span class="line">12) &quot;100&quot;</span><br></pre></td></tr></table></figure>

<p>想获得分数高于60分的从第二个人开始的3个人：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZRANGEBYSCORE scoreboard 60 +inf LIMIT 1 3</span> </span><br><span class="line">1) &quot;Peter&quot; </span><br><span class="line">2) &quot;Tom&quot; </span><br><span class="line">3) &quot;Wendy&quot;</span><br></pre></td></tr></table></figure>

<p>那么，如果想获取分数低于或等于 100 分的前 3 个人怎么办呢？这时可以借助ZREVRANGEBYSCORE命令实现。对照前文提到的ZRANGE命令和ZREVRANGE命令之间的关系，相信很容易能明白ZREVRANGEBYSCORE 命令的功能。需要注意的是ZREVRANGEBYSCORE 命令不仅是按照元素分数从大往小的顺序给出结果的，而且它的 min和max参数的顺序和ZRANGEBYSCORE命令是相反的。就像这样： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZREVRANGEBYSCORE scoreboard 100 0 LIMIT 0 3</span> </span><br><span class="line">1) &quot;David&quot; </span><br><span class="line">2) &quot;Wendy&quot; </span><br><span class="line">3) &quot;Tom&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>增加某个元素的分数</li>
</ol>
<p><code>ZINCRBY key increment member</code></p>
<p>ZINCRBY 命令可以增加一个元素的分数，返回值是更改后的分数。例如，想给 Jerry加4分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; ZINCRBY scoreboard 4 Jerry</span><br><span class="line">&quot;60&quot; </span><br><span class="line">redis&gt; ZINCRBY scoreboard -4 </span><br><span class="line">Jerry </span><br><span class="line">&quot;56&quot;</span><br></pre></td></tr></table></figure>

<h4 id="ex-实现按点击量排名"><a href="#ex-实现按点击量排名" class="headerlink" title="ex: 实现按点击量排名"></a>ex: 实现按点击量排名</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> redis(&#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentPage = <span class="number">1</span>;  <span class="comment">// 当前页面为1</span></span><br><span class="line"><span class="keyword">var</span> listLength = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start = (currentPage - <span class="number">1</span>) * listLength;</span><br><span class="line"><span class="keyword">var</span> end = currentPage * listLength - <span class="number">1</span>; <span class="comment">// 0-9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> postID = client.zrevrange(<span class="string">`post:page.view <span class="subst">$&#123;start&#125;</span> <span class="subst">$&#123;end&#125;</span>`</span>);    <span class="comment">// 递减</span></span><br><span class="line"></span><br><span class="line">postID.forEach(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    client.hgetall(<span class="string">`post:<span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果需要按时间排序，只需修改文章存储时的分数为对应文章发布的Unix时间即可。</p>
</blockquote>
<h4 id="命令补充-3"><a href="#命令补充-3" class="headerlink" title="命令补充"></a>命令补充</h4><ol>
<li>获取集合中元素的数量</li>
</ol>
<p><code>ZCARD key</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZCARD scoreboard</span></span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获得指定分数范围内的元素个数</li>
</ol>
<p><code>ZCOUNT key min max</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; ZCOUNT scoreboard 90 100</span><br><span class="line">(integer) 2</span><br><span class="line">redis&gt; ZCOUNT scoreboard (89 +inf </span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<p>3．删除一个或多个元素</p>
<p><code>ZREM key member [member …] </code></p>
<p>ZREM命令的返回值是成功删除的元素数量（不包含本来就不存在的元素）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZREM scoreboard Wendy</span> </span><br><span class="line">(integer) 1 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZCARD scoreboard</span> </span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>

<p>4．按照排名范围删除元素 </p>
<p><code>ZREMRANGEBYRANK key start stop</code></p>
<p> ZREMRANGEBYRANK 命令按照元素分数从小到大的顺序（即索引 0表示最小的值）删除处在指定排名范围内的所有元素，并返回删除的元素数量。如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD testRem 1 a 2 b 3 c 4 d 5 e 6 f</span> </span><br><span class="line">(integer) 6 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZREMRANGEBYRANK testRem 0 2</span> </span><br><span class="line">(integer) 3 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZRANGE testRem 0 -1</span> </span><br><span class="line">1) &quot;d&quot; </span><br><span class="line">2) &quot;e&quot; </span><br><span class="line">3) &quot;f&quot;</span><br></pre></td></tr></table></figure>

<p>5．按照分数范围删除元素 </p>
<p><code>ZREMRANGEBYSCORE key min max </code></p>
<p>ZREMRANGEBYSCORE命令会删除指定分数范围内的所有元素，参数min和max的特性和ZRANGEBYSCORE命令中的一样。返回值是删除的元素数量。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; ZREMRANGEBYSCORE testRem (4 5 </span><br><span class="line">(integer) 1 </span><br><span class="line">redis&gt; ZRANGE testRem 0 -1 </span><br><span class="line">1) &quot;d&quot; </span><br><span class="line">2) &quot;f&quot;</span><br></pre></td></tr></table></figure>

<p>6．获得元素的排名 </p>
<p><code>ZRANK key member</code></p>
<p><code> ZREVRANK key member</code></p>
<p>ZRANK命令会按照元素分数从小到大的顺序获得指定的元素的排名（从0开始，即分数最小的元素排名为0）。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; ZRANK scoreboard Peter </span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>ZREVRANK命令则相反（分数最大的元素排名为0）： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZREVRANK scoreboard Peter</span> </span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<p>7．计算有序集合的交集 </p>
<p><code>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE </code>SUM|MIN|MAX] ZINTERSTORE命令用来计算多个有序集合的交集并将结果存储在destination键中（同样以有序集合类型存储），返回值为destination键中的元素个数。 destination键中元素的分数是由AGGREGATE参数决定的。</p>
<h2 id="第二章-redis进阶与实战"><a href="#第二章-redis进阶与实战" class="headerlink" title="第二章 redis进阶与实战"></a>第二章 redis进阶与实战</h2><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>举个例子： 在微博中，用户之间是“关注”和“被关注”的关系。如果要使用Redis存储这样的关系可以使用集合类型。思路是对每个用户使用两个集合类型键，<strong>分别名为“user:用户ID:followers”和“user:用户ID:following”</strong>，用来存储关注该用户的用户集合和该用户关注的用户集合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> redis(&#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">follow</span>(<span class="params">currentUser, targetUser</span>) </span>&#123;</span><br><span class="line">    client.sadd(<span class="string">`post:<span class="subst">$&#123;currentUser&#125;</span>:following <span class="subst">$&#123;targetUser&#125;</span>`</span>);</span><br><span class="line">    client.sadd(<span class="string">`post:<span class="subst">$&#123;targetUser&#125;</span>:followers <span class="subst">$&#123;currentUser&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h5><p><code>MULTI</code></p>
<p>Redis中的事务（transaction）是一组命令的集合。事务同命令一样都是Redis中的事务（transaction）是一组命令的集合。事务同命令一样都是 Redis 的最小执行单位，<strong>一个事务中的命令要么都执行，要么都不执行。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; MULTI OK </span><br><span class="line">redis&gt; SADD &quot;user:1:following&quot; 2 </span><br><span class="line">QUEUED </span><br><span class="line">redis&gt; SADD &quot;user:2:followers&quot; 1 </span><br><span class="line">QUEUED redis&gt; EXEC </span><br><span class="line">1) (integer) 1 </span><br><span class="line">2) (integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><ul>
<li><p>语法错误： 可以发现并且中断后面的执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set shiwu hello</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; asdasdasd</span><br><span class="line">(error) ERR unknown command `asdasdasd`, with args beginning with:</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get shiwu</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li>
<li><p>运行错误： redis无法发现</p>
</li>
</ul>
<blockquote>
<p> Redis的事务没有关系数据库事务提供的回滚（rollback）[1] 功能。为此开发者必须在事务执行出错后自己收拾剩下的摊子（将数据库复原回事务执行前的状态等）。 不过由于 Redis 不支持回滚功能，也使得 Redis 在事务上可以保持简洁和快速。另外回顾刚才提到的会导致事务执行失败的两种错误，其中语法错误完全可以在开发时找出并解决，另外如果能够很好地规划数据库（保证键名规范等）的使用，是不会出现如命令与数据类型不匹配这样的运行错误的。</p>
</blockquote>
<h5 id="WATCH命令介绍"><a href="#WATCH命令介绍" class="headerlink" title="WATCH命令介绍"></a>WATCH命令介绍</h5><p>我们已经知道在一个事务中只有当所有命令都依次执行完后才能得到每个结果的返回值，可是有些情况下需要先获得一条命令的返回值，然后再根据这个值执行下一条命令。</p>
<p><code>WATCH</code>命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET key 1 OK</span> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> WATCH key OK</span> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET key 2 OK</span> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> MULTI OK</span> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET key 3 QUEUED</span> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EXEC (nil)</span> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GET key <span class="string">&quot;2&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>我们可以利用WATCH来重构之前实现的incr函数来避免竞态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> redis(&#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incr</span>(<span class="params">$key</span>) </span>&#123;</span><br><span class="line">    client.watch($key);</span><br><span class="line">    <span class="keyword">var</span> value = client.get($key);</span><br><span class="line">    <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">        value = value + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        client.multi();</span><br><span class="line">        client.set(<span class="string">`<span class="subst">$&#123;$key&#125;</span> value`</span>);</span><br><span class="line">        client.exit();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h4><p>在实际的开发中经常会遇到一些有时效的数据，比如限时优惠活动、缓存或验证码等，过了一定的时间就需要删除这些数据。在关系数据库中一般需要额外的一个字段记录到期时间，然后定期检测删除过期数据。而在Redis中可以使用 EXPIRE命令设置一个键的过期时间，到时间后Redis会自动删除它。</p>
<p>EXPIRE 命令的使用方法为 <code>EXPIRE key seconds</code>，其中 seconds 参数表示键的过期时间，单位是秒。如要想让session:29e3d键在15分钟后被删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET session:29e3d uid1314</span> </span><br><span class="line">OK </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EXPIRE session:29e3d 900</span> </span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p><strong>EXPIRE命令返回1表示设置成功，返回0则表示键不存在或设置失败。</strong>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; DEL session:29e3d </span><br><span class="line">(integer) 1 </span><br><span class="line">redis&gt; EXPIRE session:29e3d 900 </span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p><strong>如果想知道一个键还有多久的时间会被删除，可以使用TTL命令。</strong>返回值是键的剩余时间（单位是秒）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET foo bar</span> </span><br><span class="line">OK </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EXPIRE foo 20</span> </span><br><span class="line">(integer) 1 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TTL foo</span> </span><br><span class="line">(integer) 15 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TTL foo</span> </span><br><span class="line">(integer) 7 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TTL foo</span> </span><br><span class="line">(integer) –2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可见随着时间的不同，foo键的过期时间逐渐减少，20秒后foo键会被删除。<strong>当键不存在时TTL命令会返回−2。</strong> 那么没有为键设置过期时间（即永久存在，这是建立一个键后的默认情况）的情况下会返回什么呢？<strong>答案是返回−1：</strong></p>
<p><strong>如果想取消键的过期时间设置（即将键恢复成永久的）</strong>，则可以使用<code>PERSIST</code>命令。如果过期时间被成功清除则返回1；否则返回0（因为键不存在或键本来就是永久的）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET foo bar</span> </span><br><span class="line">OK </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EXPIRE foo 20</span> </span><br><span class="line">(integer) 1 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> PERSIST foo</span> </span><br><span class="line">(integer) 1 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TTL foo</span> </span><br><span class="line">(integer) –1</span><br></pre></td></tr></table></figure>

<p><strong>除了PERSIST命令之外</strong>，使用SET或GETSET命令为键赋值也会<strong>同时清除键的过期时间</strong>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; EXPIRE foo 20 </span><br><span class="line">(integer) 1 </span><br><span class="line">redis&gt; SET foo bar OK </span><br><span class="line">redis&gt; TTL foo </span><br><span class="line">(integer) –1</span><br></pre></td></tr></table></figure>

<p><strong>其他只对键值进行操作的命令（如INCR、LPUSH、HSET、ZREM）均不会影响键的过期时间。</strong></p>
<p>EXPIRE命令的seconds参数必须是整数，所以最小单位是1秒。<strong>如果想要更精确的控制键的过期时间应该使用 PEXPIRE命令，</strong>PEXPIRE命令与 EXPIRE的唯一区别是前者的时间单位是毫秒，即 PEXPIRE key 1000 与 EXPIRE key 1 等价。对应地可以用 PTTL命令以毫秒为单位返回键的剩余时间。</p>
<blockquote>
<p>提示 如果使用 WATCH命令监测了一个拥有过期时间的键，该键时间到期自动删除并不会被WATCH命令认为该键被改变。</p>
</blockquote>
<p><strong>另外还有两个相对不太常用的命令</strong>：<code>EXPIREAT</code> <code>和 PEXPIREAT</code>。</p>
<p>EXPIREAT命令与EXPIRE命令的差别在于前者使用Unix时间作为第二个参数表示键的过期时刻。PEXPIREAT命令与EXPIREAT命令的区别是前者的时间单位是毫秒。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; SET foo bar OK </span><br><span class="line">redis&gt; EXPIREAT foo 1351858600 </span><br><span class="line">(integer) 1 </span><br><span class="line">redis&gt; TTL foo </span><br><span class="line">(integer) 142 </span><br><span class="line">redis&gt; PEXPIREAT foo 1351858700000 </span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="ex-实现访问频率限制"><a href="#ex-实现访问频率限制" class="headerlink" title="ex: 实现访问频率限制"></a>ex: 实现访问频率限制</h5><p>需求：为了减轻服务器的压力，需要限制每个用户（以IP计）一段时间的最大访问量。</p>
<p>实现： 通过<code>EXPIRE</code>。</p>
<p>分析思路：</p>
<ol>
<li>根据用户ID新建一个字段 <code>rate.limite:$IP</code>, 存储的结果是访问量</li>
<li>用户每次访问的时候使用incr进行+1，并且EXPIRE设置一个过期时间</li>
<li>如果没过期则+1， 过期了则新建字段初始化访问次数0</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> redis(&#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isKeyExists = client.exists(<span class="string">`rate:limite:$ip`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isKeyExists) &#123;</span><br><span class="line">    <span class="keyword">var</span> time = client.incr(<span class="string">&#x27;rate:limite:$ip&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (time &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        client.exit(<span class="string">&#x27;你已经不能访问了，请休息下&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    client.incr(<span class="string">&#x27;rate:limite:$ip&#x27;</span>);</span><br><span class="line">    client.expire(<span class="string">&#x27;rate:limite:$ip 60&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段代码存在一个不太明显的问题：假如程序执行完倒数第二行后突然因为某种原因退出了，没能够为该键设置过期时间，那么该键会永久存在，导致使用对应的IP的用户在管理员手动删除该键前最多只能访问100次博客，这是一个很严重的问题。</p>
</blockquote>
<p>修改思路：使用事务包裹else</p>
<blockquote>
<p> 如果一个用户在一分钟的第一秒访问了一次博客，在同一分钟的最后一秒访问了9次，又在下一分钟的第一秒访问了10次，这样的访问是可以通过现在的访问频率限制的，但实际上该用户在2秒内访问了19次博客，这与每个用户每分钟只能访问10次的限制差距较大。尽管这种情况比较极端，但是在一些场合中还是需要粒度更小的控制方案。</p>
</blockquote>
<p>修改思路：将散列结构改造为列表</p>
<ol>
<li>新建一个 <code>rate:limit:$ip</code>的列表字段</li>
<li>每次访问向列表中存入当前时间戳</li>
<li>如果 列表长度小于10则存入</li>
<li>如果等于10，则讲列表的第一个时间戳和现在的时间对比。<ol>
<li>如果小于60秒则拒绝访问</li>
<li>反之存入，并删除第一条时间</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> redis(&#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listLength = client.llen(<span class="string">&#x27;rate:limit:$ip&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (listLength &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    client.lpush(<span class="string">`rate:limit:$ip <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()&#125;</span>`</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> time = client.lindex(<span class="string">&#x27;rate:limit:$ip -1&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().valueOf() - time &lt; <span class="number">60</span>) &#123;</span><br><span class="line">        client.exit(<span class="string">&#x27;访问超过限制&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        client.lpush(<span class="string">`rate:limit:$ip <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()&#125;</span>`</span>);</span><br><span class="line">        client.ltrim(<span class="string">`rate:limit:$ip 0 9`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ex：实现缓存"><a href="#ex：实现缓存" class="headerlink" title="ex：实现缓存"></a>ex：实现缓存</h5><p>假设学生成绩总在不断地变化，需要每隔两个小时就重新计算一次排名，这可以通过给键设置过期时间的方式实现。每次用户访问首页时程序先查询缓存键是否存在，如果存在则直接使用缓存的值；否则重新计算排名并将计算结果赋值给该键并同时设置该键的过期时间为两个小时。伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> redis(&#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rank = client.get(<span class="string">&#x27;cache:rank&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!rank) &#123;</span><br><span class="line">    <span class="keyword">var</span> $rank = jisuan();</span><br><span class="line">    client.multi();</span><br><span class="line">    client.set(<span class="string">`cache:rank <span class="subst">$&#123;$rank&#125;</span>`</span>);</span><br><span class="line">    client.expire(<span class="string">`cache:rank 7200`</span>);</span><br><span class="line">    client.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然而在一些场合中这种方法并不能满足需要。当服务器内存有限时，如果大量地使用缓存键且过期时间设置得过长就会导致 Redis 占满内存；另一方面如果为了防止 Redis 占用内存过大而将缓存键的过期时间设得太短，就可能导致缓存命中率过低并且大量内存白白地闲置。实际开发中会发现很难为缓存键设置合理的过期时间，为此可以限制 Redis 能够使用的最大内存，并让Redis按照一定的规则淘汰不需要的缓存键，这种方式在只将Redis用作缓存系统时非常实用。</p>
</blockquote>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>我们学过哪些可以排序的操作?</p>
<ul>
<li>有序集合:  根据存储的分数进行排序</li>
<li>列表： 根据插入的顺序排序</li>
</ul>
<p>介绍一种新的排序方法 <code>SORT</code></p>
<ol>
<li>sort可以对列表类型进行排序</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> LPUSH mylist 4 2 6 1 3 7</span> </span><br><span class="line">(integer) 6 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SORT mylist</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>sort可以对有序集合进行排序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; ZADD myzset 50 2 40 3 20 1 60 5 </span><br><span class="line">(integer) 4 </span><br><span class="line">redis&gt; SORT myzset </span><br><span class="line">1) &quot;1&quot; </span><br><span class="line">2) &quot;2&quot; </span><br><span class="line">3) &quot;3&quot; </span><br><span class="line">4) &quot;5&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在对有序集合类型排序时会忽略元素的分数，只针对元素自身的值进行排序。</p>
</blockquote>
<ol start="3">
<li>还可以对非数字类型进行排序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; LPUSH mylistalpha a c e d B C A </span><br><span class="line">(integer) 7 </span><br><span class="line">redis&gt; SORT mylistalpha </span><br><span class="line">(error) ERR One or more scores can&#x27;t be converted into double </span><br><span class="line">redis&gt; SORT mylistalpha ALPHA </span><br><span class="line">1) &quot;A&quot; </span><br><span class="line">2) &quot;B&quot; </span><br><span class="line">3) &quot;C&quot; </span><br><span class="line">4) &quot;a&quot; </span><br><span class="line">5) &quot;c&quot; </span><br><span class="line">6) &quot;d&quot; </span><br><span class="line">7) &quot;e&quot;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>DESC参数可以从大到小排序，还可以加入limit参数</li>
<li>通过<code>BY</code>来根据时间排序</li>
</ol>
<p>BY参数的语法为BY参考键。其中参考键可以是字符串类型键或者是散列类型键的某个字段（表示为键名-&gt;字段名）。如果提供了 BY 参数，SORT 命令将不再依据元素自身的值进行排序，而是对每个元素使用元素的值替换参考键中的第一个“*”并获取其值，然后依据该值对元素排序。就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; SORT tag:ruby:posts BY post:*-&gt;time DESC </span><br><span class="line">1) &quot;12&quot; </span><br><span class="line">2) &quot;26&quot; </span><br><span class="line">3) &quot;6&quot;</span><br><span class="line">4) &quot;2&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上例中SORT命令会读取post:2、post:6、post:12、post:26几个散列键中的time字段的值并以此决定tag:ruby:posts键中各个文章ID的顺序。</p>
</blockquote>
<p>还可以跟进GET参数获取你想要的字段的值，而不是排序的依据字段</p>
<p><code>SORT tag:ruby:posts BY post:*-&gt;time DESC GET post:*-&gt;title</code></p>
<p><code>SORT tag:ruby:posts BY post:*-&gt;time DESC GET post:*-&gt;title GET post:*-&gt;time</code></p>
<p>如果还想返回文章的ID怎么办</p>
<p><code>redis&gt; SORT tag:ruby:posts BY post:*-&gt;time DESC GET post:*-&gt;title GET post:*-&gt;time GET #</code></p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>比如<code>SORT</code>是redis最复杂的命令之一，如果使用的不好容易造成性能瓶颈。</p>
<p>SORT命令的复杂度为 0(n + mlog(m))， n代表要排序的列表长度，m代表需要返回的元素个数。</p>
<ol>
<li>尽可能减少待排序键中元素的属性(使n尽可能小)</li>
<li>利用LIMIT参数使m尽可能的小</li>
<li>如果要排序的数量比较大，尽量将结果缓存</li>
</ol>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>客户端和Redis使用TCP协议连接。不论是客户端向Redis发送命令还是Redis向客户端返回命令的执行结果，都需要经过网络传输，这两个部分的总耗时称为往返时延。</p>
<p>Redis 的底层通信协议对管道（pipelining）提供了支持。通过管道可以一次性发送多条命令并在执行完后一次性将结果返回，当一组命令中每条命令都不依赖于之前命令的执行结果时就可以将这组命令一起通过管道发出。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120140815.png" alt="image-20190616122914879"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120140806.png" alt="image-20190616122933539"></p>
<h4 id="节省空间"><a href="#节省空间" class="headerlink" title="节省空间"></a>节省空间</h4><h5 id="精简键值和键名"><a href="#精简键值和键名" class="headerlink" title="精简键值和键名"></a>精简键值和键名</h5><p>精简键名和键值是最直观的减少内存占用的方式，如将键名very.important.person:20改成VIP:20。当然精简键名一定要把握好尺度，不能单纯为了节约空间而使用不易理解的键名（比如将VIP:20修改为V:20，这样既不易维护，还容易造成命名冲突）。又比如一个存储用户性别的字符串类型键的取值是male和female，我们可以将其修改成m和f来为每条记录节约几个字节的空间，甚至通过二进制的0和1来表示。</p>
<h3 id="nodejs实战"><a href="#nodejs实战" class="headerlink" title="nodejs实战"></a>nodejs实战</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://andice-cream.github.io/post/f6aac0b2.html">https://andice-cream.github.io/post/f6aac0b2.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://andice-cream.github.io" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/Node-js%E8%BF%9B%E9%98%B6/">Node.js进阶</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212025.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/7dca11ad.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082231.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JDK8新特性-类型推断</div></div></a></div><div class="next-post pull-right"><a href="/post/489ef953.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082121.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring面试题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">NoSQL数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">课程介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">主要内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">学习目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.3.</span> <span class="toc-text">NoSQL主要应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-Redis"><span class="toc-number">1.2.</span> <span class="toc-text">第一章 Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%8F%91%E5%B1%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">历史与发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ex%EF%BC%9A"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">ex：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">内存存储与持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E4%B8%B0%E5%AF%8C"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">功能丰富</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">简单稳定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ex"><span class="toc-number">1.2.2.4.1.</span> <span class="toc-text">ex:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.3.</span> <span class="toc-text">Redis安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">初始化配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-cli%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">redis-cli简易使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.2.4.</span> <span class="toc-text">redis命令行客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ex-1"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">ex:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">命令返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%9B%9E%E5%A4%8D"><span class="toc-number">1.2.4.2.1.</span> <span class="toc-text">状态回复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%9B%9E%E5%A4%8D"><span class="toc-number">1.2.4.2.2.</span> <span class="toc-text">错误回复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%9B%9E%E5%A4%8D"><span class="toc-number">1.2.4.2.3.</span> <span class="toc-text">整数回复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9B%9E%E5%A4%8D"><span class="toc-number">1.2.4.2.4.</span> <span class="toc-text">字符串回复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9B%9E%E5%A4%8D"><span class="toc-number">1.2.4.2.5.</span> <span class="toc-text">多行字符串回复</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">多数据库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.5.</span> <span class="toc-text">Redis数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">字符串类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.5.1.2.</span> <span class="toc-text">命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ex-%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1-%E6%A0%87%E9%A2%98%EF%BC%8C-%E6%AD%A3%E6%96%87%EF%BC%8C%E8%AE%BF%E9%97%AE%E9%87%8F"><span class="toc-number">1.2.5.1.3.</span> <span class="toc-text">ex: 文章访问量统计(标题， 正文，访问量)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A9%E5%B1%95"><span class="toc-number">1.2.5.1.4.</span> <span class="toc-text">命令扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.6.</span> <span class="toc-text">散列类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ex-%E6%B1%BD%E8%BD%A6%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.6.1.1.</span> <span class="toc-text">ex: 汽车数据模型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-1"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">实践</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%A3%E5%88%97%E6%94%B9%E9%80%A0"><span class="toc-number">1.2.6.3.1.</span> <span class="toc-text">使用散列改造</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">命令补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text">列表类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-2"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ex%EF%BC%9A%E5%82%A8%E5%AD%98%E6%96%87%E7%AB%A0id%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">ex：储存文章id列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ex-%E5%AD%98%E5%82%A8%E8%AF%84%E8%AE%BA%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">ex: 存储评论列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85-1"><span class="toc-number">1.2.7.5.</span> <span class="toc-text">命令补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.8.</span> <span class="toc-text">集合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-3"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ex-%E5%AD%98%E5%82%A8%E6%96%87%E7%AB%A0%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">ex: 存储文章标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ex-%E9%80%9A%E8%BF%87%E6%A0%87%E7%AD%BE%E6%90%9C%E7%B4%A2%E6%96%87%E7%AB%A0"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">ex: 通过标签搜索文章</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85-2"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">命令补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.9.</span> <span class="toc-text">有序集合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-4"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ex-%E5%AE%9E%E7%8E%B0%E6%8C%89%E7%82%B9%E5%87%BB%E9%87%8F%E6%8E%92%E5%90%8D"><span class="toc-number">1.2.9.3.</span> <span class="toc-text">ex: 实现按点击量排名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85-3"><span class="toc-number">1.2.9.4.</span> <span class="toc-text">命令补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-redis%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="toc-number">1.3.</span> <span class="toc-text">第二章 redis进阶与实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-5"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.3.1.1.2.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WATCH%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.1.3.</span> <span class="toc-text">WATCH命令介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">过期时间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ex-%E5%AE%9E%E7%8E%B0%E8%AE%BF%E9%97%AE%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">ex: 实现访问频率限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ex%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98"><span class="toc-number">1.3.1.2.2.</span> <span class="toc-text">ex：实现缓存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%9C%81%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">节省空间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B2%BE%E7%AE%80%E9%94%AE%E5%80%BC%E5%92%8C%E9%94%AE%E5%90%8D"><span class="toc-number">1.3.1.6.1.</span> <span class="toc-text">精简键值和键名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nodejs%E5%AE%9E%E6%88%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">nodejs实战</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>