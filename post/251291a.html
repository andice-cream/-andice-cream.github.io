<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaSE基础-2 | 小肥龙吃大冰淇淋</title><meta name="keywords" content="javase基础"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="异常异常概述引入异常生活中的异常： 正常情况下，小王每日开车去上班，耗时大约30分钟 但是，异常情况迟早要发生！ 面对异常该怎么办呢？生活中，我们会根据不同的异常进行相应的处理，而不会就此中断我们的生活 在使用计算机语言进行项目开发的过程中，即使程序员把代码写得 尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE基础-2">
<meta property="og:url" content="https://andice-cream.github.io/post/251291a.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="异常异常概述引入异常生活中的异常： 正常情况下，小王每日开车去上班，耗时大约30分钟 但是，异常情况迟早要发生！ 面对异常该怎么办呢？生活中，我们会根据不同的异常进行相应的处理，而不会就此中断我们的生活 在使用计算机语言进行项目开发的过程中，即使程序员把代码写得 尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212025.jpg">
<meta property="article:published_time" content="2021-12-08T07:27:00.000Z">
<meta property="article:modified_time" content="2024-05-27T13:19:30.425Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="javase基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212025.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://andice-cream.github.io/post/251291a"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaSE基础-2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-27 21:19:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">178</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212025.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaSE基础-2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-08T07:27:00.000Z" title="发表于 2021-12-08 15:27:00">2021-12-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-27T13:19:30.425Z" title="更新于 2024-05-27 21:19:30">2024-05-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%AD%A6%E4%B9%A0/">java学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%AD%A6%E4%B9%A0/javase/">javase</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">91.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>370分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaSE基础-2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h2><h3 id="引入异常"><a href="#引入异常" class="headerlink" title="引入异常"></a><em><strong>引入异常</strong></em></h3><p><em><strong>生活中的异常：</strong></em></p>
<p>正常情况下，小王每日开车去上班，耗时大约30分钟</p>
<p>但是，异常情况迟早要发生！</p>
<p>面对异常该怎么办呢？生活中，我们会根据不同的异常进行相应的处理，而不会就此中断我们的生活</p>
<p>在使用计算机语言进行项目开发的过程中，即使程序员把代码写得 尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始终保持通畅等等。</p>
<ul>
<li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，如果不处理最终会导致JVM的非正常停止。</li>
</ul>
<blockquote>
<p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p>
<p>异常也不是指逻辑代码错误而没有得到想要的结果，例如：求a与b的和，你写成了a-b 除数为0的情况</p>
</blockquote>
<p>对于异常，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。</p>
<p>Java中是如何表示不同的异常情况，又是如何让程序员得知，并处理异常的呢？</p>
<p>Java中把不同的异常用不同的类表示，一旦发生某种异常，就通过创建该异常类型的对象，并且抛出，然后程序员可以catch到这个异常对象，并处理，如果无法catch到这个异常对象，那么这个异常对象将会导致程序终止。</p>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p>异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826170700.png"></p>
<p><strong>Throwable体系：</strong></p>
<ul>
<li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。<ul>
<li>例如：StackOverflowError，OOM（OutOfMemoryError）  内存泄漏（Memory Leak）  。</li>
<li> 内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614">内存</a>或使用的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614">内存</a>过多，最终使得程序运行要用到的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614">内存</a>大于能提供的最大内存。 </li>
<li> 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果 。</li>
</ul>
</li>
<li><strong>Exception</strong>:表示异常，其它因编程错误或偶然的外在因素导致的一般性问题，程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。<ul>
<li>例如：空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界</li>
</ul>
</li>
</ul>
<p><strong>Throwable中的常用方法：</strong></p>
<ul>
<li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><code>public String getMessage()</code>:获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
</ul>
<p><em><strong>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</strong></em></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826170704.bmp"></p>
<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p>
<p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p>
<ul>
<li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如文件找不到异常)</li>
<li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会被编译器检测到(不报错)。(如数组索引越界异常，类型转换异常)。程序员应该积极避免其出现的异常，而不是使用try..catch处理，因为这类异常很普遍，若都使用try..catch或throws处理可能会对程序的可读性和运行效率产生影响。</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826170718.png" alt="1562771528807"></p>
<h3 id="演示常见的错误和异常"><a href="#演示常见的错误和异常" class="headerlink" title="演示常见的错误和异常"></a>演示常见的错误和异常</h3><h4 id="VirtualMachineError"><a href="#VirtualMachineError" class="headerlink" title="VirtualMachineError"></a>VirtualMachineError</h4><p>最常见的就是：StackOverflowError、OutOfMemoryError</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//StackOverflowError</span></span><br><span class="line">	digui();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">digui</span><span class="params">()</span></span>&#123;</span><br><span class="line">	digui();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//OutOfMemoryError</span></span><br><span class="line">	<span class="comment">//方式一：</span></span><br><span class="line">	<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[Integer.MAX_VALUE];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//OutOfMemoryError</span></span><br><span class="line">	<span class="comment">//方式二：</span></span><br><span class="line">	StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">		s.append(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//NullPointerException</span></span><br><span class="line">	<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">	System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//ClassCastException</span></span><br><span class="line">	Person p = <span class="keyword">new</span> Man();</span><br><span class="line">	Woman w = (Woman) p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line">	<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">		System.out.println(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//InputMismatchException</span></span><br><span class="line">	Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	System.out.print(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> num = input.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//ArithmeticException</span></span><br><span class="line">	System.out.println(a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">	Thread.sleep(<span class="number">1000</span>);<span class="comment">//休眠1秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;Java学习秘籍.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">	Connection conn = DriverManager.getConnection(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常的抛出机制"><a href="#异常的抛出机制" class="headerlink" title="异常的抛出机制"></a>异常的抛出机制</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p>
<p> 工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对给定的数组通过给定的角标获取元素。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">34</span>, <span class="number">12</span>, <span class="number">67</span> &#125;;</span><br><span class="line">        intnum = ArrayTools.getElement(arr, <span class="number">4</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;num=&quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序执行过程图解：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826170738.png"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826170741.png" alt="1562772282750"></p>
<h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<h3 id="异常throw"><a href="#异常throw" class="headerlink" title="异常throw"></a>异常throw</h3><p>Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。异常对象的生成有两种方式：</p>
<ul>
<li>由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出</li>
<li>由开发人员手动创建：Exception exception = new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样，但是一旦throw抛出，就会对程序运行产生影响了。</li>
</ul>
<p>下面我们说明手动抛出异常：</p>
<p>比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，这时可以使用抛出异常的方式来告诉调用者。</p>
<p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p>
<ol>
<li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p>
</li>
<li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p>
<p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并<strong>结束</strong>当前方法的执行。</p>
</li>
</ol>
<p><strong>使用格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">throw new 异常类名(参数);</span><br></pre></td></tr></table></figure>

<p> 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;要访问的arr数组不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个数组 </span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//根据索引找对应的元素 </span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> element = getElement(arr, index);</span><br><span class="line"></span><br><span class="line">        System.out.println(element);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据 索引找到数组中对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;要访问的arr数组不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       	<span class="comment">//判断  索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;哥们，角标越界了~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p>
<p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p>
</blockquote>
<h4 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h4><p>1、声明Husband类，包含姓名和妻子属性，属性私有化，提供一个Husband(String name)的构造器，重写toString方法，返回丈夫姓名和妻子的姓名</p>
<p>2、声明Wife类，包含姓名和丈夫属性，属性私有化，提供一个Wife(String name)的构造器，重写toString方法，返回妻子的姓名和丈夫的姓名</p>
<p>3、声明TestMarry类，在main中，创建Husband和Wife对象后直接打印妻子和丈夫对象，查看异常情况，看如何解决</p>
<h4 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h4><p>1、声明银行账户类Account</p>
<p>（1）包含账号、余额属性，要求属性私有化，提供无参和有参构造，</p>
<p>（2）包含取款方法，当取款金额为负数时，抛出IllegalArgumentException，异常信息为“取款金额有误，不能为负数”，当取款金额超过余额时，抛出UnsupportedOperationException，异常信息为“取款金额不足，不支持当前取款操作”</p>
<p>（3）包含存款方法，当取款金额为负数时，抛出IllegalArgumentException，异常信息为“存款金额有误，不能为负数”</p>
<p>2、编写测试类，创建账号对象，并调用取款和存款方法，并传入非法参数，测试发生对应的异常。</p>
<h3 id="声明异常throws"><a href="#声明异常throws" class="headerlink" title="声明异常throws"></a>声明异常throws</h3><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了<strong>编译时异常</strong>，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>
<p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<p><strong>声明异常格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;	</span><br></pre></td></tr></table></figure>

<p>声明异常的代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">		readFile(<span class="string">&quot;不敲代码学会Java秘籍.txt&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">		<span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(filePath+<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException,IllegalAccessException </span>&#123;</span><br><span class="line">		readFile(<span class="string">&quot;不敲代码学会Java秘籍.txt&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> FileNotFoundException,IllegalAccessException</span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">		<span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(filePath+<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!file.isFile())&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(filePath + <span class="string">&quot;不是文件，无法直接读取&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>1、声明银行账户类Account</p>
<p>（1）包含账号、余额属性，要求属性私有化，提供无参和有参构造，</p>
<p>（2）包含取款方法，当取款金额为负数时，抛出Exception，异常信息为“越取你余额越多，想得美”，当取款金额超过余额时，抛出Exception，异常信息为“取款金额不足，不支持当前取款操作”</p>
<p>（3）包含存款方法，当取款金额为负数时，抛出Exception，异常信息为“越存余额越少，你愿意吗？”</p>
<p>2、编写测试类，创建账号对象，并调用取款和存款方法，并传入非法参数，测试发生对应的异常。</p>
<h3 id="捕获异常try…catch"><a href="#捕获异常try…catch" class="headerlink" title="捕获异常try…catch"></a>捕获异常try…catch</h3><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ol>
<li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>在方法中使用try-catch的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常。</p>
<p>*<strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</p>
<p>捕获异常语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span>  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span>  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p>
<p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>
<ul>
<li>可以有多个catch块，按顺序匹配。</li>
<li>如果多个异常类型有包含关系，那么小上大下</li>
</ul>
<p>演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			readFile(<span class="string">&quot;不敲代码学会Java秘籍.txt&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">//			e.printStackTrace();</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;好好敲代码，不要老是想获得什么秘籍&quot;);</span></span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;继续学习吧...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> FileNotFoundException, IllegalAccessException</span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">		<span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(filePath+<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!file.isFile())&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(filePath + <span class="string">&quot;不是文件，无法直接读取&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何获取异常信息：</p>
<p>Throwable类中定义了一些查看方法:</p>
<ul>
<li><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</li>
</ul>
<ul>
<li><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</li>
</ul>
<p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
<h3 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h3><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<p>什么时候的代码必须最终执行？</p>
<p>当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p>
<p>finally的语法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否发生异常，也无论<span class="keyword">catch</span>是否捕获异常，也不管<span class="keyword">try</span>和<span class="keyword">catch</span>中是否有<span class="keyword">return</span>语句，都一定会执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否发生异常，也不管<span class="keyword">try</span>中是否有<span class="keyword">return</span>语句，都一定会执行</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:finally不能单独使用。</p>
</blockquote>
<p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p>
<p>finally代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">		readFile(<span class="string">&quot;不敲代码学会Java秘籍.txt&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;继续学习吧...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">		FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(filePath+<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!file.isFile())&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(filePath + <span class="string">&quot;不是文件，无法直接读取&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">//抓取到的是编译期异常  抛出去的是运行期 </span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;无论如何，这里的代码一定会被执行&quot;</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">					fis.close();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">//抓取到的是编译期异常  抛出去的是运行期 </span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当只有在try或者catch中调用退出JVM的相关方法，例如System.exit(0),此时finally才不会执行,否则finally永远会执行。</p>
</blockquote>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826170815.bmp"></p>
<h3 id="finally与return"><a href="#finally与return" class="headerlink" title="finally与return"></a>finally与return</h3><h4 id="形式一：从try回来"><a href="#形式一：从try回来" class="headerlink" title="形式一：从try回来"></a>形式一：从try回来</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReturn</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = test(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Integer.parseInt(str);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;test结束&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="形式二：从catch回来"><a href="#形式二：从catch回来" class="headerlink" title="形式二：从catch回来"></a>形式二：从catch回来</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReturn</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = test(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Integer.parseInt(str);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;test结束&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="形式三：从finally回来"><a href="#形式三：从finally回来" class="headerlink" title="形式三：从finally回来"></a>形式三：从finally回来</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReturn</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = test(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Integer.parseInt(str);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test结束&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h2><ul>
<li><p>多个异常使用捕获又该如何处理呢？</p>
<ol>
<li>多个异常分别处理。</li>
<li>多个异常一次捕获，多次处理。(推荐)</li>
<li>多个异常一次捕获一次处理。</li>
</ol>
<p>一般我们是使用一次捕获多次处理方式，格式如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A  e)&#123;  当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B  e)&#123;  当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p>
</blockquote>
<ul>
<li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p>
</li>
<li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p>
</li>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类方法中产生了编译时异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p><strong>为什么需要自定义异常类:</strong></p>
<p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是Java开发人员没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题，考试成绩负数问题等等。那么能不能自己定义异常呢？可以</p>
<p><strong>异常类如何定义:</strong></p>
<ol>
<li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li>
<li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li>
</ol>
<p><strong>演示自定义异常：</strong></p>
<p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p>
<p>首先定义一个登陆异常类RegisterException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 表示异常提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟数据库中已存在账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] names = &#123;<span class="string">&quot;bill&quot;</span>,<span class="string">&quot;hill&quot;</span>,<span class="string">&quot;jill&quot;</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">              <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">            checkUsername(<span class="string">&quot;nill&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;注册成功&quot;</span>);<span class="comment">//如果没有异常就是注册成功</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(RegisterException e)&#123;</span><br><span class="line">            <span class="comment">//处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前注册账号是否存在</span></span><br><span class="line">    <span class="comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(String uname)</span> <span class="keyword">throws</span> LoginException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;names.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(names[i].equals(uname))&#123;<span class="comment">//如果名字在这里面 就抛出登陆异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">&quot;亲&quot;</span>+name+<span class="string">&quot;已经被注册了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>从Exception类或者它的子类派生一个子类即可</li>
<li>习惯上，自定义异常类应该包含2个构造器：一个是无参构造，另一个是带有详细信息的构造器</li>
<li>自定义的异常只能通过throw抛出。</li>
<li>自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p>
<p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="并发与并行（了解）"><a href="#并发与并行（了解）" class="headerlink" title="并发与并行（了解）"></a>并发与并行（了解）</h3><ul>
<li><strong>并行</strong>（parallel）：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。指在同一时刻，有多条指令在多个处理器上同时执行。</li>
<li><strong>并发</strong>（concurrency）：指两个或多个事件在<strong>同一个时间段内</strong>发生。指在同一个时刻只能有一条指令执行，但多个进程的指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826170940.bmp"></p>
<p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一个程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p>
<p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，<strong>并行</strong>处理的程序越多，能大大的提高电脑运行的效率。</p>
<blockquote>
<p>注意：<strong>单核</strong>处理器的计算机肯定是<strong>不能并行</strong>的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理，线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p>
</blockquote>
<p>单核CPU：只能并发</p>
<p>多核CPU：并行+并发</p>
<p>例子：</p>
<ul>
<li><p>并行：多项工作一起执行，之后再汇总，例如：泡方便面，电水壶烧水，一边撕调料倒入桶中</p>
</li>
<li><p>并发：同一时刻多个线程在访问同一个资源，多个线程对一个点，例如：春运抢票、电商秒杀…</p>
</li>
</ul>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><ul>
<li><p><strong>程序</strong>：为了完成某个任务和功能，选择一种编程语言编写的一组指令的集合。</p>
</li>
<li><p><strong>软件</strong>：<strong>1个或多个</strong>应用程序+相关的素材和资源文件等构成一个软件系统。</p>
</li>
<li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
</li>
<li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p>
<p>  简而言之：一个软件中至少有一个应用程序，应用程序的一次运行就是一个进程，一个进程中至少有一个线程。</p>
</li>
<li><p>面试题：进程是操作系统调度和分配资源的最小单位，线程是CPU调度的最小单位。不同的进程之间是不共享内存的。进程之间的数据交换和通信的成本是很高。不同的线程是共享同一个进程的内存的。当然不同的线程也有自己独立的内存空间。对于方法区，堆中中的同一个对象的内存，线程之间是可以共享的，但是栈的局部变量永远是独立的。</p>
</li>
</ul>
<p>例如：</p>
<h4 id="每个应用程序的运行都是一个进程"><a href="#每个应用程序的运行都是一个进程" class="headerlink" title="每个应用程序的运行都是一个进程"></a>每个应用程序的运行都是一个进程</h4><p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826170947.png"></p>
<h4 id="一个应用程序的多次运行，就是多个进程"><a href="#一个应用程序的多次运行，就是多个进程" class="headerlink" title="一个应用程序的多次运行，就是多个进程"></a>一个应用程序的多次运行，就是多个进程</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826170950.png" alt="1563267431480"></p>
<h4 id="一个进程中包含多个线程"><a href="#一个进程中包含多个线程" class="headerlink" title="一个进程中包含多个线程"></a>一个进程中包含多个线程</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171037.png" alt="1563270525077"></p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ul>
<li><p>分时调度</p>
<p>  所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</li>
<li><p>抢占式调度</p>
<p>  优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
<ul>
<li><p>抢占式调度详解</p>
<p>  大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p>
<p>  实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>  其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p>
<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171057.bmp" alt="抢占式调度"></p>
</li>
</ul>
</li>
</ul>
<h2 id="另行创建和启动线程"><a href="#另行创建和启动线程" class="headerlink" title="另行创建和启动线程"></a>另行创建和启动线程</h2><p>当运行Java程序时，其实已经有一个线程了，那就是main线程。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171054.png" alt="1563281796505"></p>
<p>那么如何创建和启动main线程以外的线程呢？</p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p>代码如下：</p>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建自定义线程对象</span></span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">&quot;新的线程！&quot;</span>);</span><br><span class="line">		<span class="comment">//开启新线程</span></span><br><span class="line">		mt.start();</span><br><span class="line">		<span class="comment">//在主方法中执行for循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;main线程！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>Java有单继承的限制，当我们无法继承Thread类时，那么该如何做呢？在核心类库中提供了Runnable接口，我们可以实现Runnable接口，重写run()方法，然后再通过Thread类的对象代理启动和执行我们的线程体run()方法</p>
<p>步骤如下：</p>
<ol>
<li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br> 的线程对象。</li>
<li>调用线程对象的start()方法来启动线程。<br> 代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        	System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);         </span><br><span class="line">		&#125;       </span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建自定义类对象  线程任务对象</span></span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mr, <span class="string">&quot;小强&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;旺财 &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程<br>代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p>
<p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p>
<p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现<br>Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p>
<p>tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。<br>而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p>
<h3 id="使用匿名内部类对象来实现线程的创建和启动"><a href="#使用匿名内部类对象来实现线程的创建和启动" class="headerlink" title="使用匿名内部类对象来实现线程的创建和启动"></a>使用匿名内部类对象来实现线程的创建和启动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="string">&quot;新的线程！&quot;</span>)&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>


<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>public Thread() :分配一个新的线程对象。<br>public Thread(String name) :分配一个指定名字的新的线程对象。<br>public Thread(Runnable target) :分配一个带有指定目标新的线程对象。<br>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</p>
<h3 id="常用方法系列1"><a href="#常用方法系列1" class="headerlink" title="常用方法系列1"></a>常用方法系列1</h3><ul>
<li><p>public void run() :此线程要执行的任务在此处定义代码。</p>
</li>
<li><p>public String getName() :获取当前线程名称。</p>
</li>
<li><p>public static Thread currentThread() :返回对当前正在执行的线程对象的引用。</p>
</li>
<li><p>public final boolean isAlive()：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。 </p>
</li>
<li><p>public final int getPriority() ：返回线程优先级 </p>
</li>
<li><p>public final void setPriority(int newPriority) ：改变线程的优先级</p>
<ul>
<li>每个线程都有一定的优先级，优先级高的线程将获得较多的执行机会。每个线程默认的优先级都与创建它的父线程具有相同的优先级。Thread类提供了setPriority(int newPriority)和getPriority()方法类设置和获取线程的优先级，其中setPriority方法需要一个整数，并且范围在[1,10]之间，通常推荐设置Thread类的三个优先级常量：</li>
<li>MAX_PRIORITY（10）：最高优先级 </li>
<li>MIN _PRIORITY （1）：最低优先级</li>
<li>NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(getName() + <span class="string">&quot;的优先级：&quot;</span> + getPriority());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	t.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">	t.start();</span><br><span class="line">	</span><br><span class="line">	System.out.println(Thread.currentThread().getName() +<span class="string">&quot;的优先级：&quot;</span> + Thread.currentThread().getPriority());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-3-常用方法系列2"><a href="#9-3-3-常用方法系列2" class="headerlink" title="9.3.3 常用方法系列2"></a>9.3.3 常用方法系列2</h3><ul>
<li><p>public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</p>
</li>
<li><p>public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</p>
</li>
<li><p>public static void yield()：yield只是让当前线程暂停一下，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会，但是这个不能保证，完全有可能的情况是，当某个线程调用了yield方法暂停之后，线程调度器又将其调度出来重新执行。</p>
</li>
<li><p>void join() ：等待该线程终止。 </p>
<p>  void join(long millis) ：等待该线程终止的时间最长为 millis 毫秒。如果millis时间到，将不再等待。 </p>
<p>  void join(long millis, int nanos) ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。 </p>
</li>
<li><p>public final void stop()：强迫线程停止执行。 该方法具有固有的不安全性，已经标记为@Deprecated不建议再使用，那么我们就需要通过其他方式来停止线程了，其中一种方式是使用变量的值的变化来控制线程是否结束。</p>
</li>
</ul>
<h4 id="示例代码：倒计时"><a href="#示例代码：倒计时" class="headerlink" title="示例代码：倒计时"></a>示例代码：倒计时</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;新年快乐！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例代码：强行加塞"><a href="#示例代码：强行加塞" class="headerlink" title="示例代码：强行加塞"></a>示例代码：强行加塞</h4><p>主线程：打印[1,10]，每隔10毫秒打印一个数字，</p>
<p>自定义线程类：不停的问是否结束，输入Y或N，</p>
<p>现在当主线程打印完5之后，就让自定义线程类加塞，直到自定义线程类结束，主线程再继续。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ChatThread t = <span class="keyword">new</span> ChatThread();</span><br><span class="line">		t.start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;main:&quot;</span> + i);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">10</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">         <span class="comment">//当main打印到5之后，需要等join进来的线程停止后才会继续了。</span></span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					t.join();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;是否结束？（Y、N）&quot;</span>);</span><br><span class="line">			<span class="keyword">char</span> confirm = input.next().charAt(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(confirm == <span class="string">&#x27;Y&#x27;</span> || confirm == <span class="string">&#x27;y&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		input.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-4-volatile保证线程间的数据的可见性"><a href="#9-3-4-volatile保证线程间的数据的可见性" class="headerlink" title="9.3.4 volatile保证线程间的数据的可见性"></a>9.3.4 volatile保证线程间的数据的可见性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//保证</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程并启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;=============&quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:/%E5%B0%9A%E7%A1%85%E8%B0%B7_XX%E7%8F%AD%E7%BA%A7_JavaSE%E4%B8%8A%E8%AF%BE%E7%89%A9%E6%96%99%E5%8C%85/01-%E8%AF%BE%E4%BB%B6/01-%E8%AF%BE%E4%BB%B6/%E8%AF%BE%E4%BB%B6%E3%80%90md%E7%89%88%E3%80%91/%E7%AC%AC9%E7%AB%A0%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/imgs/1597137316744.png" alt="1597137316744"></p>
<blockquote>
<p>volatile的作用是确保不会因编译器的优化而省略某些指令，volatile的变量是说这变量可能会被意想不到地改变，每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份，这样，编译器就不会去假设这个变量的值了。</p>
</blockquote>
<h3 id="9-3-5守护线程（了解）"><a href="#9-3-5守护线程（了解）" class="headerlink" title="9.3.5守护线程（了解）"></a>9.3.5守护线程（了解）</h3><p>有一种线程，它是在后台运行的，它的任务是为其他线程提供服务的，这种线程被称为“守护线程”。JVM的垃圾回收线程就是典型的守护线程。</p>
<p>守护线程有个特点，就是如果所有非守护线程都死亡，那么守护线程自动死亡。</p>
<p>调用setDaemon(true)方法可将指定线程设置为守护线程。必须在线程启动之前设置，否则会报IllegalThreadStateException异常。</p>
<p>调用isDaemon()可以判断线程是否是守护线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyDaemon m = <span class="keyword">new</span> MyDaemon();</span><br><span class="line">		m.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		m.start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;main:&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDaemon</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;我一直守护者你...&quot;</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>当我们使用多个线程访问<strong>同一资源</strong>（可以是同一个变量、同一个文件、同一条记录等）的时候，若多个线程只有读操作，那么不会发生线程安全问题，但是如果多个线程中对资源有读和写的操作，就容易出现线程安全问题。</p>
<p>我们通过一个案例，演示线程的安全问题：<br>电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个<br>(本场电影只能卖100张票)。<br>我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票)</p>
<h3 id="同一个资源问题"><a href="#同一个资源问题" class="headerlink" title="同一个资源问题"></a>同一个资源问题</h3><h4 id="局部变量不能共享"><a href="#局部变量不能共享" class="headerlink" title="局部变量不能共享"></a>局部变量不能共享</h4><p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package com.atguigu.safe;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo1</span> </span>&#123;</span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">		Window w1 = <span class="keyword">new</span> Window();</span><br><span class="line">		Window w2 = <span class="keyword">new</span> Window();</span><br><span class="line">		Window w3 = <span class="keyword">new</span> Window();</span><br><span class="line">		</span><br><span class="line">		w1.start();</span><br><span class="line">		w2.start();</span><br><span class="line">		w3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	public <span class="keyword">void</span> <span class="function"><span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		int total = <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">while</span>(total&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(getName() + <span class="string">&quot;卖出一张票，剩余:&quot;</span> + --total);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：发现卖出300张票。</p>
<p>问题：局部变量是每次调用方法都是独立的，那么每个线程的run()的total是独立的，不是共享数据。</p>
<h4 id="不同对象的实例变量不共享"><a href="#不同对象的实例变量不共享" class="headerlink" title="不同对象的实例变量不共享"></a>不同对象的实例变量不共享</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.safe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TicketSaleThread t1 = <span class="keyword">new</span> TicketSaleThread();</span><br><span class="line">		TicketSaleThread t2 = <span class="keyword">new</span> TicketSaleThread();</span><br><span class="line">		TicketSaleThread t3 = <span class="keyword">new</span> TicketSaleThread();</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketSaleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(total&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(getName() + <span class="string">&quot;卖出一张票，剩余:&quot;</span> + --total);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：发现卖出300张票。</p>
<p>问题：不同的实例对象的实例变量是独立的。</p>
<h4 id="静态变量是共享的"><a href="#静态变量是共享的" class="headerlink" title="静态变量是共享的"></a>静态变量是共享的</h4><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.safe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TicketThread t1 = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		TicketThread t2 = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		TicketThread t3 = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(total&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(getName() + <span class="string">&quot;卖出一张票，剩余:&quot;</span> + --total);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：发现卖出近100张票。</p>
<p>问题（1）：但是有重复票或负数票问题。</p>
<p>原因：线程安全问题</p>
<p>问题（2）：如果要考虑有两场电影，各卖100张票等</p>
<p>原因：TicketThread类的静态变量，是所有TicketThread类的对象共享</p>
<h4 id="同一个对象的实例变量共享"><a href="#同一个对象的实例变量共享" class="headerlink" title="同一个对象的实例变量共享"></a>同一个对象的实例变量共享</h4><p>示例代码：多个Thread线程使用同一个Runnable对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.safe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TicketSaleRunnable tr = <span class="keyword">new</span> TicketSaleRunnable();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketSaleRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(total&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出一张票，剩余:&quot;</span> + --total);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：发现卖出近100张票。</p>
<p>问题：但是有重复票或负数票问题。</p>
<p>原因：线程安全问题</p>
<h4 id="抽取资源类，共享同一个资源对象"><a href="#抽取资源类，共享同一个资源对象" class="headerlink" title="抽取资源类，共享同一个资源对象"></a>抽取资源类，共享同一个资源对象</h4><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread.resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo5</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//2、创建资源对象</span></span><br><span class="line">		Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、启动多个线程操作资源类的对象</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;窗口一&quot;</span>)&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="string">&quot;窗口二&quot;</span>)&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1、编写资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(total&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出一张票，剩余:&quot;</span> + --total);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有票了&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现程序出现了两个问题：</p>
<ol>
<li>相同的票数,比如某张票被卖了两回。</li>
<li>不存在的票，比如0票与-1票，是不存在的。</li>
</ol>
<p>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</p>
<h3 id="尝试解决线程安全问题"><a href="#尝试解决线程安全问题" class="headerlink" title="尝试解决线程安全问题"></a>尝试解决线程安全问题</h3><p>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制<br>(synchronized)来解决。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171332.png" alt="1563372934332"></p>
<p>根据案例简述：</p>
<p>窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</p>
<p>为了保证每个线程都能正常执行原子操作，Java引入了线程同步机制。注意:在任何时候,最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着(BLOCKED)。</p>
<p>同步方法：synchronized 关键字直接修饰方法，表示同一时刻只有一个线程能进入这个方法，其他线程在外面等着。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块：synchronized 关键字可以用于某个区块前面，表示只对这个区块的资源实行互斥访问。<br>格式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">     需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁对象选择"><a href="#锁对象选择" class="headerlink" title="锁对象选择"></a>锁对象选择</h3><p>同步锁对象：</p>
<ul>
<li>锁对象可以是任意类型。</li>
<li>多个线程对象  要使用同一把锁。</li>
</ul>
<h4 id="1、同步方法的锁对象问题"><a href="#1、同步方法的锁对象问题" class="headerlink" title="1、同步方法的锁对象问题"></a>1、同步方法的锁对象问题</h4><p>（1）静态方法：当前类的Class对象</p>
<p>（2）非静态方法：this</p>
<h5 id="示例代码一："><a href="#示例代码一：" class="headerlink" title="示例代码一："></a>示例代码一：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread2.safemethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketSafeDemo1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 2、创建资源对象</span></span><br><span class="line">		Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3、启动多个线程操作资源类的对象</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;窗口一&quot;</span>) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">// 加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="string">&quot;窗口二&quot;</span>) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">// 加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">// 加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、编写资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//非静态方法隐含的锁对象就是this</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出一张票，剩余:&quot;</span> + --total);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(Thread.currentThread().getName() + <span class="string">&quot;发现没有票了&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="示例代码二："><a href="#示例代码二：" class="headerlink" title="示例代码二："></a>示例代码二：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread2.safemethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketSafeDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TicketRunnable tr = <span class="keyword">new</span> TicketRunnable();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			sellTicket();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//非静态方法隐含的锁对象就是this</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例代码三："><a href="#示例代码三：" class="headerlink" title="示例代码三："></a>示例代码三：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread2.safemethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketSafeDemo3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TicketThread t1 = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		TicketThread t2 = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		TicketThread t3 = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			sellTicket();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里必须是静态方法，因为如果是非静态方法，隐含的锁对象是this，那么多个线程就不是同一个锁对象了</span></span><br><span class="line">	<span class="comment">//而静态方法隐含的锁对象是当前类的Class对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票可以卖 </span></span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖：&quot;</span> + ticket--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、同步代码块的锁对象"><a href="#2、同步代码块的锁对象" class="headerlink" title="2、同步代码块的锁对象"></a>2、同步代码块的锁对象</h4><p>同步锁对象：</p>
<ul>
<li>锁对象可以是任意类型。</li>
<li>多个线程对象  要使用同一把锁。</li>
<li>习惯上先考虑this，但是要注意是否同一个this</li>
</ul>
<h5 id="示例代码一：this对象"><a href="#示例代码一：this对象" class="headerlink" title="示例代码一：this对象"></a>示例代码一：this对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread2.safeblock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketSafeDemo1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 2、创建资源对象</span></span><br><span class="line">		Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3、启动多个线程操作资源类的对象</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;窗口一&quot;</span>) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">// 加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="string">&quot;窗口二&quot;</span>) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">// 加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">// 加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、编写资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出一张票，剩余:&quot;</span> + --total);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(Thread.currentThread().getName() + <span class="string">&quot;发现没有票了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="示例代码二：this对象"><a href="#示例代码二：this对象" class="headerlink" title="示例代码二：this对象"></a>示例代码二：this对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread2.safeblock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketSafeDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TicketRunnable tr = <span class="keyword">new</span> TicketRunnable();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例代码三：其他对象"><a href="#示例代码三：其他对象" class="headerlink" title="示例代码三：其他对象"></a>示例代码三：其他对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread2.safeblock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketSafeDemo3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TicketThread t1 = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		TicketThread t2 = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		TicketThread t3 = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object myLock = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(total&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//			synchronized (this) &#123;//此处不能选this对象作为锁，因为this对于上面的三个线程来说是不同的</span></span><br><span class="line"><span class="comment">//			synchronized (TicketThread.class) &#123;//可以，因为在JVM中TicketThread类的Class对象只有一个</span></span><br><span class="line"><span class="comment">//			synchronized (&quot;&quot;) &#123;//可以，因为在JVM中&quot;&quot;字符串对象只有一个</span></span><br><span class="line">			<span class="keyword">synchronized</span> (myLock) &#123;<span class="comment">//可以，因为在JVM中myLock对象只有一个</span></span><br><span class="line">				<span class="keyword">if</span>(total&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					System.out.println(getName() + <span class="string">&quot;卖出一张票，剩余:&quot;</span> + --total);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁的范围问题"><a href="#锁的范围问题" class="headerlink" title="锁的范围问题"></a>锁的范围问题</h3><p>锁的范围太小：不能解决安全问题</p>
<p>锁的范围太大：因为一旦某个线程抢到锁，其他线程就只能等待，所以范围太大，效率会降低，不能合理利用CPU资源。</p>
<h4 id="示例代码一：锁范围太小"><a href="#示例代码一：锁范围太小" class="headerlink" title="示例代码一：锁范围太小"></a>示例代码一：锁范围太小</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread3.lockrange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketSafeDemo1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//2、创建资源对象</span></span><br><span class="line">		Ticket2 ticket = <span class="keyword">new</span> Ticket2();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、启动多个线程操作资源类的对象</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;窗口一&quot;</span>)&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="string">&quot;窗口二&quot;</span>)&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1、编写资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket2</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(total&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//锁的范围太小</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出一张票，剩余:&quot;</span> + --total);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(Thread.currentThread().getName() + <span class="string">&quot;发现没有票了&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="示例代码二：锁范围太小"><a href="#示例代码二：锁范围太小" class="headerlink" title="示例代码二：锁范围太小"></a>示例代码二：锁范围太小</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread3.lockrange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketSafeDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TicketRunnable tr = <span class="keyword">new</span> TicketRunnable();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">				<span class="comment">//if (ticket &gt; 0) &#123;//条件没有锁进去</span></span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line">				<span class="comment">//&#125;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例代码三：锁范围太大"><a href="#示例代码三：锁范围太大" class="headerlink" title="示例代码三：锁范围太大"></a>示例代码三：锁范围太大</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread3.lockrange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketSafeDemo3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TicketRunnableDemo tr = <span class="keyword">new</span> TicketRunnableDemo();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(tr,<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketRunnableDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="示例代码四：锁范围太大"><a href="#示例代码四：锁范围太大" class="headerlink" title="示例代码四：锁范围太大"></a>示例代码四：锁范围太大</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread3.lockrange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketSafeDemo1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//2、创建资源对象</span></span><br><span class="line">		Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、启动多个线程操作资源类的对象</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;窗口一&quot;</span>)&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//问题：一旦某个线程占了ticket锁，就要等它把票全部卖完，才会释放锁了</span></span><br><span class="line">				<span class="keyword">synchronized</span> (ticket) &#123;</span><br><span class="line">					<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">							ticket.sale();</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="string">&quot;窗口二&quot;</span>)&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (ticket) &#123;</span><br><span class="line">					<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">							ticket.sale();</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (ticket) &#123;</span><br><span class="line">					<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">							ticket.sale();</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1、编写资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(total&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出一张票，剩余:&quot;</span> + --total);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(Thread.currentThread().getName() + <span class="string">&quot;发现没有票了&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何编写多线程的程序呢？"><a href="#如何编写多线程的程序呢？" class="headerlink" title="如何编写多线程的程序呢？"></a>如何编写多线程的程序呢？</h3><ul>
<li><p>原则：</p>
<ul>
<li>线程操作资源类</li>
<li>高内聚低耦合</li>
</ul>
</li>
<li><p>步骤：</p>
<ul>
<li>编写资源类</li>
<li>考虑线程安全问题，在资源类中考虑使用同步代码块或同步方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 2、创建资源对象</span></span><br><span class="line">		Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3、启动多个线程操作资源类的对象</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;窗口一&quot;</span>) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">// 加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="string">&quot;窗口二&quot;</span>) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">// 加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);<span class="comment">// 加入这个，使得问题暴露的更明显</span></span><br><span class="line">						ticket.sale();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、编写资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(total&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(Thread.currentThread().getName() + <span class="string">&quot;发现没有票了&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出一张票，剩余:&quot;</span> + --total);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例设计模式的线程安全问题"><a href="#单例设计模式的线程安全问题" class="headerlink" title="单例设计模式的线程安全问题"></a>单例设计模式的线程安全问题</h3><h4 id="1、饿汉式没有线程安全问题"><a href="#1、饿汉式没有线程安全问题" class="headerlink" title="1、饿汉式没有线程安全问题"></a>1、饿汉式没有线程安全问题</h4><p>饿汉式：上来就创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlyOneDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		OnlyOne o1 = OnlyOne.INSTANCE;</span><br><span class="line">		OnlyOne o2 = OnlyOne.INSTANCE;</span><br><span class="line">		</span><br><span class="line">		System.out.println(o1);</span><br><span class="line">		System.out.println(o2);</span><br><span class="line">		System.out.println(o1==o2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnlyOne</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OnlyOne INSTANCE = <span class="keyword">new</span> OnlyOne();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">OnlyOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、懒汉式线程安全问题"><a href="#2、懒汉式线程安全问题" class="headerlink" title="2、懒汉式线程安全问题"></a>2、懒汉式线程安全问题</h4><p>延迟创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Single s1 = Single.getInstance();</span><br><span class="line">        Single s2 = Single.getInstance();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Single s1;</span><br><span class="line">    Single s2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                s1 = Single.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                s2 = Single.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(s1 + <span class="string">&quot; : &quot;</span> + s2);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h2><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p><strong>为什么要处理线程间通信：</strong></p>
<p>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。而多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些通信机制，可以协调它们的工作，以此来帮我们达到多线程共同操作一份数据。</p>
<p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，此时B线程必须等到A线程完成后才能执行，那么线程A与线程B之间就需要线程通信，即—— <strong>等待唤醒机制。</strong></p>
<h3 id="等待唤醒机制-1"><a href="#等待唤醒机制-1" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><p><strong>什么是等待唤醒机制</strong></p>
<p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。</p>
<p>就是在一个线程满足某个条件时，就进入等待状态（<strong>wait()</strong>/**wait(time)<strong>）， 等待其他线程执行完他们的指定代码过后再将其唤醒（</strong>notify()**）;或可以指定wait的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果需要，可以使用 notifyAll()来唤醒所有的等待线程。wait/notify 就是线程间的一种协作机制。</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING或TIMED_WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”或者等待时间到，在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个线程释放；</li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>被通知线程被唤醒后也不一定能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE（可运行） 状态；</li>
<li>否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong></p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li>
</ol>
<h3 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h3><p>等待唤醒机制可以解决经典的“生产者与消费者”的问题。</p>
<p>生产者与消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个（多个）共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p>
<p>生产者与消费者问题中其实隐含了两个问题：</p>
<ul>
<li>线程安全问题：因为生产者与消费者共享数据缓冲区，不过这个问题可以使用同步解决。</li>
<li>线程的协调工作问题：<ul>
<li>要解决该问题，就必须让生产者线程在缓冲区满时等待(wait)，暂停进入阻塞状态，等到下次消费者消耗了缓冲区中的数据的时候，通知(notify)正在等待的线程恢复到就绪状态，重新开始往缓冲区添加数据。同样，也可以让消费者线程在缓冲区空时进入等待(wait)，暂停进入阻塞状态，等到生产者往缓冲区添加数据之后，再通知(notify)正在等待的线程恢复到就绪状态。通过这样的通信机制来解决此类问题。</li>
</ul>
</li>
</ul>
<h4 id="一个厨师一个服务员问题"><a href="#一个厨师一个服务员问题" class="headerlink" title="一个厨师一个服务员问题"></a>一个厨师一个服务员问题</h4><p>案例：有家餐馆的取餐口比较小，只能放10份快餐，厨师做完快餐放在取餐口的工作台上，服务员从这个工作台取出快餐给顾客。现在有1个厨师和1个服务员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCommunicate</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1、创建资源类对象</span></span><br><span class="line">		Workbench workbench = <span class="keyword">new</span> Workbench();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2、创建和启动厨师线程</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="string">&quot;厨师&quot;</span>) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					workbench.put();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3、创建和启动服务员线程</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="string">&quot;服务员&quot;</span>) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					workbench.take();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、定义资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Workbench</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (num &gt;= MAX_VALUE) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		num++;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot;制作了一份快餐，现在工作台上有：&quot;</span> + num + <span class="string">&quot;份快餐&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.notify();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		num--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取走了一份快餐，现在工作台上有：&quot;</span> + num + <span class="string">&quot;份快餐&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.notify();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="多个厨师多个服务员问题"><a href="#多个厨师多个服务员问题" class="headerlink" title="多个厨师多个服务员问题"></a>多个厨师多个服务员问题</h4><p>案例：有家餐馆的取餐口比较小，只能放10份快餐，厨师做完快餐放在取餐口的工作台上，服务员从这个工作台取出快餐给顾客。现在有多个厨师和多个服务员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCommunicate2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1、创建资源类对象</span></span><br><span class="line">		WindowBoard windowBoard = <span class="keyword">new</span> WindowBoard();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2、创建和启动厨师线程</span></span><br><span class="line">		<span class="comment">// 3、创建和启动服务员线程</span></span><br><span class="line">		Cook c1 = <span class="keyword">new</span> Cook(<span class="string">&quot;张三&quot;</span>,windowBoard);</span><br><span class="line">		Cook c2 = <span class="keyword">new</span> Cook(<span class="string">&quot;李四&quot;</span>,windowBoard);</span><br><span class="line">		Waiter w1 = <span class="keyword">new</span> Waiter(<span class="string">&quot;小红&quot;</span>,windowBoard);</span><br><span class="line">		Waiter w2 = <span class="keyword">new</span> Waiter(<span class="string">&quot;小绿&quot;</span>,windowBoard);</span><br><span class="line">		</span><br><span class="line">		c1.start();</span><br><span class="line">		c2.start();</span><br><span class="line">		w1.start();</span><br><span class="line">		w2.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1、定义资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowBoard</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (num &gt;= MAX_VALUE) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		num++;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot;制作了一份快餐，现在工作台上有：&quot;</span> + num + <span class="string">&quot;份快餐&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		num--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取走了一份快餐，现在工作台上有：&quot;</span> + num + <span class="string">&quot;份快餐&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、定义厨师类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cook</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> WindowBoard windowBoard;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cook</span><span class="params">(String name,WindowBoard windowBoard)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.windowBoard = windowBoard;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			windowBoard.put();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、定义服务员类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> WindowBoard windowBoard;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Waiter</span><span class="params">(String name,WindowBoard windowBoard)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.windowBoard = windowBoard;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			windowBoard.take();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>1、要求两个线程，同时打印字母，每个线程都能连续打印3个字母。两个线程交替打印，一个线程打印字母的小写形式，一个线程打印字母的大写形式，但是字母是连续的。当字母循环到z之后，回到a。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171252.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintLetterDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 2、创建资源对象</span></span><br><span class="line">		PrintLetter p = <span class="keyword">new</span> PrintLetter();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3、创建两个线程打印</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="string">&quot;小写字母&quot;</span>) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					p.printLower();</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);<span class="comment">// 控制节奏</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="string">&quot;大写字母&quot;</span>) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					p.printUpper();</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);<span class="comment">// 控制节奏</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、定义资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintLetter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> letter = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printLower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + letter);</span><br><span class="line">			letter++;</span><br><span class="line">			<span class="keyword">if</span> (letter &gt; <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">				letter = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.notify();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.wait();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printUpper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + (<span class="keyword">char</span>) (letter - <span class="number">32</span>));</span><br><span class="line">			letter++;</span><br><span class="line">			<span class="keyword">if</span> (letter &gt; <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">				letter = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.notify();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.wait();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><h3 id="观点1：5种状态"><a href="#观点1：5种状态" class="headerlink" title="观点1：5种状态"></a>观点1：5种状态</h3><p>简单来说，线程的生命周期有五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Dead）。CPU需要在多条线程之间切换，于是线程状态会多次在运行、阻塞、就绪之间切换。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171213.png"></p>
<p><strong>新建</strong></p>
<p>当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状。此时它和其他Java对象一样，仅仅由JVM为其分配了内存，并初始化了实例变量的值。此时的线程对象并没有任何线程的动态特征，程序也不会执行它的线程体run()。</p>
<p><strong>就绪</strong></p>
<p>但是当线程对象调用了start()方法之后，就不一样了，线程就从新建状态转为就绪状态。JVM会为其创建方法调用栈和程序计数器，当然，处于这个状态中的线程并没有开始运行，只是表示已具备了运行的条件，随时可以被调度。至于什么时候被调度，取决于JVM里线程调度器的调度。</p>
<blockquote>
<p>注意：</p>
<p>程序只能对新建状态的线程调用start()，并且只能调用一次，如果对非新建状态的线程，如已启动的线程或已死亡的线程调用start()都会报错IllegalThreadStateException异常。</p>
</blockquote>
<p><strong>运行</strong></p>
<p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程体代码，则该线程处于运行状态。如果计算机只有一个CPU，在任何时刻只有一个线程处于运行状态，如果计算机有多个处理器，将会有多个线程并行(Parallel)执行。</p>
<p>当然，美好的时光总是短暂的，而且CPU讲究雨露均沾。对于抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务，当该时间用完，系统会剥夺该线程所占用的资源，让其回到就绪状态等待下一次被调度。此时其他线程将获得执行机会，而在选择下一个线程时，系统会适当考虑线程的优先级。</p>
<p><strong>阻塞</strong></p>
<p>当在运行过程中的线程遇到如下情况时，线程会进入阻塞状态：</p>
<ul>
<li>线程调用了sleep()方法，主动放弃所占用的CPU资源；</li>
<li>线程试图获取一个同步监视器，但该同步监视器正被其他线程持有；</li>
<li>线程执行过程中，同步监视器调用了wait()，让它等待某个通知（notify）；</li>
<li>线程执行过程中，同步监视器调用了wait(time)</li>
<li>线程执行过程中，遇到了其他线程对象的加塞（join）；</li>
<li>线程被调用suspend方法被挂起（已过时，因为容易发生死锁）；</li>
</ul>
<p>当前正在执行的线程被阻塞后，其他线程就有机会执行了。针对如上情况，当发生如下情况时会解除阻塞，让该线程重新进入就绪状态，等待线程调度器再次调度它：</p>
<ul>
<li>线程的sleep()时间到；</li>
<li>线程成功获得了同步监视器；</li>
<li>线程等到了通知(notify)；</li>
<li>线程wait的时间到了</li>
<li>加塞的线程结束了；</li>
<li>被挂起的线程又被调用了resume恢复方法（已过时，因为容易发生死锁）；</li>
</ul>
<p><strong>5.</strong> <strong>死亡</strong></p>
<p>线程会以以下三种方式之一结束，结束后的线程就处于死亡状态：</p>
<ul>
<li>run()方法执行完成，线程正常结束</li>
<li>线程执行过程中抛出了一个未捕获的异常（Exception）或错误（Error）</li>
<li>直接调用该线程的stop()来结束该线程（已过时，因为容易发生死锁）</li>
</ul>
<h3 id="观点2：6种状态"><a href="#观点2：6种状态" class="headerlink" title="观点2：6种状态"></a>观点2：6种状态</h3><p>在java.lang.Thread.State的枚举类中这样定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先它没有区分：就绪和运行状态，因为对于Java对象来说，只能标记为可运行，至于什么时候运行，不是JVM来控制的了，是OS来进行调度的，而且时间非常短暂，因此对于Java对象的状态来说，无法区分。只能我们人为的进行想象和理解。</p>
<p>其次根据Thread.State的定义，阻塞状态是分为三种的：BLOCKED、WAITING、TIMED_WAITING。</p>
<ul>
<li>BLOCKED：是指互有竞争关系的几个线程，其中一个线程占有锁对象时，其他线程只能等待锁。只有获得锁对象的线程才能有执行机会。</li>
<li>TIMED_WAITING：当前线程执行过程中遇到Thread类的sleep或join，Object类的wait，LockSupport类的park方法，并且在调用这些方法时，设置了时间，那么当前线程会进入TIMED_WAITING，直到时间到，或被中断。</li>
<li>WAITING：当前线程执行过程中遇到遇到Object类的wait，Thread类的join，LockSupport类的park方法，并且在调用这些方法时，没有指定时间，那么当前线程会进入WAITING状态，直到被唤醒。<ul>
<li>通过Object类的wait进入WAITING状态的要有Object的notify/notifyAll唤醒；</li>
<li>通过Condition的await进入WAITING状态的要有Conditon的signal方法唤醒；</li>
<li>通过LockSupport类的park方法进入WAITING状态的要有LockSupport类的unpark方法唤醒</li>
<li>通过Thread类的join进入WAITING状态，只有调用join方法的线程对象结束才能让当前线程恢复；</li>
</ul>
</li>
</ul>
<p>说明：当从WAITING或TIMED_WAITING恢复到Runnable状态时，如果发现当前线程没有得到监视器锁，那么会立刻转入BLOCKED状态。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171144.png" alt="image-20200521184149034"></p>
<h2 id="释放锁操作与死锁"><a href="#释放锁操作与死锁" class="headerlink" title="释放锁操作与死锁"></a>释放锁操作与死锁</h2><p>任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定，那么何时会释放对同步监视器的锁定呢？</p>
<h3 id="释放锁的操作"><a href="#释放锁的操作" class="headerlink" title="释放锁的操作"></a><strong>释放锁的操作</strong></h3><p>当前线程的同步方法、同步代码块执行结束。</p>
<p>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致当前线程异常结束。</p>
<p>当前线程在同步代码块、同步方法中执行了锁对象的wait()方法，当前线程被挂起，并释放锁。</p>
<h3 id="不会释放锁的操作"><a href="#不会释放锁的操作" class="headerlink" title="不会释放锁的操作"></a><strong>不会释放锁的操作</strong></h3><p>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行。</p>
<p>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该该线程挂起，该线程不会释放锁（同步监视器）。应尽量避免使用suspend()和resume()这样的过时来控制线程。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>不同的线程分别锁住对方需要的同步监视器对象不释放，都在等待对方先放弃时就形成了线程的死锁。一旦出现死锁，整个程序既不会发生异常，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object g = <span class="keyword">new</span> Object();</span><br><span class="line">		Object m = <span class="keyword">new</span> Object();</span><br><span class="line">		Owner s = <span class="keyword">new</span> Owner(g,m);</span><br><span class="line">		Customer c = <span class="keyword">new</span> Customer(g,m);</span><br><span class="line">		<span class="keyword">new</span> Thread(s).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(c).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Owner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object goods;</span><br><span class="line">	<span class="keyword">private</span> Object money;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Owner</span><span class="params">(Object goods, Object money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.goods = goods;</span><br><span class="line">		<span class="keyword">this</span>.money = money;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (goods) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;先给钱&quot;</span>);</span><br><span class="line">			<span class="keyword">synchronized</span> (money) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;发货&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object goods;</span><br><span class="line">	<span class="keyword">private</span> Object money;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Object goods, Object money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.goods = goods;</span><br><span class="line">		<span class="keyword">this</span>.money = money;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (money) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;先发货&quot;</span>);</span><br><span class="line">			<span class="keyword">synchronized</span> (goods) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;再给钱&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题：sleep-和wait-方法的区别"><a href="#面试题：sleep-和wait-方法的区别" class="headerlink" title="面试题：sleep()和wait()方法的区别"></a>面试题：sleep()和wait()方法的区别</h3><p>（1）sleep()不释放锁，wait()释放锁</p>
<p>（2）sleep()指定休眠的时间，wait()可以指定时间也可以无限等待直到notify或notifyAll</p>
<p>（3）sleep()在Thread类中声明的静态方法，wait方法在Object类中声明</p>
<p>因为我们调用wait（）方法是由锁对象调用，而锁对象的类型是任意类型的对象。那么希望任意类型的对象都要有的方法，只能声明在Object类中。</p>
<h1 id="基础API与常见算法"><a href="#基础API与常见算法" class="headerlink" title="基础API与常见算法"></a>基础API与常见算法</h1><h2 id="和数学相关的类"><a href="#和数学相关的类" class="headerlink" title="和数学相关的类"></a>和数学相关的类</h2><h3 id="java-lang-Math"><a href="#java-lang-Math" class="headerlink" title="java.lang.Math"></a>java.lang.Math</h3><p><code>java.lang.Math</code> 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</p>
<ul>
<li><code>public static double abs(double a) </code> ：返回 double 值的绝对值。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.abs(-<span class="number">5</span>); <span class="comment">//d1的值为5</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.abs(<span class="number">5</span>); <span class="comment">//d2的值为5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static double ceil(double a)</code> ：返回大于等于参数的最小的整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.ceil(<span class="number">3.3</span>); <span class="comment">//d1的值为 4.0</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.ceil(-<span class="number">3.3</span>); <span class="comment">//d2的值为 -3.0</span></span><br><span class="line"><span class="keyword">double</span> d3 = Math.ceil(<span class="number">5.1</span>); <span class="comment">//d3的值为 6.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static double floor(double a) </code> ：返回小于等于参数最大的整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.floor(<span class="number">3.3</span>); <span class="comment">//d1的值为3.0</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.floor(-<span class="number">3.3</span>); <span class="comment">//d2的值为-4.0</span></span><br><span class="line"><span class="keyword">double</span> d3 = Math.floor(<span class="number">5.1</span>); <span class="comment">//d3的值为 5.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static long round(double a)</code> ：返回最接近参数的 long。(相当于四舍五入方法)  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> d1 = Math.round(<span class="number">5.5</span>); <span class="comment">//d1的值为6.0</span></span><br><span class="line"><span class="keyword">long</span> d2 = Math.round(<span class="number">5.4</span>); <span class="comment">//d2的值为5.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>public static double pow(double a,double b)：返回a的b幂次方法</li>
<li>public static double sqrt(double a)：返回a的平方根</li>
<li>public static double random()：返回[0,1)的随机值</li>
<li>public static final double PI：返回圆周率</li>
<li>public static double max(double x, double y)：返回x,y中的最大值</li>
<li>public static double min(double x, double y)：返回x,y中的最小值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> result = Math.pow(<span class="number">2</span>,<span class="number">31</span>);</span><br><span class="line"><span class="keyword">double</span> sqrt = Math.sqrt(<span class="number">256</span>);</span><br><span class="line"><span class="keyword">double</span> rand = Math.random();</span><br><span class="line"><span class="keyword">double</span> pi = Math.PI;</span><br></pre></td></tr></table></figure>

<h5 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h5><p>请使用<code>Math</code> 相关的API，计算在 <code>-10.8</code>  到<code>5.9</code>  之间，绝对值大于<code>6</code>  或者小于<code>2.1</code> 的整数有多少个？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义最小值</span></span><br><span class="line">    <span class="keyword">double</span> min = -<span class="number">10.8</span>;</span><br><span class="line">    <span class="comment">// 定义最大值</span></span><br><span class="line">    <span class="keyword">double</span> max = <span class="number">5.9</span>;</span><br><span class="line">    <span class="comment">// 定义变量计数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 范围内循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> i = Math.ceil(min); i &lt;= max; i++) &#123;</span><br><span class="line">      <span class="comment">// 获取绝对值并判断</span></span><br><span class="line">      <span class="keyword">if</span> (Math.abs(i) &gt; <span class="number">6</span> || Math.abs(i) &lt; <span class="number">2.1</span>) &#123;</span><br><span class="line">        <span class="comment">// 计数</span></span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;个数为: &quot;</span> + count + <span class="string">&quot; 个&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-math包"><a href="#java-math包" class="headerlink" title="java.math包"></a>java.math包</h3><h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><p>不可变的任意精度的整数。</p>
<ul>
<li>BigInteger(String val) </li>
<li>BigInteger add(BigInteger val)  </li>
<li>BigInteger subtract(BigInteger val)</li>
<li>BigInteger multiply(BigInteger val) </li>
<li>BigInteger divide(BigInteger val) </li>
<li>BigInteger remainder(BigInteger val)</li>
<li>….</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//		long bigNum = 123456789123456789123456789L;</span></span><br><span class="line">		</span><br><span class="line">		BigInteger b1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;123456789123456789123456789&quot;</span>);</span><br><span class="line">		BigInteger b2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;78923456789123456789123456789&quot;</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		System.out.println(&quot;和：&quot; + (b1+b2));//错误的，无法直接使用+进行求和</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;和：&quot;</span> + b1.add(b2));</span><br><span class="line">		System.out.println(<span class="string">&quot;减：&quot;</span> + b1.subtract(b2));</span><br><span class="line">		System.out.println(<span class="string">&quot;乘：&quot;</span> + b1.multiply(b2));</span><br><span class="line">		System.out.println(<span class="string">&quot;除：&quot;</span> + b2.divide(b1));</span><br><span class="line">		System.out.println(<span class="string">&quot;余：&quot;</span> + b2.remainder(b1));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RoundingMode枚举类"><a href="#RoundingMode枚举类" class="headerlink" title="RoundingMode枚举类"></a>RoundingMode枚举类</h4><p>CEILING ：向正无限大方向舍入的舍入模式。<br>DOWN ：向零方向舍入的舍入模式。<br>FLOOR：向负无限大方向舍入的舍入模式。<br>HALF_DOWN ：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向下舍入。<br>HALF_EVEN：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。<br>HALF_UP：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向上舍入。<br>UNNECESSARY：用于断言请求的操作具有精确结果的舍入模式，因此不需要舍入。<br>UP：远离零方向舍入的舍入模式。 </p>
<h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><p>不可变的、任意精度的有符号十进制数。</p>
<ul>
<li>BigDecimal(String val) </li>
<li>BigDecimal add(BigDecimal val) </li>
<li>BigDecimal subtract(BigDecimal val)</li>
<li>BigDecimal multiply(BigDecimal val) </li>
<li>BigDecimal divide(BigDecimal val) </li>
<li>BigDecimal divide(BigDecimal divisor, int roundingMode) </li>
<li>BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) </li>
<li>BigDecimal remainder(BigDecimal val) </li>
<li>….</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">/*double big = 12.123456789123456789123456789;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;big = &quot; + big);*/</span></span><br><span class="line">		</span><br><span class="line">		BigDecimal b1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45678912345678912345678912345678&quot;</span>);</span><br><span class="line">		BigDecimal b2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;7.8923456789123456789123456789998898888&quot;</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		System.out.println(&quot;和：&quot; + (b1+b2));//错误的，无法直接使用+进行求和</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;和：&quot;</span> + b1.add(b2));</span><br><span class="line">		System.out.println(<span class="string">&quot;减：&quot;</span> + b1.subtract(b2));</span><br><span class="line">		System.out.println(<span class="string">&quot;乘：&quot;</span> + b1.multiply(b2));</span><br><span class="line">		System.out.println(<span class="string">&quot;除：&quot;</span> + b1.divide(b2,<span class="number">20</span>,RoundingMode.UP));<span class="comment">//divide(BigDecimal divisor, int scale, int roundingMode)</span></span><br><span class="line">		System.out.println(<span class="string">&quot;除：&quot;</span> + b1.divide(b2,<span class="number">20</span>,RoundingMode.DOWN));<span class="comment">//divide(BigDecimal divisor, int scale, int roundingMode)</span></span><br><span class="line">		System.out.println(<span class="string">&quot;余：&quot;</span> + b1.remainder(b2));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-util-Random"><a href="#java-util-Random" class="headerlink" title="java.util.Random"></a>java.util.Random</h3><p>用于产生随机数</p>
<ul>
<li><p>boolean nextBoolean():返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean 值。 </p>
</li>
<li><p>void nextBytes(byte[] bytes):生成随机字节并将其置于用户提供的 byte 数组中。 </p>
</li>
<li><p>double nextDouble():返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 double 值。 </p>
</li>
<li><p>float nextFloat():返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 float 值。 </p>
</li>
<li><p>double nextGaussian():返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0。 </p>
</li>
<li><p>int nextInt():返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。 </p>
</li>
<li><p>int nextInt(int n):返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值。 </p>
</li>
<li><p>long nextLong():返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Random r = <span class="keyword">new</span> Random();</span><br><span class="line">	System.out.println(<span class="string">&quot;随机整数：&quot;</span> + r.nextInt());</span><br><span class="line">	System.out.println(<span class="string">&quot;随机小数：&quot;</span> + r.nextDouble());</span><br><span class="line">	System.out.println(<span class="string">&quot;随机布尔值：&quot;</span> + r.nextBoolean());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="日期时间API"><a href="#日期时间API" class="headerlink" title="日期时间API"></a>日期时间API</h2><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><h4 id="java-util-Date"><a href="#java-util-Date" class="headerlink" title="java.util.Date"></a>java.util.Date</h4><p>new  Date()：当前系统时间</p>
<p>long  getTime()：返回该日期时间对象距离1970-1-1 0.0.0 0毫秒之间的毫秒值</p>
<p>new Date(long 毫秒)：把该毫秒值换算成日期时间对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> time = Long.MAX_VALUE;</span><br><span class="line">	Date d = <span class="keyword">new</span> Date(time);</span><br><span class="line">	System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> time = <span class="number">1559807047979L</span>;</span><br><span class="line">	Date d = <span class="keyword">new</span> Date(time);</span><br><span class="line">	System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Date d = <span class="keyword">new</span> Date();</span><br><span class="line">	<span class="keyword">long</span> time = d.getTime();</span><br><span class="line">	System.out.println(time);<span class="comment">//1559807047979</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">	System.out.println(time);<span class="comment">//1559806982971</span></span><br><span class="line">	<span class="comment">//当前系统时间距离1970-1-1 0:0:0 0毫秒的时间差，毫秒为单位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Date d = <span class="keyword">new</span> Date();</span><br><span class="line">	System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="java-util-TimeZone"><a href="#java-util-TimeZone" class="headerlink" title="java.util.TimeZone"></a>java.util.TimeZone</h4><p>通常，使用 <code>getDefault</code> 获取 <code>TimeZone</code>，<code>getDefault</code>  基于程序运行所在的时区创建 <code>TimeZone</code>。</p>
<p>也可以用 <code>getTimeZone</code> 及时区 ID 获取 <code>TimeZone</code> 。例如美国太平洋时区的时区 ID 是  “America/Los_Angeles”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String[] all = TimeZone.getAvailableIDs();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all.length; i++) &#123;</span><br><span class="line">		System.out.println(all[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">	TimeZone t = TimeZone.getTimeZone(<span class="string">&quot;America/Los_Angeles&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见时区ID：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Asia/Shanghai</span><br><span class="line">UTC</span><br><span class="line">America/New_York</span><br></pre></td></tr></table></figure>



<h4 id="java-util-Calendar"><a href="#java-util-Calendar" class="headerlink" title="java.util.Calendar"></a>java.util.Calendar</h4><p><code>Calendar</code> 类是一个抽象类，它为特定瞬间与一组诸如  <code>YEAR</code>、<code>MONTH</code>、<code>DAY_OF_MONTH</code>、<code>HOUR</code>  等 <a href="../../java/util/Calendar.html#fields"><code>日历字段</code></a>之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距<em>历元</em>（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。与其他语言环境敏感类一样，<code>Calendar</code> 提供了一个类方法  <code>getInstance</code>，以获得此类型的一个通用的对象。</p>
<p>（1）getInstance()：得到Calendar的对象</p>
<p>（2）get(常量)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Calendar c = Calendar.getInstance();</span><br><span class="line">	System.out.println(c);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">	System.out.println(year);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> month = c.get(Calendar.MONTH)+<span class="number">1</span>;</span><br><span class="line">	System.out.println(month);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">	TimeZone t = TimeZone.getTimeZone(<span class="string">&quot;America/Los_Angeles&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//getInstance(TimeZone zone)</span></span><br><span class="line">	Calendar c = Calendar.getInstance(t);</span><br><span class="line">	System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="java-text-SimpleDateFormat"><a href="#java-text-SimpleDateFormat" class="headerlink" title="java.text.SimpleDateFormat"></a>java.text.SimpleDateFormat</h4><p>SimpleDateFormat用于日期时间的格式化。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171852.png" alt="1572599023197"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">	String str = <span class="string">&quot;2019年06月06日 16时03分14秒 545毫秒  星期四 +0800&quot;</span>;</span><br><span class="line">	SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z&quot;</span>);</span><br><span class="line">	Date d = sf.parse(str);</span><br><span class="line">	System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Date d = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">	SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z&quot;</span>);</span><br><span class="line">	<span class="comment">//把Date日期转成字符串，按照指定的格式转</span></span><br><span class="line">	String str = sf.format(d);</span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><p>Java1.0中包含了一个Date类，但是它的大多数方法已经在Java 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：</p>
<ul>
<li>可变性：象日期和时间这样的类对象应该是不可变的。Calendar类中可以使用三种方法更改日历字段：set()、add() 和 roll()。</li>
<li>偏移性：Date中的年份是从1900开始的，而月份都是从0开始的。</li>
<li>格式化：格式化只对Date有用，Calendar则不行。</li>
<li>此外，它们也不是线程安全的，不能处理闰秒等。</li>
</ul>
<p>可以说，对日期和时间的操作一直是Java程序员最痛苦的地方之一。第三次引入的API是成功的，并且java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。</p>
<p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。</p>
<ul>
<li>java.time – 包含值对象的基础包</li>
<li>java.time.chrono – 提供对不同的日历系统的访问。</li>
<li>java.time.format – 格式化和解析时间和日期</li>
<li>java.time.temporal – 包括底层框架和扩展特性</li>
<li>java.time.zone – 包含时区支持的类</li>
</ul>
<p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于时钟（Clock），本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。</p>
<h4 id="本地日期时间：LocalDate、LocalTime、LocalDateTime"><a href="#本地日期时间：LocalDate、LocalTime、LocalDateTime" class="headerlink" title="本地日期时间：LocalDate、LocalTime、LocalDateTime"></a>本地日期时间：LocalDate、LocalTime、LocalDateTime</h4><table>
<thead>
<tr>
<th>方法</th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>now() / now(ZoneId zone)</td>
<td>静态方法，根据当前时间创建对象/指定时区的对象</td>
</tr>
<tr>
<td>of()</td>
<td>静态方法，根据指定日期/时间创建对象</td>
</tr>
<tr>
<td>getDayOfMonth()/getDayOfYear()</td>
<td>获得月份天数(1-31) /获得年份天数(1-366)</td>
</tr>
<tr>
<td>getDayOfWeek()</td>
<td>获得星期几(返回一个 DayOfWeek 枚举值)</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获得月份, 返回一个 Month 枚举值</td>
</tr>
<tr>
<td>getMonthValue() / getYear()</td>
<td>获得月份(1-12) /获得年份</td>
</tr>
<tr>
<td>getHours()/getMinute()/getSecond()</td>
<td>获得当前对象对应的小时、分钟、秒</td>
</tr>
<tr>
<td>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</td>
<td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td>
</tr>
<tr>
<td>with(TemporalAdjuster  t)</td>
<td>将当前日期时间设置为校对器指定的日期时间</td>
</tr>
<tr>
<td>plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</td>
<td>向当前对象添加几天、几周、几个月、几年、几小时</td>
</tr>
<tr>
<td>minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()</td>
<td>从当前对象减去几月、几周、几天、几年、几小时</td>
</tr>
<tr>
<td>plus(TemporalAmount t)/minus(TemporalAmount t)</td>
<td>添加或减少一个 Duration 或 Period</td>
</tr>
<tr>
<td>isBefore()/isAfter()</td>
<td>比较两个 LocalDate</td>
</tr>
<tr>
<td>isLeapYear()</td>
<td>判断是否是闰年（在LocalDate类中声明）</td>
</tr>
<tr>
<td>format(DateTimeFormatter  t)</td>
<td>格式化本地日期、时间，返回一个字符串</td>
</tr>
<tr>
<td>parse(Charsequence text)</td>
<td>将指定格式的字符串解析为日期、时间</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LocalDate now = LocalDate.now();</span><br><span class="line">	LocalDate before = now.minusDays(<span class="number">100</span>);</span><br><span class="line">	System.out.println(before);<span class="comment">//2019-02-26</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LocalDate lai = LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">	LocalDate go = lai.plusDays(<span class="number">160</span>);</span><br><span class="line">	System.out.println(go);<span class="comment">//2019-10-20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LocalDate lai = LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">	System.out.println(lai.getDayOfYear());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LocalDate lai = LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">	System.out.println(lai);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LocalDateTime now = LocalDateTime.now();</span><br><span class="line">	System.out.println(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LocalTime now = LocalTime.now();</span><br><span class="line">	System.out.println(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LocalDate now = LocalDate.now();</span><br><span class="line">	System.out.println(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指定时区日期时间：ZonedDateTime"><a href="#指定时区日期时间：ZonedDateTime" class="headerlink" title="指定时区日期时间：ZonedDateTime"></a>指定时区日期时间：ZonedDateTime</h4><p>常见时区ID：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Asia/Shanghai</span><br><span class="line">UTC</span><br><span class="line">America/New_York</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestZonedDateTime</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ZonedDateTime t = ZonedDateTime.now();</span><br><span class="line">		System.out.println(t);</span><br><span class="line">		</span><br><span class="line">		ZonedDateTime t1 = ZonedDateTime.now(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">		System.out.println(t1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="持续日期-时间：Period和Duration"><a href="#持续日期-时间：Period和Duration" class="headerlink" title="持续日期/时间：Period和Duration"></a>持续日期/时间：Period和Duration</h4><p>Period:用于计算两个“日期”间隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		LocalDate t1 = LocalDate.now();</span><br><span class="line">		LocalDate t2 = LocalDate.of(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">31</span>);</span><br><span class="line">		Period between = Period.between(t1, t2);</span><br><span class="line">		System.out.println(between);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;相差的年数：&quot;</span>+between.getYears());<span class="comment">//1年</span></span><br><span class="line">		System.out.println(<span class="string">&quot;相差的月数：&quot;</span>+between.getMonths());<span class="comment">//又7个月</span></span><br><span class="line">		System.out.println(<span class="string">&quot;相差的天数：&quot;</span>+between.getDays());<span class="comment">//零25天</span></span><br><span class="line">		System.out.println(<span class="string">&quot;相差的总数：&quot;</span>+between.toTotalMonths());<span class="comment">//总共19个月</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Duration:用于计算两个“时间”间隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	LocalDateTime t1 = LocalDateTime.now();</span><br><span class="line">	LocalDateTime t2 = LocalDateTime.of(<span class="number">2017</span>, <span class="number">8</span>, <span class="number">29</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	Duration between = Duration.between(t1, t2);</span><br><span class="line">	System.out.println(between);</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">&quot;相差的总天数：&quot;</span>+between.toDays());</span><br><span class="line">	System.out.println(<span class="string">&quot;相差的总小时数：&quot;</span>+between.toHours());</span><br><span class="line">	System.out.println(<span class="string">&quot;相差的总分钟数：&quot;</span>+between.toMinutes());</span><br><span class="line">	System.out.println(<span class="string">&quot;相差的总秒数：&quot;</span>+between.getSeconds());</span><br><span class="line">	System.out.println(<span class="string">&quot;相差的总毫秒数：&quot;</span>+between.toMillis());</span><br><span class="line">	System.out.println(<span class="string">&quot;相差的总纳秒数：&quot;</span>+between.toNanos());</span><br><span class="line">	System.out.println(<span class="string">&quot;不够一秒的纳秒数：&quot;</span>+between.getNano());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DateTimeFormatter：日期时间格式化"><a href="#DateTimeFormatter：日期时间格式化" class="headerlink" title="DateTimeFormatter：日期时间格式化"></a>DateTimeFormatter：日期时间格式化</h4><p>该类提供了三种格式化方法：</p>
<p>预定义的标准格式。如：ISO_DATE_TIME;ISO_DATE</p>
<p>本地化相关的格式。如：ofLocalizedDate(FormatStyle.MEDIUM)</p>
<p>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span></span>&#123;</span><br><span class="line">		LocalDateTime now = LocalDateTime.now();</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		DateTimeFormatter df = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);//2019年6月6日 下午04时40分03秒</span></span><br><span class="line">		DateTimeFormatter df = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);<span class="comment">//19-6-6 下午4:40</span></span><br><span class="line">		String str = df.format(now);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">		LocalDateTime now = LocalDateTime.now();</span><br><span class="line">		</span><br><span class="line">		DateTimeFormatter df = DateTimeFormatter.ISO_DATE_TIME;<span class="comment">//2019-06-06T16:38:23.756</span></span><br><span class="line">		String str = df.format(now);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">		LocalDateTime now = LocalDateTime.now();</span><br><span class="line">		</span><br><span class="line">		DateTimeFormatter df = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒  SSS毫秒  E 是这一年的D天&quot;</span>);</span><br><span class="line">		String str = df.format(now);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="系统相关类"><a href="#系统相关类" class="headerlink" title="系统相关类"></a>系统相关类</h2><h3 id="java-lang-System类"><a href="#java-lang-System类" class="headerlink" title="java.lang.System类"></a>java.lang.System类</h3><p>系统类中很多好用的方法，其中几个如下：</p>
<ul>
<li><p>static long currentTimeMillis() ：返回当前系统时间距离1970-1-1 0:0:0的毫秒值</p>
</li>
<li><p>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)： </p>
<p>  从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。常用于数组的插入和删除</p>
</li>
<li><p>static void exit(int status) ：退出当前系统</p>
</li>
<li><p>static void gc() ：运行垃圾回收器。</p>
</li>
<li><p>static String getProperty(String key)：获取某个系统属性</p>
</li>
<li><p>…</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    	System.out.println(<span class="string">&quot;现在的系统时间距离1970年1月1日凌晨：&quot;</span> + time + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    	System.out.println(<span class="string">&quot;over&quot;</span>);<span class="comment">//不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="java-lang-Runtime类"><a href="#java-lang-Runtime类" class="headerlink" title="java.lang.Runtime类"></a>java.lang.Runtime类</h3><p>每个 Java 应用程序都有一个 <code>Runtime</code> 类实例，使应用程序能够与其运行的环境相连接。可以通过  <code>getRuntime</code> 方法获取当前运行时。  应用程序不能创建自己的 Runtime 类实例。</p>
<p>public static Runtime getRuntime()： 返回与当前 Java 应用程序相关的运行时对象。</p>
<p>public long totalMemory()：返回 Java 虚拟机中的内存总量。此方法返回的值可能随时间的推移而变化，这取决于主机环境。</p>
<p>public long freeMemory()：回 Java 虚拟机中的空闲内存量。调用 gc 方法可能导致 freeMemory 返回值的增加。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数组的算法升华"><a href="#数组的算法升华" class="headerlink" title="数组的算法升华"></a>数组的算法升华</h2><h3 id="数组的算法升华-1"><a href="#数组的算法升华-1" class="headerlink" title="数组的算法升华"></a>数组的算法升华</h3><h4 id="数组的反转"><a href="#数组的反转" class="headerlink" title="数组的反转"></a>数组的反转</h4><p>方法有两种：</p>
<p>1、借助一个新数组</p>
<p>2、首尾对应位置交换</p>
<p>第一种方式示例代码：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171846.png" alt="1572828418996"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)先创建一个新数组</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)复制元素</span></span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[len -<span class="number">1</span> - i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)舍弃旧的，让arr指向新数组</span></span><br><span class="line">arr = newArr;<span class="comment">//这里把新数组的首地址赋值给了arr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>缺点：需要借助一个数组，浪费额外空间，原数组需要垃圾回收</p>
</blockquote>
<p>第二种方式示例代码：</p>
<p><strong>实现思想：</strong>数组对称位置的元素互换。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171709.png" alt="1561469467316"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)计算要交换的次数：  次数 = arr.length/2</span></span><br><span class="line"><span class="comment">//(2)首尾对称位置交换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length/<span class="number">2</span>; i++)&#123;<span class="comment">//循环的次数就是交换的次数</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">	arr[arr.length-<span class="number">1</span>-i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或</p>
<p><img src="H:/00%25E3%2580%2581%25E5%25B0%259A%25E7%25A1%2585%25E8%25B0%25B7%25E5%25A4%25A7%25E8%25AF%25BE/2021%25E5%25B9%25B4%25E5%25B0%259A%25E7%25A1%2585%25E8%25B0%25B7Java%25E5%2590%258E%25E7%25AB%25AF%25E9%259D%25A2%25E6%258E%2588%25E7%258F%25AD%25E3%2580%25902021%25E5%25B9%25B45%25E6%259C%2588%25E7%25BB%2593%25E8%25AF%25BE%25E3%2580%2591/%25E8%25AF%25BE%25E4%25BB%25B6/%25E8%25AF%25BE%25E4%25BB%25B6/1.JAVA%25E6%25A0%25B8%25E5%25BF%2583%25E5%259F%25BA%25E7%25A1%2580/1.JAVA%25E6%25A0%25B8%25E5%25BF%2583%25E5%259F%25BA%25E7%25A1%2580%25E3%2580%2590%25E6%25B5%25B7%25E9%2587%258Fit%25E8%25B5%2584%25E6%25BA%2590%25EF%25BC%259A666java.com%25E3%2580%2591/%25E8%25AF%25BE%25E4%25BB%25B6/%25E7%25AC%25AC10%25E7%25AB%25A0%2520%25E5%259F%25BA%25E7%25A1%2580API%25E4%25B8%258E%25E5%25B8%25B8%25E8%25A7%2581%25E7%25AE%2597%25E6%25B3%2595/imgs/1561469087319.png" alt="1561469087319"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左右对称位置交换</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>,right=arr.length-<span class="number">1</span>; left&lt;right; left++,right--)&#123;</span><br><span class="line">	    <span class="comment">//首  与  尾交换</span></span><br><span class="line">	    <span class="keyword">int</span> temp = arr[left];</span><br><span class="line">	    arr[left] = arr[right];</span><br><span class="line">		arr[right] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//（3）遍历显示</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">	    System.out.println(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="数组的扩容"><a href="#数组的扩容" class="headerlink" title="数组的扩容"></a>数组的扩容</h4><p>示例：当原来的数组长度不够了需要扩容，例如需要新增位置来存储10</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要把arr数组扩容，增加1个位置</span></span><br><span class="line"><span class="comment">//(1)先创建一个新数组，它的长度 = 旧数组的长度+1，或者也可以扩大为原来数组长度的1.5倍，2倍等</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)复制元素</span></span><br><span class="line"><span class="comment">//注意：i&lt;arr.length   因位arr比newArr短，避免下标越界</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)把新元素添加到newArr的最后</span></span><br><span class="line">newArr[newArr.length-<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)如果下面继续使用arr，可以让arr指向新数组</span></span><br><span class="line">arr = newArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>（1）至于新数组的长度定义多少合适，看实际情况，如果新增的元素个数确定，那么可以增加指定长度，如果新增元素个数不确定，那么可以扩容为原来的1.5倍、2倍等</p>
<p>（2）数组扩容太多会造成浪费，太少会导致频繁扩容，效率低下</p>
</blockquote>
<h4 id="数组元素的插入"><a href="#数组元素的插入" class="headerlink" title="数组元素的插入"></a>数组元素的插入</h4><p>示例：在原数组的某个[index]插入一个元素</p>
<p>情形一：原数组未满</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>]=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line">arr[<span class="number">2</span>]=<span class="string">&quot;王五&quot;</span>;</span><br><span class="line"></span><br><span class="line">那么目前数组的长度是<span class="number">5</span>，而数组的实际元素个数是<span class="number">3</span>，如果此时需要在“张三”和“李四”之间插入一个“赵六”，即在[index=<span class="number">1</span>]的位置插入“赵六”，需要怎么做呢？</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>]=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line">arr[<span class="number">2</span>]=<span class="string">&quot;王五&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）移动2个元素，需要移动的起始元素下标是[1]，它需要移动到[2]，一共一共2个</span></span><br><span class="line">System.arraycopy(arr,<span class="number">1</span>,arr,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//（2）插入新元素</span></span><br><span class="line">arr[<span class="number">1</span>]=<span class="string">&quot;赵六&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情形二：原数组已满</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>]=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line">arr[<span class="number">2</span>]=<span class="string">&quot;王五&quot;</span>;</span><br><span class="line"></span><br><span class="line">那么目前数组的长度是<span class="number">3</span>，而数组的实际元素个数是<span class="number">3</span>，如果此时需要在“张三”和“李四”之间插入一个“赵六”，即在[index=<span class="number">1</span>]的位置插入“赵六”，需要怎么做呢？</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>]=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line">arr[<span class="number">2</span>]=<span class="string">&quot;王五&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）先扩容</span></span><br><span class="line">String[] newArr = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">	newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">arr=newArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）移动2个元素，需要移动的起始元素下标是[1]，它需要移动到[2]，一共一共2个</span></span><br><span class="line">System.arraycopy(arr,<span class="number">1</span>,arr,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//（3）插入新元素</span></span><br><span class="line">arr[<span class="number">1</span>]=<span class="string">&quot;赵六&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组元素的删除"><a href="#数组元素的删除" class="headerlink" title="数组元素的删除"></a>数组元素的删除</h4><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>]=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line">arr[<span class="number">2</span>]=<span class="string">&quot;王五&quot;</span>;</span><br><span class="line"></span><br><span class="line">现在需要删除“李四”，我们又不希望数组中间空着元素，该如何处理呢？</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>]=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line">arr[<span class="number">2</span>]=<span class="string">&quot;王五&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）移动元素，需要移动元素的起始下标[2]，该元素需要移动到[1]，一共需要移动1个元素</span></span><br><span class="line">System.arraycopy(arr,<span class="number">2</span>,arr,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）因为数组元素整体往左移动，这里本质上是复制，原来最后一个元素需要置空</span></span><br><span class="line">arr[<span class="number">2</span>]=<span class="keyword">null</span>;<span class="comment">//使得垃圾回收尽快回收对应对象的内存</span></span><br></pre></td></tr></table></figure>



<h4 id="数组的二分查找"><a href="#数组的二分查找" class="headerlink" title="数组的二分查找"></a>数组的二分查找</h4><p>二分查找：对折对折再对折</p>
<p>要求：要求数组元素必须支持比较大小，并且数组中的元素已经按大小排好序</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam2</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">25</span>,<span class="number">28</span>&#125;;<span class="comment">//数组是有序的</span></span><br><span class="line">		<span class="keyword">int</span> value = <span class="number">18</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//找到结束</span></span><br><span class="line">            <span class="keyword">if</span>(value == arr[mid])&#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; arr[mid])&#123;<span class="comment">//往右继续查找</span></span><br><span class="line">                <span class="comment">//移动左边界，使得mid往右移动</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; arr[mid])&#123;<span class="comment">//往左边继续查找</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    		System.out.println(value + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		System.out.println(value + <span class="string">&quot;的下标是&quot;</span> + index);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171914.png"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171917.png"></p>
<h4 id="数组的直接选择排序"><a href="#数组的直接选择排序" class="headerlink" title="数组的直接选择排序"></a>数组的直接选择排序</h4><p>示例代码：简单的直接选择排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">//（1）找出本轮未排序元素中的最值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    未排序元素：</span></span><br><span class="line"><span class="comment">    第1轮：i=1,未排序，[0,7]，本轮未排序元素第一个元素是[0]</span></span><br><span class="line"><span class="comment">    第2轮：i=2,未排序，[1,7]，本轮未排序元素第一个元素是[1]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    第7轮：i=7,未排序，[6,7]，本轮未排序元素第一个元素是[6]</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    每一轮未排序元素的起始下标：0,1,2,3,4,5,6，正好是i-1的</span></span><br><span class="line"><span class="comment">    未排序的后面的元素依次：</span></span><br><span class="line"><span class="comment">    第1轮：[1,7]  j=1,2,3,4,5,6,7</span></span><br><span class="line"><span class="comment">    第2轮：[2,4]  j=2,3,4,5,6,7</span></span><br><span class="line"><span class="comment">    。。。。</span></span><br><span class="line"><span class="comment">    第7轮：[7]    j=7</span></span><br><span class="line"><span class="comment">    j的起点是i，终点都是7</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;arr.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; max)&#123;</span><br><span class="line">            max = arr[j];</span><br><span class="line">            index = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（2）如果这个最值没有在它应该在的位置，就与这个位置的元素交换</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，最大值应该在[0]</span></span><br><span class="line"><span class="comment">    第2轮，最大值应该在[1]</span></span><br><span class="line"><span class="comment">    ....</span></span><br><span class="line"><span class="comment">    第7轮，最大值应该在[6]</span></span><br><span class="line"><span class="comment">    正好是i-1的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(index != i-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//交换arr[i-1]与arr[index]</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i-<span class="number">1</span>];</span><br><span class="line">        arr[i-<span class="number">1</span>] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">	System.out.print(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171939.png" alt="1561513135868"></p>
<h3 id="数组工具类"><a href="#数组工具类" class="headerlink" title="数组工具类"></a>数组工具类</h3><p>java.util.Arrays数组工具类，提供了很多静态方法来对数组进行操作，而且如下每一个方法都有各种重载形式，以下只列出int[]类型的，其他类型的数组类推：</p>
<ul>
<li><p>static int binarySearch(int[] a, int key) ：要求数组有序，在数组中查找key是否存在，如果存在返回第一次找到的下标，不存在返回负数</p>
</li>
<li><p>static int[] copyOf(int[] original, int newLength)  ：根据original原数组复制一个长度为newLength的新数组，并返回新数组</p>
</li>
<li><p>static int[] copyOfRange(int[] original, int from, int to) ：复制original原数组的[from,to)构成新数组，并返回新数组</p>
</li>
<li><p>static boolean equals(int[] a, int[] a2) ：比较两个数组的长度、元素是否完全相同</p>
</li>
<li><p>static void fill(int[] a, int val) ：用val填充整个a数组</p>
</li>
<li><p>static void fill(int[] a, int fromIndex, int toIndex, int val)：将a数组[fromIndex,toIndex)部分填充为val </p>
</li>
<li><p>static void sort(int[] a) ：将a数组按照从小到大进行排序</p>
</li>
<li><p>static void sort(int[] a, int fromIndex, int toIndex) ：将a数组的[fromIndex, toIndex)部分按照升序排列</p>
</li>
<li><p>static String toString(int[] a) ：把a数组的元素，拼接为一个字符串，形式为：[元素1，元素2，元素3。。。]</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 打印数组,输出地址值</span></span><br><span class="line">  		System.out.println(arr); <span class="comment">// [I@2ac1fdc4</span></span><br><span class="line">  		<span class="comment">// 数组内容转为字符串</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;arr数组初始状态：&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    	</span><br><span class="line">    	Arrays.fill(arr, <span class="number">3</span>);</span><br><span class="line">    	System.out.println(<span class="string">&quot;arr数组现在状态：&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    	</span><br><span class="line">    	Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			arr[i] = rand.nextInt(<span class="number">100</span>);<span class="comment">//赋值为100以内的随机整数</span></span><br><span class="line">		&#125;</span><br><span class="line">    	System.out.println(<span class="string">&quot;arr数组现在状态：&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span>[] arr2 = Arrays.copyOf(arr, <span class="number">10</span>);</span><br><span class="line">    	System.out.println(<span class="string">&quot;新数组：&quot;</span> + Arrays.toString(arr2));</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(<span class="string">&quot;两个数组的比较结果：&quot;</span> + Arrays.equals(arr, arr2));</span><br><span class="line">    	</span><br><span class="line">    	Arrays.sort(arr);</span><br><span class="line">    	System.out.println(<span class="string">&quot;arr数组现在状态：&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组面试题"><a href="#数组面试题" class="headerlink" title="数组面试题"></a>数组面试题</h3><h4 id="编程题1"><a href="#编程题1" class="headerlink" title="编程题1"></a>编程题1</h4><p>找出数组中一个值，使其左侧值的加和等于右侧值的加和，</p>
<p>​    例如：[1,2,5,3,2,4,2]，结果为：第4个值3</p>
<p>​                [9, 6, 8, 8, 7, 6, 9, 5, 2, 5]，结果是没有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">int</span> index = leftSumEqualsRightSum(arr);</span><br><span class="line">	<span class="keyword">if</span>(index!=-<span class="number">1</span>) &#123;</span><br><span class="line">		System.out.println(arr[index]);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;没有&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">leftSumEqualsRightSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">0</span>; mid &lt; arr.length; mid++) &#123;</span><br><span class="line">		<span class="keyword">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> rightSum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;mid; i++) &#123;</span><br><span class="line">			leftSum += arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = mid+<span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			rightSum += arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(leftSum==rightSum) &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h4><ul>
<li><p>左奇右偶</p>
<ul>
<li> 10个整数的数组{26,67,49,38,52,66,7,71,56,87}。</li>
<li> 元素重新排列，所有的奇数保存到数组左边，所有的偶数保存到数组右边。</li>
</ul>
</li>
<li><p>代码实现，效果如图所示：</p>
<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172000.jpg"></p>
</li>
<li><p>开发提示：</p>
<ul>
<li>左边的偶数与右边的奇数换位置：</li>
<li>定义两个变量left和right，从左边开始查找偶数的位置，找到后用left记录，从右边开始找奇数的位置，找到后用right记录，如果left&lt;right，那么就交换，然后在上一次的基础上继续查找，直到left与right擦肩。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//效率最高</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>,right = arr.length-<span class="number">1</span>; left &lt; right; )&#123;</span><br><span class="line">        <span class="comment">//left代表左边需要交换的数的下标，偶数的下标</span></span><br><span class="line">        <span class="comment">//如果arr[left]此时是奇数，说明此时left不是我们要找的下标，left++往后移动</span></span><br><span class="line">        <span class="keyword">while</span>(arr[left]%<span class="number">2</span>!=<span class="number">0</span>)&#123;<span class="comment">//当arr[left]是偶数时，结束while循环</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果arr[right]此时是偶数，说明此时right不是我们要找的下标，right--往前移动</span></span><br><span class="line">        <span class="keyword">while</span>(arr[right]%<span class="number">2</span>==<span class="number">0</span>)&#123;<span class="comment">//当arr[right]是奇数时，结束while循环</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right]= temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order3</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">while</span> (len&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//左边的元素是偶数，就和它相邻的元素交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j]%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//从左边往右边找偶数，记录下标，evenIndex，这个是错误的数字的下标</span></span><br><span class="line">        <span class="comment">//从右边往左边找奇数，记录下标，oddIndex，这个是错误的数字的下标</span></span><br><span class="line">        <span class="comment">//交换arr[oddIndex]与arr[evenIndex]，调整之后就可以了</span></span><br><span class="line">        <span class="keyword">int</span> evenIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oddIndex = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(evenIndex &lt; oddIndex)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    evenIndex = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                    oddIndex = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(evenIndex &lt; oddIndex) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[evenIndex];</span><br><span class="line">                arr[evenIndex] = arr[oddIndex];</span><br><span class="line">                arr[oddIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="编程题3"><a href="#编程题3" class="headerlink" title="编程题3"></a>编程题3</h4><ul>
<li><p>数组去重</p>
<ul>
<li>10个整数{9,10,6,6,1,9,3,5,6,4}，范围1-10，保存到数组中。</li>
<li>去除数组中重复的内容，只保留唯一的元素。</li>
</ul>
</li>
<li><p>按步骤编写代码，效果如图所示：</p>
<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172007.jpg"></p>
</li>
<li><p>开发提示：</p>
<ul>
<li>定义一个变量count，初始化为数组的长度</li>
<li>遍历每一个元素，如果该元素与前面的某个元素相等，那么通过移动数组，把该元素覆盖掉，并修改count–。</li>
<li>最后创建一个新数组，长度为count，并从原数组把前count个元素复制过来</li>
</ul>
</li>
</ul>
<h4 id="编程题4"><a href="#编程题4" class="headerlink" title="编程题4"></a>编程题4</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172011.png" alt="1573715386032"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExer4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">double</span>[] arr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			arr[i] = Math.random() * <span class="number">100</span>;<span class="comment">//[0,100)之间的小数</span></span><br><span class="line">		&#125;</span><br><span class="line">		arr[arr.length-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;直线上每一个点距离下一个点的距离：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">double</span> length = <span class="number">150.5</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			sum += arr[i];</span><br><span class="line">			<span class="keyword">if</span>(sum&lt;=length) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;长度为：&quot;</span> + length + <span class="string">&quot;的绳子最多能覆盖&quot;</span> +count+<span class="string">&quot;个点&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编程题5"><a href="#编程题5" class="headerlink" title="编程题5"></a>编程题5</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172019.png" alt="1573715429966"></p>
<p>冒泡排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-i; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">					arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>直接选择排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> minIndex = i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">					minIndex = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(minIndex!=i) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[minIndex];</span><br><span class="line">				arr[minIndex] = arr[i];</span><br><span class="line">				arr[i] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><h4 id="1、折半插入排序"><a href="#1、折半插入排序" class="headerlink" title="1、折半插入排序"></a>1、折半插入排序</h4><p>例如：数组{12,2,6,1,5}</p>
<p>第一次：在[0,1)之间找插入2的位置==&gt;left = [0] ==&gt; {2,12,6,1,5}</p>
<p>第二次：在[0,2)之间找插入6的位置==&gt;left = [1] ==&gt; {2,6,12,1,5}</p>
<p>第三次：在[0,3)之间找插入1的位置==&gt;left = [0] ==&gt;{1,2,6,12,5}</p>
<p>第四次：在[0,4)之间找插入5的位置==&gt;left = [2] ==&gt;{1,2,5,6,12}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">12</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    sort(arr);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="comment">//找到[0,i)之间插入arr[i]的位置</span></span><br><span class="line">        <span class="comment">//使用二分查找法</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;=arr[mid])&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//在[0,i)插入arr[i]</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            System.arraycopy(arr,left,arr,left+<span class="number">1</span>,i-left);</span><br><span class="line">            arr[left] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172032.png"></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>例如：数组{5, 2, 6, 12, 1,7,9}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    sort(arr,<span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将[start+1,end]之间的元素分为两拨，左边的所有元素比arr[start]小，右边的所有元素比arr[start]大</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = start+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="comment">//从左往右，从[start+1]开始找比arr[start]大的数arr[left]，让它与arr[right]交换</span></span><br><span class="line">            <span class="comment">//当arr[left]大于arr[start]就停止循环，因为此时找到了比arr[start]大的数arr[left]</span></span><br><span class="line">            <span class="keyword">while</span>(arr[left]&lt;=arr[start] &amp;&amp; left&lt;=end)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//从右往左，从[end]开始找比比arr[start]小的数arr[right]，让它与arr[left]交换</span></span><br><span class="line">           <span class="comment">//当arr[right]小于arr[start]就停止循环，因为此时找到了比arr[start]小的数arr[right]</span></span><br><span class="line">            <span class="keyword">while</span>(arr[right]&gt;=arr[start] &amp;&amp; right&gt;start)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[left];</span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                arr[right] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//经过上面的while，//如果right&gt;start+1，那么说明在[start+1,end]之间的数分为两拨</span></span><br><span class="line">        <span class="comment">//[start+1,right]之间的是比arr[start]小的数</span></span><br><span class="line">        <span class="comment">//[right,end]之间的是比arr[start]大的数</span></span><br><span class="line">        <span class="comment">//交换arr[start]与arr[right]</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; start + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[start];</span><br><span class="line">            arr[start] = arr[right];</span><br><span class="line">            arr[right] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时[start,right-1]之间都是比arr[start]小的数据了，但是它们还未排序</span></span><br><span class="line">        <span class="comment">//此时[right+1,end]之间都是比arr[start]大的数据了，但是它们还未排序</span></span><br><span class="line">        <span class="comment">//所以需要分别对[start,right-1]、[right+1,end]之间元素重复上面的操作继续排序</span></span><br><span class="line">        sort(arr,start,right-<span class="number">1</span>);</span><br><span class="line">        sort(arr,right+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第1次调用sort(arr,0,6)<br>交换arr[left=2]与arr[right=4]：[5, 2, 1, 12, 6, 7, 9]<br>交换基准位置的元素与分界位置的元素：arr[start=0]与arr[right=2]：[1, 2, 5, 12, 6, 7, 9]<br>第2次调用sort(arr,0,1)<br>第3次调用sort(arr,0,0)<br>第4次调用sort(arr,2,1)<br>第5次调用sort(arr,3,6)<br>交换基准位置的元素与分界位置的元素：arr[start=3]与arr[right=6]：[1, 2, 5, 9, 6, 7, 12]<br>第6次调用sort(arr,3,5)<br>交换基准位置的元素与分界位置的元素：arr[start=3]与arr[right=5]：[1, 2, 5, 7, 6, 9, 12]<br>第7次调用sort(arr,3,4)<br>第8次调用sort(arr,3,3)<br>第9次调用sort(arr,5,4)<br>第10次调用sort(arr,6,5)<br>第11次调用sort(arr,7,6)</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172043.png"></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><code>java.lang.String</code> 类代表字符串。Java程序中所有的字符串文字（例如<code>&quot;abc&quot;</code> ）都可以被看作是实现此类的实例。字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。</p>
<p><code>String</code> 类包括的方法可用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符全部转换为大写或小写。 </p>
<p>Java 语言提供对字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持（toString()方法）。</p>
<h3 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h3><p>1、字符串String类型本身是final声明的，意味着我们不能继承String。</p>
<p>2、字符串的对象也是不可变对象，意味着一旦进行修改，就会产生新对象</p>
<blockquote>
<p>我们修改了字符串后，如果想要获得新的内容，必须重新接受。</p>
<p>如果程序中涉及到大量的字符串的修改操作，那么此时的时空消耗比较高。可能需要考虑使用StringBuilder或StringBuffer的可变字符序列。</p>
</blockquote>
<p>3、String对象内部是用字符数组进行保存的</p>
<blockquote>
<p>JDK1.9之前有一个char[] value数组，JDK1.9之后byte[]数组</p>
</blockquote>
<p><code>&quot;abc&quot;</code> 等效于 <code>char[] data=&#123; &#39;a&#39; , &#39;b&#39; , &#39;c&#39; &#125;</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如： </span><br><span class="line">String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">相当于： </span><br><span class="line"><span class="keyword">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;     </span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br><span class="line"><span class="comment">// String底层是靠字符数组实现的。</span></span><br></pre></td></tr></table></figure>

<p>4、String类中这个char[] values数组也是final修饰的，意味着这个数组不可变，然后它是private修饰，外部不能直接操作它，String类型提供的所有的方法都是用新对象来表示修改后内容的，所以保证了String对象的不可变。</p>
<p>5、就因为字符串对象设计为不可变，那么所以字符串有常量池来保存很多常量对象</p>
<p>常量池在方法区。</p>
<p>如果细致的划分：</p>
<p>（1）JDK1.6及其之前：方法区</p>
<p>（2）JDK1.7：堆</p>
<p>（3）JDK1.8：元空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"><span class="comment">// 内存中只有一个&quot;abc&quot;对象被创建，同时被s1和s2共享。</span></span><br></pre></td></tr></table></figure>

<h3 id="构造字符串对象"><a href="#构造字符串对象" class="headerlink" title="构造字符串对象"></a>构造字符串对象</h3><h4 id="使用构造方法"><a href="#使用构造方法" class="headerlink" title="使用构造方法"></a>使用构造方法</h4><ul>
<li><code>public String() </code> ：初始化新创建的 String对象，以使其表示空字符序列。</li>
<li><code> String(String original)</code>： 初始化一个新创建的 <code>String</code> 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。</li>
<li><code>public String(char[] value) </code> ：通过当前参数中的字符数组来构造新的String。</li>
<li><code>public String(char[] value,int offset, int count) </code> ：通过字符数组的一部分来构造新的String。</li>
<li><code>public String(byte[] bytes) </code> ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。</li>
<li><code>public String(byte[] bytes,String charsetName) </code> ：通过使用指定的字符集解码当前参数中的字节数组来构造新的String。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串常量对象</span></span><br><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String（）；</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建&quot;hello&quot;字符串常量的副本</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过字符数组构造</span></span><br><span class="line"><span class="keyword">char</span> chars[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;     </span><br><span class="line">String str3 = <span class="keyword">new</span> String(chars);</span><br><span class="line">String str4 = <span class="keyword">new</span> String(chars,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字节数组构造</span></span><br><span class="line"><span class="keyword">byte</span> bytes[] = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span> &#125;;     </span><br><span class="line">String str5 = <span class="keyword">new</span> String(bytes);</span><br><span class="line">String str6 = <span class="keyword">new</span> String(bytes,<span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="使用静态方法"><a href="#使用静态方法" class="headerlink" title="使用静态方法"></a>使用静态方法</h4><ul>
<li>static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String</li>
<li>static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String</li>
<li>static String valueOf(char[] data)  ： 返回指定数组中表示该字符序列的 String</li>
<li>static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String</li>
<li>static String valueOf(xx  value)：xx支持各种数据类型，返回各种数据类型的value参数的字符串表示形式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span>[] data = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">	String s1 = String.copyValueOf(data);</span><br><span class="line">	String s2 = String.copyValueOf(data,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">123456</span>;</span><br><span class="line">	String s3 = String.valueOf(num);</span><br><span class="line">	System.out.println(s1);</span><br><span class="line">	System.out.println(s2);</span><br><span class="line">	System.out.println(s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用””"><a href="#使用””" class="headerlink" title="使用””+"></a>使用””+</h4><p>任意数据类型与”字符串”进行拼接，结果都是字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">123456</span>;</span><br><span class="line">	String s = num + <span class="string">&quot;&quot;</span>;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">	</span><br><span class="line">	Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">	String s2 = stu + <span class="string">&quot;&quot;</span>;<span class="comment">//自动调用对象的toString()，然后与&quot;&quot;进行拼接</span></span><br><span class="line">	System.out.println(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串的对象的个数"><a href="#字符串的对象的个数" class="headerlink" title="字符串的对象的个数"></a>字符串的对象的个数</h3><p>1、字符串常量对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>;<span class="comment">//1个，在常量池中</span></span><br></pre></td></tr></table></figure>

<p>2、字符串的普通对象和常量对象一起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//str3首先指向堆中的一个字符串对象，然后堆中字符串的value数组指向常量池中常量对象的value数组</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串对象的内存分析"><a href="#字符串对象的内存分析" class="headerlink" title="字符串对象的内存分析"></a>字符串对象的内存分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s;</span><br><span class="line"></span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">String s = <span class="keyword">new</span> String();</span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] arr = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">String s = <span class="keyword">new</span> String(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] arr = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">String s = <span class="keyword">new</span> String(arr,<span class="number">0</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172123.png" alt="1562945799274"></p>
<h3 id="字符串拼接问题"><a href="#字符串拼接问题" class="headerlink" title="字符串拼接问题"></a>字符串拼接问题</h3><h4 id="拼接结果的存储和比较问题"><a href="#拼接结果的存储和比较问题" class="headerlink" title="拼接结果的存储和比较问题"></a>拼接结果的存储和比较问题</h4><p>原则：</p>
<p>（1）常量+常量：结果是常量池</p>
<p>（2）常量与变量 或 变量与变量：结果是堆</p>
<p>（3）拼接后调用intern方法：结果在常量池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	String s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">	String s3 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	String s4 = (s1 + <span class="string">&quot;world&quot;</span>).intern();<span class="comment">//把拼接的结果放到常量池中</span></span><br><span class="line">	String s5 = (s1 + s2).intern();</span><br><span class="line">	</span><br><span class="line">	System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">	System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">final</span> String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="keyword">final</span> String s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">	String s3 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	String s4 = s1 + <span class="string">&quot;world&quot;</span>;<span class="comment">//s4字符串内容也helloworld，s1是常量，&quot;world&quot;常量，常量+ 常量 结果在常量池中</span></span><br><span class="line">	String s5 = s1 + s2;<span class="comment">//s5字符串内容也helloworld，s1和s2都是常量，常量+ 常量 结果在常量池中</span></span><br><span class="line">	String s6 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;<span class="comment">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span></span><br><span class="line">	</span><br><span class="line">	System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">	System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">	System.out.println(s3 == s6);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	String s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">	String s3 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	String s4 = s1 + <span class="string">&quot;world&quot;</span>;<span class="comment">//s4字符串内容也helloworld，s1是变量，&quot;world&quot;常量，变量 + 常量的结果在堆中</span></span><br><span class="line">	String s5 = s1 + s2;<span class="comment">//s5字符串内容也helloworld，s1和s2都是变量，变量 + 变量的结果在堆中</span></span><br><span class="line">	String s6 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;<span class="comment">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span></span><br><span class="line">	</span><br><span class="line">	System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">	System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">	System.out.println(s3 == s6);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172137.png" alt="1562946547647"></p>
<p><img src="H:/00%25E3%2580%2581%25E5%25B0%259A%25E7%25A1%2585%25E8%25B0%25B7%25E5%25A4%25A7%25E8%25AF%25BE/2021%25E5%25B9%25B4%25E5%25B0%259A%25E7%25A1%2585%25E8%25B0%25B7Java%25E5%2590%258E%25E7%25AB%25AF%25E9%259D%25A2%25E6%258E%2588%25E7%258F%25AD%25E3%2580%25902021%25E5%25B9%25B45%25E6%259C%2588%25E7%25BB%2593%25E8%25AF%25BE%25E3%2580%2591/%25E8%25AF%25BE%25E4%25BB%25B6/%25E8%25AF%25BE%25E4%25BB%25B6/1.JAVA%25E6%25A0%25B8%25E5%25BF%2583%25E5%259F%25BA%25E7%25A1%2580/1.JAVA%25E6%25A0%25B8%25E5%25BF%2583%25E5%259F%25BA%25E7%25A1%2580%25E3%2580%2590%25E6%25B5%25B7%25E9%2587%258Fit%25E8%25B5%2584%25E6%25BA%2590%25EF%25BC%259A666java.com%25E3%2580%2591/%25E8%25AF%25BE%25E4%25BB%25B6/%25E7%25AC%25AC10%25E7%25AB%25A0%2520%25E5%259F%25BA%25E7%25A1%2580API%25E4%25B8%258E%25E5%25B8%25B8%25E8%25A7%2581%25E7%25AE%2597%25E6%25B3%2595/imgs/1562946558630.png" alt="1562946558630"></p>
<h4 id="拼接效率问题"><a href="#拼接效率问题" class="headerlink" title="拼接效率问题"></a>拼接效率问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">			str += i;  </span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172143.png" alt="1562946595771"></p>
<p>不过现在的JDK版本，都会使用可变字符序列对如上代码进行优化，我们反编译查看字节码：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">javap -c TestString.class</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172146.png" alt="1563106868437"></p>
<h4 id="两种拼接"><a href="#两种拼接" class="headerlink" title="两种拼接"></a>两种拼接</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">		String str2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">		String str3 =<span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		String str4 = <span class="string">&quot;hello&quot;</span>.concat(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		String str5 = <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">		System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>concat方法拼接，哪怕是两个常量对象拼接，结果也是在堆。</p>
</blockquote>
<h3 id="字符串对象的比较"><a href="#字符串对象的比较" class="headerlink" title="字符串对象的比较"></a>字符串对象的比较</h3><p>1、==：比较是对象的地址</p>
<blockquote>
<p>只有两个字符串变量都是指向字符串的常量对象时，才会返回true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1 == str4); <span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>2、equals：比较是对象的内容，因为String类型重写equals，区分大小写</p>
<p>只要两个字符串的字符内容相同，就会返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str3));<span class="comment">//true</span></span><br><span class="line">System.out.println(str3.equals(str4));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>3、equalsIgnoreCase：比较的是对象的内容，不区分大小写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line">System.out.println(str1.equalsIgnoreCase(strs)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>4、compareTo：String类型重写了Comparable接口的抽象方法，自然排序，按照字符的Unicode编码值进行比较大小的，严格区分大小写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">str1.compareTo(str2) <span class="comment">//小于0的值</span></span><br></pre></td></tr></table></figure>

<p>5、compareToIgnoreCase：不区分大小写，其他按照字符的Unicode编码值进行比较大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line">str1.compareToIgnoreCase(str2)  <span class="comment">//等于0</span></span><br></pre></td></tr></table></figure>

<h3 id="空字符的比较"><a href="#空字符的比较" class="headerlink" title="空字符的比较"></a>空字符的比较</h3><p>1、哪些是空字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String();</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>空字符串：长度为0</p>
<p>2、如何判断某个字符串是否是空字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(str))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span>  &amp;&amp; str.isEmpty())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span> &amp;&amp; str.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span> &amp;&amp; str.length()==<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="字符串的常用方法"><a href="#字符串的常用方法" class="headerlink" title="字符串的常用方法"></a>字符串的常用方法</h3><h4 id="系列1"><a href="#系列1" class="headerlink" title="系列1"></a>系列1</h4><p>（1）boolean isEmpty()：字符串是否为空</p>
<p>（2）int length()：返回字符串的长度</p>
<p>（3）String concat(xx)：拼接，等价于+</p>
<p>（4）boolean equals(Object obj)：比较字符串是否相等，区分大小写</p>
<p>（5）boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，区分大小写</p>
<p>（6）int compareTo(String other)：比较字符串大小，区分大小写，按照Unicode编码值比较大小</p>
<p>（7）int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写</p>
<p>（8）String toLowerCase()：将字符串中大写字母转为小写</p>
<p>（9）String toUpperCase()：将字符串中小写字母转为大写</p>
<p>（10）String trim()：去掉字符串前后空白符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//将用户输入的单词全部转为小写，如果用户没有输入单词，重新输入</span></span><br><span class="line">	Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	String word;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;请输入单词：&quot;</span>);</span><br><span class="line">		word = input.nextLine();</span><br><span class="line">		<span class="keyword">if</span>(word.trim().length()!=<span class="number">0</span>)&#123;</span><br><span class="line">			word = word.toLowerCase();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//随机生成验证码，验证码由0-9，A-Z,a-z的字符组成</span></span><br><span class="line">	<span class="keyword">char</span>[] array = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>*<span class="number">2</span>+<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		array[i] = (<span class="keyword">char</span>)(<span class="string">&#x27;0&#x27;</span> + i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>,j=<span class="number">0</span>; i &lt; <span class="number">10</span>+<span class="number">26</span>; i++,j++) &#123;</span><br><span class="line">		array[i] = (<span class="keyword">char</span>)(<span class="string">&#x27;A&#x27;</span> + j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>+<span class="number">26</span>,j=<span class="number">0</span>; i &lt; array.length; i++,j++) &#123;</span><br><span class="line">		array[i] = (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + j);</span><br><span class="line">	&#125;</span><br><span class="line">	String code = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		code += array[rand.nextInt(array.length)];</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;验证码：&quot;</span> + code);</span><br><span class="line">	<span class="comment">//将用户输入的单词全部转为小写，如果用户没有输入单词，重新输入</span></span><br><span class="line">	Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	System.out.print(<span class="string">&quot;请输入验证码：&quot;</span>);</span><br><span class="line">	String inputCode = input.nextLine();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!code.equalsIgnoreCase(inputCode))&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;验证码输入不正确&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="系列2：查找"><a href="#系列2：查找" class="headerlink" title="系列2：查找"></a>系列2：查找</h4><p>（11）boolean contains(xx)：是否包含xx</p>
<p>（12）int indexOf(xx)：从前往后找当前字符串中xx，即如果有返回第一次出现的下标，要是没有返回-1</p>
<p>（13）int lastIndexOf(xx)：从后往前找当前字符串中xx，即如果有返回最后一次出现的下标，要是没有返回-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String str = <span class="string">&quot;尚硅谷是一家靠谱的培训机构，尚硅谷可以说是IT培训的小清华，JavaEE是尚硅谷的当家学科，尚硅谷的大数据培训是行业独角兽。尚硅谷的前端和运维专业一样独领风骚。&quot;</span>;</span><br><span class="line">	System.out.println(<span class="string">&quot;是否包含清华：&quot;</span> + str.contains(<span class="string">&quot;清华&quot;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;培训出现的第一次下标：&quot;</span> + str.indexOf(<span class="string">&quot;培训&quot;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;培训出现的最后一次下标：&quot;</span> + str.lastIndexOf(<span class="string">&quot;培训&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="系列3：字符串截取"><a href="#系列3：字符串截取" class="headerlink" title="系列3：字符串截取"></a>系列3：字符串截取</h4><p>（14）String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。 </p>
<p>（15）String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String str = <span class="string">&quot;helloworldjavaatguigu&quot;</span>;</span><br><span class="line">	String sub1 = str.substring(<span class="number">5</span>);</span><br><span class="line">	String sub2 = str.substring(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">	System.out.println(sub1);</span><br><span class="line">	System.out.println(sub2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String fileName = <span class="string">&quot;快速学习Java的秘诀.dat&quot;</span>;</span><br><span class="line">	<span class="comment">//截取文件名</span></span><br><span class="line">	System.out.println(<span class="string">&quot;文件名：&quot;</span> + fileName.substring(<span class="number">0</span>,fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>)));</span><br><span class="line">	<span class="comment">//截取后缀名</span></span><br><span class="line">	System.out.println(<span class="string">&quot;后缀名：&quot;</span> + fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="系列4：和字符相关"><a href="#系列4：和字符相关" class="headerlink" title="系列4：和字符相关"></a>系列4：和字符相关</h4><p>（16）char charAt(index)：返回[index]位置的字符</p>
<p>（17）char[] toCharArray()： 将此字符串转换为一个新的字符数组返回</p>
<p>（18）String(char[] value)：返回指定数组中表示该字符序列的 String。 </p>
<p>（19）String(char[] value, int offset, int count)：返回指定数组中表示该字符序列的 String。</p>
<p>（20）static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String</p>
<p>（21）static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String</p>
<p>（22）static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String</p>
<p>（23）static String valueOf(char[] data)  ：返回指定数组中表示该字符序列的 String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//将字符串中的字符按照大小顺序排列</span></span><br><span class="line">	String str = <span class="string">&quot;helloworldjavaatguigu&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span>[] array = str.toCharArray();</span><br><span class="line">	Arrays.sort(array);</span><br><span class="line">	str = <span class="keyword">new</span> String(array);</span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//将首字母转为大写</span></span><br><span class="line">	String str = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">	str = Character.toUpperCase(str.charAt(<span class="number">0</span>))+str.substring(<span class="number">1</span>);</span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="系列5：编码与解码"><a href="#系列5：编码与解码" class="headerlink" title="系列5：编码与解码"></a>系列5：编码与解码</h4><p>（24）byte[] getBytes()：编码，把字符串变为字节数组，按照平台默认的字符编码进行编码</p>
<p>​    byte[] getBytes(字符编码方式)：按照指定的编码方式进行编码</p>
<p>（25）new String(byte[] ) 或 new String(byte[], int, int)：解码，按照平台默认的字符编码进行解码</p>
<p>​           new String(byte[]，字符编码方式 ) 或 new String(byte[], int, int，字符编码方式)：解码，按照指定的编码方式进行解码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * GBK，UTF-8，ISO8859-1所有的字符编码都向下兼容ASCII码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	String str = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">	System.out.println(str.getBytes(<span class="string">&quot;ISO8859-1&quot;</span>).length);<span class="comment">// 2</span></span><br><span class="line">	<span class="comment">// ISO8859-1把所有的字符都当做一个byte处理，处理不了多个字节</span></span><br><span class="line">	System.out.println(str.getBytes(<span class="string">&quot;GBK&quot;</span>).length);<span class="comment">// 4 每一个中文都是对应2个字节</span></span><br><span class="line">	System.out.println(str.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);<span class="comment">// 6 常规的中文都是3个字节</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 不乱码：（1）保证编码与解码的字符集名称一样（2）不缺字节</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	System.out.println(<span class="keyword">new</span> String(str.getBytes(<span class="string">&quot;ISO8859-1&quot;</span>), <span class="string">&quot;ISO8859-1&quot;</span>));<span class="comment">// 乱码</span></span><br><span class="line">	System.out.println(<span class="keyword">new</span> String(str.getBytes(<span class="string">&quot;GBK&quot;</span>), <span class="string">&quot;GBK&quot;</span>));<span class="comment">// 中国</span></span><br><span class="line">	System.out.println(<span class="keyword">new</span> String(str.getBytes(<span class="string">&quot;UTF-8&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>));<span class="comment">// 中国</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="字符编码发展"><a href="#字符编码发展" class="headerlink" title="字符编码发展"></a>字符编码发展</h5><h5 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a><strong>ASCII码</strong></h5><p>计算机一开始发明的时候是用来解决数字计算的问题，后来人们发现，计算机还可以做更多的事，例如文本处理。但由于计算机只识“数”，因此人们必须告诉计算机哪个数字来代表哪个特定字符，例如65代表字母‘A’，66代表字母‘B’，以此类推。但是计算机之间字符-数字的对应关系必须得一致，否则就会造成同一段数字在不同计算机上显示出来的字符不一样。因此美国国家标准协会ANSI制定了一个标准，规定了常用字符的集合以及每个字符对应的编号，这就是ASCII字符集（Character Set），也称ASCII码。</p>
<p>那时候的字符编解码系统非常简单，就是简单的查表过程。其中：</p>
<ul>
<li>0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)</li>
<li>32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字。</li>
<li>65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。</li>
</ul>
<h5 id="OEM字符集的衍生"><a href="#OEM字符集的衍生" class="headerlink" title="OEM字符集的衍生"></a><strong>OEM字符集的衍生</strong></h5><p>当计算机开始发展起来的时候，人们逐渐发现，ASCII字符集里那可怜的128个字符已经不能再满足他们的需求了。人们就在想，一个字节能够表示的数字（编号）有256个，而ASCII字符只用到了0x00~0x7F，也就是占用了前128个，后面128个数字不用白不用，因此很多人打起了后面这128个数字的主意。可是问题在于，很多人同时有这样的想法，但是大家对于0x80-0xFF这后面的128个数字分别对应什么样的字符，却有各自的想法。这就导致了当时销往世界各地的机器上出现了大量各式各样的OEM字符集。不同的OEM字符集导致人们无法跨机器交流各种文档。例如职员甲发了一封简历résumés给职员乙，结果职员乙看到的却是r?sum?s，因为é字符在职员甲机器上的OEM字符集中对应的字节是0x82，而在职员乙的机器上，由于使用的OEM字符集不同，对0x82字节解码后得到的字符却是?。</p>
<h5 id="多字节字符集（MBCS）和中文字符集"><a href="#多字节字符集（MBCS）和中文字符集" class="headerlink" title="多字节字符集（MBCS）和中文字符集"></a><strong>多字节字符集（MBCS）和中文字符集</strong></h5><p>上面我们提到的字符集都是基于单字节编码，也就是说，一个字节翻译成一个字符。这对于拉丁语系国家来说可能没有什么问题，因为他们通过扩展第8个比特，就可以得到256个字符了，足够用了。但是对于亚洲国家来说，256个字符是远远不够用的。因此这些国家的人为了用上电脑，又要保持和ASCII字符集的兼容，就发明了多字节编码方式，相应的字符集就称为多字节字符集（Muilti-Bytes Charecter Set）。例如中国使用的就是双字节字符集编码。</p>
<p>例如目前最常用的中文字符集GB2312，涵盖了所有简体字符以及一部分其他字符；GBK（K代表扩展的意思）则在GB2312的基础上加入了对繁体字符等其他非简体字符。这两个字符集的字符都是使用1-2个字节来表示。Windows系统采用936代码页来实现对GBK字符集的编解码。在解析字节流的时候，如果遇到字节的最高位是0的话，那么就使用936代码页中的第1张码表进行解码，这就和单字节字符集的编解码方式一致了。如果遇到字节的最高位是1的话，那么就表示需要两个字节值才能对应一个字符。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172226.png" alt="1563199557136"></p>
<h5 id="ANSI标准、国家标准、ISO标准"><a href="#ANSI标准、国家标准、ISO标准" class="headerlink" title="ANSI标准、国家标准、ISO标准"></a><strong>ANSI标准、国家标准、ISO标准</strong></h5><p>不同ASCII衍生字符集的出现，让文档交流变得非常困难，因此各种组织都陆续进行了标准化流程。例如美国ANSI组织制定了ANSI标准字符编码（注意，我们现在通常说到ANSI编码，通常指的是平台的默认编码，例如英文操作系统中是ISO-8859-1，中文系统是GBK），ISO组织制定的各种ISO标准字符编码，还有各国也会制定一些国家标准字符集，例如中国的GBK，GB2312和GB18030。</p>
<p>操作系统在发布的时候，通常会往机器里预装这些标准的字符集还有平台专用的字符集，这样只要你的文档是使用标准字符集编写的，通用性就比较高了。例如你用GB2312字符集编写的文档，在中国大陆内的任何机器上都能正确显示。同时，我们也可以在一台机器上阅读多个国家不同语言的文档了，前提是本机必须安装该文档使用的字符集。</p>
<h5 id="Unicode的出现"><a href="#Unicode的出现" class="headerlink" title="Unicode的出现"></a><strong>Unicode的出现</strong></h5><p>虽然通过使用不同字符集，我们可以在一台机器上查阅不同语言的文档，但是我们仍然<strong>无法解决一个问题：如果一份文档中含有不同国家的不同语言的字符，那么无法在一份文档中显示所有字符</strong>。为了解决这个问题，我们需要一个全人类达成共识的巨大的字符集，这就是Unicode字符集。</p>
<p>Unicode字符集涵盖了目前人类使用的所有字符，并为每个字符进行统一编号，分配唯一的字符码（Code Point）。Unicode字符集将所有字符按照使用上的频繁度划分为17个层面（Plane），每个层面上有216=65536个字符码空间。其中第0个层面BMP，基本涵盖了当今世界用到的所有字符。其他的层面要么是用来表示一些远古时期的文字，要么是留作扩展。我们平常用到的Unicode字符，一般都是位于BMP层面上的。目前Unicode字符集中尚有大量字符空间未使用。</p>
<p>Unicode同样也不完美，这里就有三个的问题，一个是，我们已经知道，英文字母只用一个字节表示就够了，第二个问题是如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现，为解决Unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。UTF-8就是在互联网上使用最广的一种Unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</p>
<p>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换（<strong>即Uncidoe字符集≠UTF-8编码方式</strong>）。</p>
<p>并不是直接的对应，而是要过一些算法和规则来转换（<strong>即Uncidoe字符集≠UTF-8编码方式</strong>）。</p>
<p>Unicode符号范围         | UTF-8编码方式</p>
<p>(十六进制)                      |        （二进制）</p>
<p>—————————————————————–</p>
<p>0000 0000-0000 007F | 0xxxxxxx（兼容原来的ASCII）</p>
<p>0000 0080-0000 07FF | 110xxxxx 10xxxxxx</p>
<p>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</p>
<p>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172231.png" alt="1563199860263"></p>
<p>因此，Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-16和UTF-8。</p>
<p>早期字符编码、字符集和代码页等概念都是表达同一个意思。例如GB2312字符集、GB2312编码，936代码页，实际上说的是同个东西。</p>
<p>但是对于Unicode则不同，Unicode字符集只是定义了字符的集合和唯一编号，Unicode编码，则是对UTF-8、UCS-2/UTF-16等具体编码方案的统称而已，并不是具体的编码方案。所以当需要用到字符编码的时候，你可以写gb2312，codepage936，utf-8，utf-16，但请不要写Unicode。</p>
<h4 id="系列6：开头与结尾"><a href="#系列6：开头与结尾" class="headerlink" title="系列6：开头与结尾"></a>系列6：开头与结尾</h4><p>（26）boolean startsWith(xx)：是否以xx开头</p>
<p>（27）boolean endsWith(xx)：是否以xx结尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	System.out.println(name.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String file = <span class="string">&quot;Hello.txt&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(file.endsWith(<span class="string">&quot;.java&quot;</span>))&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Java源文件&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(file.endsWith(<span class="string">&quot;.class&quot;</span>))&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Java字节码文件&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;其他文件&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="系列7：替换"><a href="#系列7：替换" class="headerlink" title="系列7：替换"></a>系列7：替换</h4><p>（29）String replace(xx,xx)：不支持正则</p>
<p>（30）String replaceFirst(正则，value)：替换第一个匹配部分</p>
<p>（31）String repalceAll(正则， value)：替换所有匹配部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String str = <span class="string">&quot;hello244world.java;887&quot;</span>;</span><br><span class="line">	<span class="comment">//把其中的非字母去掉</span></span><br><span class="line">	str = str.replaceAll(<span class="string">&quot;[^a-zA-Z]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="系列8：拆分"><a href="#系列8：拆分" class="headerlink" title="系列8：拆分"></a>系列8：拆分</h4><p>（32）String[] split(正则)：按照某种规则进行拆分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String str = <span class="string">&quot;张三.23|李四.24|王五.25&quot;</span>;</span><br><span class="line">	<span class="comment">//|在正则中是有特殊意义，我这里要把它当做普通的|</span></span><br><span class="line">	String[] all = str.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//转成一个一个学生对象</span></span><br><span class="line">	Student[] students = <span class="keyword">new</span> Student[all.length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">		<span class="comment">//.在正则中是特殊意义，我这里想要表示普通的.</span></span><br><span class="line">		String[] strings = all[i].split(<span class="string">&quot;\\.&quot;</span>);<span class="comment">//张三,  23</span></span><br><span class="line">		String name = strings[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> age = Integer.parseInt(strings[<span class="number">1</span>]);</span><br><span class="line">		students[i] = <span class="keyword">new</span> Student(name,age);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">		System.out.println(students[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String str = <span class="string">&quot;1Hello2World3java4atguigu5&quot;</span>;</span><br><span class="line">	str = str.replaceAll(<span class="string">&quot;^\\d|\\d$&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	String[] all = str.split(<span class="string">&quot;\\d&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all.length; i++) &#123;</span><br><span class="line">		System.out.println(all[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String str = <span class="string">&quot;1Hello2World3java4atguigu&quot;</span>;</span><br><span class="line">	str = str.replaceFirst(<span class="string">&quot;\\d&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	System.out.println(str);</span><br><span class="line">	String[] all = str.split(<span class="string">&quot;\\d&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all.length; i++) &#123;</span><br><span class="line">		System.out.println(all[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String str = <span class="string">&quot;Hello World java atguigu&quot;</span>;</span><br><span class="line">	String[] all = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all.length; i++) &#123;</span><br><span class="line">		System.out.println(all[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可变字符序列"><a href="#可变字符序列" class="headerlink" title="可变字符序列"></a>可变字符序列</h2><h3 id="String与可变字符序列的区别"><a href="#String与可变字符序列的区别" class="headerlink" title="String与可变字符序列的区别"></a>String与可变字符序列的区别</h3><p>因为String对象是不可变对象，虽然可以共享常量对象，但是对于频繁字符串的修改和拼接操作，效率极低。因此，JDK又在java.lang包提供了可变字符序列StringBuilder和StringBuffer类型。</p>
<p>StringBuffer：老的，线程安全的（因为它的方法有synchronized修饰）</p>
<p>StringBuilder：线程不安全的</p>
<h3 id="StringBuilder、StringBuffer的API"><a href="#StringBuilder、StringBuffer的API" class="headerlink" title="StringBuilder、StringBuffer的API"></a>StringBuilder、StringBuffer的API</h3><p>常用的API，StringBuilder、StringBuffer的API是完全一致的</p>
<p>（1）StringBuffer append(xx)：拼接，追加</p>
<p>（2）StringBuffer insert(int index, xx)：在[index]位置插入xx</p>
<p>（3）StringBuffer delete(int start, int end)：删除[start,end)之间字符</p>
<pre><code>StringBuffer deleteCharAt(int index)：删除[index]位置字符
</code></pre>
<p>（4）void setCharAt(int index, xx)：替换[index]位置字符</p>
<p>（5）StringBuffer reverse()：反转</p>
<p>（6）void setLength(int newLength) ：设置当前字符序列长度为newLength</p>
<p>（7）StringBuffer replace(int start, int end, String str)：替换[start,end)范围的字符序列为str</p>
<p>（8）int indexOf(String str)：在当前字符序列中查询str的第一次出现下标</p>
<p>​    int indexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的第一次出现下标</p>
<p>​    int lastIndexOf(String str)：在当前字符序列中查询str的最后一次出现下标</p>
<p>​    int lastIndexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的最后一次出现下标</p>
<p>（9）String substring(int start)：截取当前字符序列[start,最后]</p>
<p>（10）String substring(int start, int end)：截取当前字符序列[start,end)</p>
<p>（11）String toString()：返回此序列中数据的字符串表示形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">	StringBuilder s = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">	s.setLength(<span class="number">30</span>);</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">	StringBuilder s = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">	s.setCharAt(<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	StringBuilder s = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">	s.reverse();</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	StringBuilder s = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">	s.delete(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	s.deleteCharAt(<span class="number">4</span>);</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	StringBuilder s = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">	s.insert(<span class="number">5</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">	s.insert(<span class="number">5</span>, <span class="string">&quot;chailinyan&quot;</span>);</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	s.append(<span class="string">&quot;hello&quot;</span>).append(<span class="keyword">true</span>).append(<span class="string">&#x27;a&#x27;</span>).append(<span class="number">12</span>).append(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">	System.out.println(s);</span><br><span class="line">	System.out.println(s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Runtime：JVM运行时环境</span></span><br><span class="line"><span class="comment"> * Runtime是一个单例的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTime</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		testStringBuilder();</span></span><br><span class="line">		testStringBuffer();</span><br><span class="line"><span class="comment">//		testString();</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		String s = <span class="keyword">new</span> String(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">			s += i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;String拼接+用时：&quot;</span>+(end-start));<span class="comment">//444</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        System.out.println(<span class="string">&quot;String拼接+memory占用内存: &quot;</span> + memory);<span class="comment">//53185144字节</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStringBuilder</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		StringBuilder s = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">			s.append(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;StringBuilder拼接+用时：&quot;</span>+(end-start));<span class="comment">//4</span></span><br><span class="line">		<span class="keyword">long</span> memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuilder拼接+memory占用内存: &quot;</span> + memory);<span class="comment">//1950488</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStringBuffer</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">			s.append(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;StringBuffer拼接+用时：&quot;</span>+(end-start));<span class="comment">//7</span></span><br><span class="line">		<span class="keyword">long</span> memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuffer拼接+memory占用内存: &quot;</span> + memory);<span class="comment">//1950488</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串特点相关面试题"><a href="#字符串特点相关面试题" class="headerlink" title="字符串特点相关面试题"></a>字符串特点相关面试题</h2><h3 id="1、面试题：字符串的length和数组的length有什么不同？"><a href="#1、面试题：字符串的length和数组的length有什么不同？" class="headerlink" title="1、面试题：字符串的length和数组的length有什么不同？"></a>1、面试题：字符串的length和数组的length有什么不同？</h3><p>字符串的length()，数组的length属性</p>
<h3 id="字符串对象不可变"><a href="#字符串对象不可变" class="headerlink" title="字符串对象不可变"></a>字符串对象不可变</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TEXT</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">public</span> String str;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TEXT</span><span class="params">(<span class="keyword">int</span> num, String str)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.num = num;</span><br><span class="line">		<span class="keyword">this</span>.str = str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class4</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tIn是传对象的地址，修改形参的属性，会影响实参</span></span><br><span class="line">    <span class="comment">//intIn是传数据，基本数据类型的形参修改和实参无关</span></span><br><span class="line">    <span class="comment">//Integer和String对象不可变</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(TEXT tIn, <span class="keyword">int</span> intIn, Integer integerIn, String strIn)</span></span>&#123;</span><br><span class="line">		tIn.num =<span class="number">200</span>;</span><br><span class="line">		tIn.str = <span class="string">&quot;bcd&quot;</span>;<span class="comment">//形参和实参指向的是同一个TEXT的对象，修改了属性，就相当于修改实参对象的属性</span></span><br><span class="line">		intIn = <span class="number">200</span>;<span class="comment">//基本数据类型的形参是实参的“副本”，无论怎么修改和实参都没关系</span></span><br><span class="line">		integerIn = <span class="number">200</span>;<span class="comment">//Integer对象和String对象一样都是不可变，一旦修改都是新对象，和实参无关</span></span><br><span class="line">		strIn = <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TEXT tIn = <span class="keyword">new</span> TEXT(<span class="number">100</span>, <span class="string">&quot;abc&quot;</span>);<span class="comment">//tIn.num = 100, tIn.str=&quot;abc&quot;</span></span><br><span class="line">		<span class="keyword">int</span> intIn = <span class="number">100</span>;</span><br><span class="line">		Integer integerIn = <span class="number">100</span>;</span><br><span class="line">		String strIn = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		f1(tIn,intIn,integerIn,strIn);</span><br><span class="line">		</span><br><span class="line">		System.out.println(tIn.num + tIn.str + intIn + integerIn + strIn);</span><br><span class="line">		<span class="comment">//200 + bcd + 100 + 100 + abc</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171820.png" alt="1572834610162"></p>
<h3 id="字符串对象个数"><a href="#字符串对象个数" class="headerlink" title="字符串对象个数"></a>字符串对象个数</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171816.png" alt="1572834413234"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171813.png" alt="1572835014847"></p>
<h3 id="字符串对象比较"><a href="#字符串对象比较" class="headerlink" title="字符串对象比较"></a>字符串对象比较</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171801.png" alt="1572834430257"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171759.png" alt="1572834653725"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171756.png" alt="1572834908977"></p>
<h3 id="空字符串"><a href="#空字符串" class="headerlink" title="空字符串"></a>空字符串</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171752.png" alt="1572834804165"></p>
<h2 id="字符串算法相关面试题"><a href="#字符串算法相关面试题" class="headerlink" title="字符串算法相关面试题"></a>字符串算法相关面试题</h2><h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><p>在字符串中找出连续最长数字串，返回这个串的长度，并打印这个最长数字串。</p>
<p>例如：abcd12345cd125se123456789，返回9，打印出123456789</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171749.png" alt="1573715990196"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExer1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">&quot;abcd12345cd125se123456789&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//去掉最前和最后的字母</span></span><br><span class="line">		str =	str.replaceAll(<span class="string">&quot;^[a-zA-Z]+&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//[a-zA-Z]：表示字母范围</span></span><br><span class="line">		<span class="comment">//+：一次或多次</span></span><br><span class="line">		String[] strings = str.split(<span class="string">&quot;[a-zA-Z]+&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		String max = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">			<span class="keyword">if</span>(string.length() &gt; max.length()) &#123;</span><br><span class="line">				max = string;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;最长的数字串：&quot;</span> + max + <span class="string">&quot;，它的长度为：&quot;</span> + max.length());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编程题-1"><a href="#编程题-1" class="headerlink" title="编程题"></a>编程题</h3><p>不能使用trim()，实现去除字符串两端的空格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String str =<span class="string">&quot;    he   llo   &quot;</span>;</span><br><span class="line">	System.out.println(myTrim(str));</span><br><span class="line">	System.out.println(myTrim2(str));</span><br><span class="line">	System.out.println(myTrim3(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myTrim3</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">	<span class="comment">//利用正则表达式</span></span><br><span class="line">	<span class="comment">//^表示开头    \s表示  空白符   *表示0次或多次     |表示或者    $表示结尾</span></span><br><span class="line">	<span class="keyword">return</span> str.replaceAll(<span class="string">&quot;(^\\s*)|(\\s*$)&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myTrim2</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(str.startsWith(<span class="string">&quot; &quot;</span>))&#123;</span><br><span class="line">		str = str.replaceFirst(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(str.endsWith(<span class="string">&quot; &quot;</span>))&#123;</span><br><span class="line">		str = str.substring(<span class="number">0</span>, str.length()-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myTrim</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>[] array = str.toCharArray();</span><br><span class="line">	<span class="keyword">int</span> start =<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(array[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">			start++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> end = array.length-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=end;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(array[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	String result = str.substring(start,end+<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编程题-2"><a href="#编程题-2" class="headerlink" title="编程题"></a>编程题</h3><p>将字符串中指定部分进行反转。比如将“abcdefgho”反转为”abfedcgho”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String str =<span class="string">&quot;abcdefgho&quot;</span>;</span><br><span class="line">	System.out.println(str);</span><br><span class="line">	System.out.println(reverse(str,<span class="number">2</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从第start个字符，到第end个字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String str,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>[] array = str.toCharArray();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = start,j=end;i&lt; j;i++,j--)&#123;</span><br><span class="line">		<span class="keyword">char</span> temp =array[i];</span><br><span class="line">		array[i]=array[j];</span><br><span class="line">		array[j]=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	String s = <span class="keyword">new</span> String(array);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从第start个字符，到第end个字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String str,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       String left = str.substring(<span class="number">0</span>,start);</span><br><span class="line">	String middle = str.substring(start,end+<span class="number">1</span>);</span><br><span class="line">       String left = str.substring(end+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> left+<span class="keyword">new</span> StringBuilder(middle).reverse()+right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编程题-3"><a href="#编程题-3" class="headerlink" title="编程题"></a>编程题</h3><p>获取一个字符串在另一个字符串中出现的次数。</p>
<p>​     比如：获取”ab”在 “abababkkcadkabkebfkabkskab”中出现的次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String str1=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">	String str2=<span class="string">&quot;abababkkcadkabkebfkabkskab&quot;</span>;</span><br><span class="line">	System.out.println(count(str1,str2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = str2.indexOf(str1);</span><br><span class="line">		<span class="keyword">if</span>(index !=-<span class="number">1</span>)&#123;</span><br><span class="line">			count++;</span><br><span class="line">			str2 = str2.substring(index + str1.length());</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编程题-4"><a href="#编程题-4" class="headerlink" title="编程题"></a>编程题</h3><p>获取两个字符串中最大相同子串。</p>
<p>比如：str1 = “abcwerthelloyuiodef“;str2 = “cvhellobnm”</p>
<p>   提示：将短的那个串进行长度依次递减的子串与较长的串比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String str=findMaxSubString(<span class="string">&quot;abcwerthelloyuiodef&quot;</span>,<span class="string">&quot;cvhellobnm&quot;</span>);</span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提示：将短的那个串进行长度依次递减的子串与较长的串比较。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findMaxSubString</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">	String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	String mixStr = str1.length()&lt;str2.length()?str1:str2;</span><br><span class="line">	String maxStr = str1.length()&gt;str2.length()?str1:str2;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//外循环控制从左到右的下标，内循环控制从右到左的下标</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mixStr.length();i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=mixStr.length();j&gt;=i;j--)&#123;</span><br><span class="line">			String str=mixStr.substring(i, j);</span><br><span class="line">			<span class="keyword">if</span>(maxStr.contains(str))&#123;</span><br><span class="line">				<span class="comment">//找出最大相同子串</span></span><br><span class="line">				<span class="keyword">if</span>(result.length()&lt;str.length())&#123;</span><br><span class="line">					result = str;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编程题-5"><a href="#编程题-5" class="headerlink" title="编程题"></a>编程题</h3><p>编写代码完成如下功能</p>
<p>public static String replace(String text, String target, String replace){</p>
<p>….</p>
<p>}</p>
<p>示例：replace(“aabbccbb”, “bb”, “dd”);  结果：aaddccdd</p>
<p>注意：不能使用String及StringBuffer等类的replace等现成的替换API方法。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171729.png" alt="1573716569424"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(replace(<span class="string">&quot;aabbcbcbb&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;dd&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replace</span><span class="params">(String text, String target, String replace)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> index = text.indexOf(target);</span><br><span class="line">		<span class="keyword">if</span>(index!=-<span class="number">1</span>) &#123;</span><br><span class="line">			text = text.substring(<span class="number">0</span>,index) + replace + text.substring(index+target.length());</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编程题-6"><a href="#编程题-6" class="headerlink" title="编程题"></a>编程题</h3><p>1个字符串中可能包含a-z中的多个字符，字符也可能重复，例如：String data = “aabcexmkduyruieiopxzkkkkasdfjxjdsds”;写一个程序，对于给定一个这样的字符串求出字符串出现次数最多的那个字母以及出现的次数（若次数最多的字母有多个，则全部求出）</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826171726.png" alt="1574169374414"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String str = <span class="string">&quot;aabbyolhljlhlxxmnbwyteuhfhjloiqqbhrg&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//统计每个字母的次数</span></span><br><span class="line">	<span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">char</span>[] letters = str.toCharArray();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length; i++) &#123;</span><br><span class="line">		counts[letters[i]-<span class="number">97</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//找出最多次数值</span></span><br><span class="line">	<span class="keyword">int</span> max = counts[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(max &lt; counts[i]) &#123;</span><br><span class="line">			max = counts[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//找出所有最多次数字母</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(counts[i] == max) &#123;</span><br><span class="line">			System.out.println((<span class="keyword">char</span>)(i+<span class="number">97</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果学习完集合之后，该题还可以使用Map集合写出不同的答案</p>
</blockquote>
<h3 id="编程题-7"><a href="#编程题-7" class="headerlink" title="编程题"></a>编程题</h3><p>假设日期段用两个6位长度的正整数表示，例如：(201401，201406)用来表示2014年1月到2014年6月，求两个日期段的重叠月份数。例如：输入：时间段1：201401和201406，时间段2：201403和201409，输出：4</p>
<p>解释：重叠月份：3,4,5,6月共4个月</p>
<p>情形1：两个时间段都是同一年内的，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String date1Start = <span class="string">&quot;201401&quot;</span>;</span><br><span class="line">	String date1End = <span class="string">&quot;201406&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	String date2Start = <span class="string">&quot;201403&quot;</span>;</span><br><span class="line">	String date2End = <span class="string">&quot;201409&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> date1StartMonth = Integer.parseInt(date1Start.substring(<span class="number">4</span>));</span><br><span class="line">	<span class="keyword">int</span> date1EndMonth = Integer.parseInt(date1End.substring(<span class="number">4</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> date2StartMonth = Integer.parseInt(date2Start.substring(<span class="number">4</span>));</span><br><span class="line">	<span class="keyword">int</span> date2EndMonth = Integer.parseInt(date2End.substring(<span class="number">4</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> start = date1StartMonth &gt;= date2StartMonth ? date1StartMonth : date2StartMonth;</span><br><span class="line">	<span class="keyword">int</span> end = date1EndMonth &lt;= date2EndMonth ? date1EndMonth : date2EndMonth;</span><br><span class="line">       System.out.println(<span class="string">&quot;重叠月份数：&quot;</span>+(end-start+<span class="number">1</span>));</span><br><span class="line">       </span><br><span class="line">	System.out.println(<span class="string">&quot;重叠的月份有：&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情形2：两个时间段可能不在同一年内的，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String date1Start = <span class="string">&quot;201401&quot;</span>;</span><br><span class="line">		String date1End = <span class="string">&quot;201506&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		String date2Start = <span class="string">&quot;201403&quot;</span>;</span><br><span class="line">		String date2End = <span class="string">&quot;201505&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		String date1 = handleDate(date1Start,date1End);</span><br><span class="line">		String date2 = handleDate(date2Start,date2End);</span><br><span class="line">		System.out.println(date1);</span><br><span class="line">		System.out.println(date2);</span><br><span class="line">		</span><br><span class="line">		String sameDate = findMaxSubString(date1,date2);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;重叠的月份数：&quot;</span> + sameDate.length()/<span class="number">6</span>);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(sameDate)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;重叠的月份有：&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span> (sameDate.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				String sameMonth = sameDate.substring(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">				System.out.println(sameMonth);</span><br><span class="line">				sameDate = sameDate.substring(<span class="number">6</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findMaxSubString</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">		String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		String mixStr = str1.length()&lt;str2.length()?str1:str2;</span><br><span class="line">		String maxStr = str1.length()&gt;str2.length()?str1:str2;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//外循环控制从左到右的下标，内循环控制从右到左的下标</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mixStr.length();i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=mixStr.length();j&gt;=i;j--)&#123;</span><br><span class="line">				String str=mixStr.substring(i, j);</span><br><span class="line">				<span class="keyword">if</span>(maxStr.contains(str))&#123;</span><br><span class="line">					<span class="comment">//找出最大相同子串</span></span><br><span class="line">					<span class="keyword">if</span>(result.length()&lt;str.length())&#123;</span><br><span class="line">						result = str;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">handleDate</span><span class="params">(String dateStart, String dateEnd)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> dateStartYear = Integer.parseInt(dateStart.substring(<span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line">		<span class="keyword">int</span> dateEndYear = Integer.parseInt(dateEnd.substring(<span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line">		<span class="keyword">int</span> dateStartMonth = Integer.parseInt(dateStart.substring(<span class="number">4</span>));</span><br><span class="line">		<span class="keyword">int</span> dateEndMonth = Integer.parseInt(dateEnd.substring(<span class="number">4</span>));</span><br><span class="line">		</span><br><span class="line">		String date = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(dateStartYear == dateEndYear) &#123;<span class="comment">//一年之内</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = dateStartMonth; i &lt;=dateEndMonth; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">					date += dateStartYear+<span class="string">&quot;0&quot;</span>+i;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					date += dateStartYear+<span class="string">&quot;&quot;</span>+i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;<span class="comment">//跨年</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = dateStartMonth; i &lt;=<span class="number">12</span>; i++) &#123;<span class="comment">//date1StartYear起始年</span></span><br><span class="line">				<span class="keyword">if</span>(i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">					date += dateStartYear+<span class="string">&quot;0&quot;</span>+i;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					date += dateStartYear+<span class="string">&quot;&quot;</span>+i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = dateStartYear+<span class="number">1</span>; i &lt; dateEndYear; i++) &#123;<span class="comment">//中间间隔年</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">12</span>; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(j&lt;<span class="number">10</span>) &#123;</span><br><span class="line">						date += i+<span class="string">&quot;0&quot;</span>+j;</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						date += i+<span class="string">&quot;&quot;</span>+j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dateEndMonth; i++) &#123;<span class="comment">//date1EndYear结束年</span></span><br><span class="line">				<span class="keyword">if</span>(i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">					date += dateEndYear+<span class="string">&quot;0&quot;</span>+i;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					date += dateEndYear+<span class="string">&quot;&quot;</span>+i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> date;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合是java中提供的一种容器，可以用来存储多个数据。</p>
<p>集合和数组既然都是容器，它们有啥区别呢？</p>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中可以存储基本数据类型值，也可以存储对象，而集合中只能存储对象</li>
</ul>
<p>集合主要分为两大系列：Collection和Map，Collection 表示一组对象，Map表示一组映射关系或键值对。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List、Queue）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。 </p>
<p>Collection<E>是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<p><strong>1、添加元素</strong></p>
<p>（1）add(E obj)：添加元素对象到当前集合中</p>
<p>（2）addAll(Collection&lt;? extends E&gt; other)：添加other集合中的所有元素对象到当前集合中，即this = this ∪ other</p>
<p><strong>2、删除元素</strong></p>
<p> （1） boolean remove(Object obj) ：从当前集合中删除第一个找到的与obj对象equals返回true的元素。</p>
<p> （2）boolean removeAll(Collection&lt;?&gt; coll)：从当前集合中删除所有与coll集合中相同的元素。即this = this - this ∩ coll</p>
<p><strong>3、判断</strong></p>
<p>（1）boolean isEmpty()：判断当前集合是否为空集合。</p>
<p>（2）boolean contains(Object obj)：判断当前集合中是否存在一个与obj对象equals返回true的元素。</p>
<p>（3）boolean containsAll(Collection&lt;?&gt; c)：判断c集合中的元素是否在当前集合中都存在。即c集合是否是当前集合的“子集”。</p>
<p><strong>4、获取元素个数</strong></p>
<p>（1）int size()：获取当前集合中实际存储的元素个数</p>
<p><strong>5、交集</strong></p>
<p>（1）boolean retainAll(Collection&lt;?&gt; coll)：当前集合仅保留与c集合中的元素相同的元素，即当前集合中仅保留两个集合的交集，即this  = this ∩ coll；</p>
<p><strong>6、转为数组</strong></p>
<p>（1）Object[] toArray()：返回包含当前集合中所有元素的数组</p>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建集合对象 </span></span><br><span class="line">    	<span class="comment">// 使用多态形式</span></span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	<span class="comment">// 使用方法</span></span><br><span class="line">    	<span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    	coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">    	System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="string">&quot;扫地僧&quot;</span>));</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="string">&quot;石破天&quot;</span>));</span><br><span class="line">    	System.out.println(<span class="string">&quot;操作之后集合中元素:&quot;</span>+coll);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">		System.out.println(<span class="string">&quot;集合中有&quot;</span>+coll.size()+<span class="string">&quot;个元素&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    	Object[] objects = coll.toArray();</span><br><span class="line">    	<span class="comment">// 遍历数组</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">			System.out.println(objects[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// void  clear() 清空集合</span></span><br><span class="line">		coll.clear();</span><br><span class="line">		System.out.println(<span class="string">&quot;集合中内容为：&quot;</span>+coll);</span><br><span class="line">		<span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">		System.out.println(coll.isEmpty());  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		coll.add(<span class="number">1</span>);</span><br><span class="line">		coll.add(<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;coll集合元素的个数：&quot;</span> + coll.size());</span><br><span class="line">		</span><br><span class="line">		Collection other = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		other.add(<span class="number">1</span>);</span><br><span class="line">		other.add(<span class="number">2</span>);</span><br><span class="line">		other.add(<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		coll.addAll(other);</span><br><span class="line"><span class="comment">//		coll.add(other);</span></span><br><span class="line">		System.out.println(<span class="string">&quot;coll集合元素的个数：&quot;</span> + coll.size());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：coll.addAll(other);与coll.add(other);</p>
</blockquote>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172636.png" alt="1563548078274"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	coll.add(<span class="number">1</span>);</span><br><span class="line">	coll.add(<span class="number">2</span>);</span><br><span class="line">	coll.add(<span class="number">3</span>);</span><br><span class="line">	coll.add(<span class="number">4</span>);</span><br><span class="line">	coll.add(<span class="number">5</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;coll集合元素的个数：&quot;</span> + coll.size());<span class="comment">//5</span></span><br><span class="line">	</span><br><span class="line">	Collection other = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	other.add(<span class="number">1</span>);</span><br><span class="line">	other.add(<span class="number">2</span>);</span><br><span class="line">	other.add(<span class="number">8</span>);</span><br><span class="line">	</span><br><span class="line">	coll.retainAll(other);<span class="comment">//保留交集</span></span><br><span class="line">	System.out.println(<span class="string">&quot;coll集合元素的个数：&quot;</span> + coll.size());<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">&quot;串串星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;吐槽星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;汪星人&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
</blockquote>
<h3 id="迭代器的实现原理"><a href="#迭代器的实现原理" class="headerlink" title="迭代器的实现原理"></a>迭代器的实现原理</h3><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172651.bmp"></p>
<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，指向第一个元素，当第一次调用迭代器的next方法时，返回第一个元素，然后迭代器的索引会向后移动一位，指向第二个元素，当再次调用next方法时，返回第二个元素，然后迭代器的索引会再向后移动一位，指向第三个元素，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h3 id="使用Iterator迭代器删除元素"><a href="#使用Iterator迭代器删除元素" class="headerlink" title="使用Iterator迭代器删除元素"></a>使用Iterator迭代器删除元素</h3><p>java.util.Iterator迭代器中有一个方法：</p>
<p>​    void remove() ;</p>
<p>那么，既然Collection已经有remove(xx)方法了，为什么Iterator迭代器还要提供删除方法呢？</p>
<p>因为Collection的remove方法，无法根据条件删除。</p>
<p>例如：要删除以下集合元素中的偶数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Collection&lt;Integer&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		coll.add(<span class="number">1</span>);</span><br><span class="line">		coll.add(<span class="number">2</span>);</span><br><span class="line">		coll.add(<span class="number">3</span>);</span><br><span class="line">		coll.add(<span class="number">4</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		coll.remove(?)//无法编写</span></span><br><span class="line">		</span><br><span class="line">		Iterator&lt;Integer&gt; iterator = coll.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">			Integer element = iterator.next();</span><br><span class="line">			<span class="keyword">if</span>(element%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//				coll.remove(element);//错误的</span></span><br><span class="line">				iterator.remove();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(coll);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：不要在使用Iterator迭代器进行迭代时，调用Collection的remove(xx)方法，否则会报异常java.util.ConcurrentModificationException，或出现不确定行为。</p>
</blockquote>
<h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h3><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><p>通常只进行遍历元素，<strong>不要在遍历的过程中对数组元素进行修改</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       	<span class="comment">//使用增强for遍历数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">			System.out.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习2：遍历集合"><a href="#练习2：遍历集合" class="headerlink" title="练习2：遍历集合"></a>练习2：遍历集合</h4><p>通常只进行遍历元素，<strong>不要在遍历的过程中对集合元素进行增加、删除、替换操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	coll.add(<span class="string">&quot;小河神&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;老河神&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;神婆&quot;</span>);</span><br><span class="line">    	<span class="comment">//使用增强for遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    		System.out.println(s);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-lang-Iterable接口"><a href="#java-lang-Iterable接口" class="headerlink" title="java.lang.Iterable接口"></a>java.lang.Iterable接口</h3><p>java.lang.Iterable接口，实现这个接口允许对象成为 “foreach” 语句的目标。 </p>
<p>Java 5时Collection接口继承了java.lang.Iterable接口，因此Collection系列的集合就可以直接使用foreach循环遍历。</p>
<p>java.lang.Iterable接口的抽象方法：</p>
<ul>
<li>public Iterator iterator(): 获取对应的迭代器，用来遍历数组或集合中的元素的。</li>
</ul>
<p>自定义某容器类型，实现java.lang.Iterable接口，发现就可以使用foreach进行迭代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyArrayList</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyArrayList&lt;String&gt; my = <span class="keyword">new</span> MyArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String obj : my) &#123;</span><br><span class="line">			System.out.println(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foreach本质上就是使用Iterator迭代器进行遍历的。</p>
<p>我们在如下代码的for(Student student : coll)这行打断点，然后使用单步调试进入源码，发现foreach本质上是调用集合的iterator()方法，返回一个迭代器进行迭代的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForeach</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		coll.add(<span class="string">&quot;陈琦&quot;</span>);</span><br><span class="line">		coll.add(<span class="string">&quot;李晨&quot;</span>);</span><br><span class="line">		coll.add(<span class="string">&quot;邓超&quot;</span>);</span><br><span class="line">		coll.add(<span class="string">&quot;黄晓明&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//调用ArrayList里面的Iterator iterator()</span></span><br><span class="line">		<span class="keyword">for</span> (String str : coll) &#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172716.png" alt="1572594204643"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172722.png" alt="1572594284437"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172733.png" alt="1572594358046"></p>
<blockquote>
<p>所以也不要在foreach遍历的过程使用Collection的remove()方法。否则，要么报异常java.util.ConcurrentModificationException，要么行为不确定。</p>
</blockquote>
<h3 id="Java中modCount的用法，快速失败（fail-fast）机制"><a href="#Java中modCount的用法，快速失败（fail-fast）机制" class="headerlink" title="Java中modCount的用法，快速失败（fail-fast）机制"></a>Java中modCount的用法，快速失败（fail-fast）机制</h3><p>当使用foreach或Iterator迭代器遍历集合时，同时调用迭代器自身以外的方法修改了集合的结构，例如调用集合的add和remove方法时，就会报ConcurrentModificationException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForeach</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">			list.remove(iterator.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在Iterator、ListIterator迭代器创建后的任意时间从结构上修改了集合（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，而不是冒着在将来不确定的时间任意发生不确定行为的风险。</p>
<p>这样设计是因为，迭代器代表集合中某个元素的位置，内部会存储某些能够代表该位置的信息。当集合发生改变时，该信息的含义可能会发生变化，这时操作迭代器就可能会造成不可预料的事情。因此，果断抛异常阻止，是最好的方法。这就是Iterator迭代器的快速失败（fail-fast）机制。</p>
<p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在不同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 <code>ConcurrentModificationException</code>。因此，编写依赖于此异常的程序的方式是错误的，正确做法是：<em>迭代器的快速失败行为应该仅用于检测 bug。</em>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//以下代码没有发生ConcurrentModificationException异常</span></span><br><span class="line">	Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">	<span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">		String str = iterator.next();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">&quot;atguigu&quot;</span>.equals(str))&#123;</span><br><span class="line">			list.remove(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如何实现快速失败（fail-fast）机制的呢？</p>
<ul>
<li>在ArrayList等集合类中都有一个modCount变量。它用来记录集合的结构被修改的次数。</li>
<li>当我们给集合添加和删除操作时，会导致modCount++。</li>
<li>然后当我们用Iterator迭代器遍历集合时，创建集合迭代器的对象时，用一个变量记录当前集合的modCount。例如：<code>int expectedModCount = modCount;</code>，并且在迭代器每次next()迭代元素时，都要检查 <code>expectedModCount != modCount</code>，如果不相等了，那么说明你调用了Iterator迭代器以外的Collection的add,remove等方法，修改了集合的结构，使得modCount++，值变了，就会抛出ConcurrentModificationException。</li>
</ul>
<p>下面以AbstractList<E>和ArrayList.Itr迭代器为例进行源码分析：</p>
<p>AbstractList<E>类中声明了modCount变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the size of the</span></span><br><span class="line"><span class="comment"> * list, or otherwise perturb it in such a fashion that iterations in</span></span><br><span class="line"><span class="comment"> * progress may yield incorrect results.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This field is used by the iterator and list iterator implementation</span></span><br><span class="line"><span class="comment"> * returned by the &#123;<span class="doctag">@code</span> iterator&#125; and &#123;<span class="doctag">@code</span> listIterator&#125; methods.</span></span><br><span class="line"><span class="comment"> * If the value of this field changes unexpectedly, the iterator (or list</span></span><br><span class="line"><span class="comment"> * iterator) will throw a &#123;<span class="doctag">@code</span> ConcurrentModificationException&#125; in</span></span><br><span class="line"><span class="comment"> * response to the &#123;<span class="doctag">@code</span> next&#125;, &#123;<span class="doctag">@code</span> remove&#125;, &#123;<span class="doctag">@code</span> previous&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> set&#125; or &#123;<span class="doctag">@code</span> add&#125; operations.  This provides</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in</span></span><br><span class="line"><span class="comment"> * the face of concurrent modification during iteration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass</span></span><br><span class="line"><span class="comment"> * wishes to provide fail-fast iterators (and list iterators), then it</span></span><br><span class="line"><span class="comment"> * merely has to increment this field in its &#123;<span class="doctag">@code</span> add(int, E)&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> remove(int)&#125; methods (and any other methods that it overrides</span></span><br><span class="line"><span class="comment"> * that result in structural modifications to the list).  A single call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> add(int, E)&#125; or &#123;<span class="doctag">@code</span> remove(int)&#125; must add no more than</span></span><br><span class="line"><span class="comment"> * one to this field, or the iterators (and list iterators) will throw</span></span><br><span class="line"><span class="comment"> * bogus &#123;<span class="doctag">@code</span> ConcurrentModificationExceptions&#125;.  If an implementation</span></span><br><span class="line"><span class="comment"> * does not wish to provide fail-fast iterators, this field may be</span></span><br><span class="line"><span class="comment"> * ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>modCount是这个list被结构性修改的次数。结构性修改是指：改变list的size大小，或者，以其他方式改变他导致正在进行迭代时出现错误的结果。</p>
<p>这个字段用于迭代器和列表迭代器的实现类中，由迭代器和列表迭代器方法返回。如果这个值被意外改变，这个迭代器将会抛出 ConcurrentModificationException的异常来响应：next,remove,previous,set,add 这些操作。在迭代过程中，他提供了fail-fast行为而不是不确定行为来处理并发修改。</p>
<p>子类使用这个字段是可选的，如果子类希望提供fail-fast迭代器，它仅仅需要在add(int, E),remove(int)方法（或者它重写的其他任何会结构性修改这个列表的方法）中添加这个字段。调用一次add(int,E)或者remove(int)方法时必须且仅仅给这个字段加1，否则迭代器会抛出伪装的ConcurrentModificationExceptions错误。如果一个实现类不希望提供fail-fast迭代器，则可以忽略这个字段。</p>
<p>Arraylist的Itr迭代器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;      </span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;<span class="comment">//在创建迭代器时，expectedModCount初始化为当前集合的modCount的值</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();<span class="comment">//校验expectedModCount与modCount是否相等</span></span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line">       	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)<span class="comment">//校验expectedModCount与modCount是否相等</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();<span class="comment">//不相等，抛异常</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子接口，他们都具备那些特性呢？</p>
<h3 id="List接口介绍"><a href="#List接口介绍" class="headerlink" title="List接口介绍"></a>List接口介绍</h3><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。</p>
<p>List接口特点：</p>
<ol>
<li>List集合所有的元素是以一种线性方式进行存储的，例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）</li>
<li>它是一个元素存取有序的集合。即元素的存入顺序和取出顺序有保证。</li>
<li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ol>
<p>List集合类中元素有序、且可重复。这就像银行门口客服，给每一个来办理业务的客户分配序号：第一个来的是“张三”，客服给他分配的是0；第二个来的是“李四”，客服给他分配的1；以此类推，最后一个序号应该是“总人数-1”。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172755.png" alt="1563549818689"></p>
<p>注意：</p>
<p>List集合关心元素是否有序，而不关心是否重复，请大家记住这个原则。例如“张三”可以领取两个号。</p>
<h3 id="List接口中常用方法"><a href="#List接口中常用方法" class="headerlink" title="List接口中常用方法"></a>List接口中常用方法</h3><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p>
<p>List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。</p>
<p>1、添加元素</p>
<ul>
<li>void add(int index, E ele)</li>
<li>boolean addAll(int index, Collection&lt;? extends E&gt; eles)</li>
</ul>
<p>2、获取元素</p>
<ul>
<li>E get(int index)</li>
<li>List subList(int fromIndex, int toIndex)</li>
</ul>
<p>3、获取元素索引</p>
<ul>
<li>int indexOf(Object obj)</li>
<li>int lastIndexOf(Object obj)</li>
</ul>
<p>4、删除和替换元素</p>
<ul>
<li>E remove(int index)</li>
<li>E set(int index, E ele)</li>
</ul>
<p>List集合特有的方法都是跟索引相关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建List集合对象</span></span><br><span class="line">    	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">    	list.add(<span class="string">&quot;图图&quot;</span>);</span><br><span class="line">    	list.add(<span class="string">&quot;小美&quot;</span>);</span><br><span class="line">    	list.add(<span class="string">&quot;不高兴&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">    	list.add(<span class="number">1</span>,<span class="string">&quot;没头脑&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span></span><br><span class="line">    	<span class="comment">// 删除索引位置为2的元素 </span></span><br><span class="line">    	System.out.println(<span class="string">&quot;删除索引位置为2的元素&quot;</span>);</span><br><span class="line">    	System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String set(int index,String s)</span></span><br><span class="line">    	<span class="comment">// 在指定位置 进行 元素替代（改） </span></span><br><span class="line">    	<span class="comment">// 修改指定位置元素</span></span><br><span class="line">    	list.set(<span class="number">0</span>, <span class="string">&quot;三毛&quot;</span>);</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String get(int index)  获取指定位置元素</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 跟size() 方法一起用  来 遍历的 </span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    		System.out.println(list.get(i));</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//还可以使用增强for</span></span><br><span class="line">    	<span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在JavaSE中List名称的类型有两个，一个是java.util.List集合接口，一个是java.awt.List图形界面的组件，别导错包了。</p>
</blockquote>
<h3 id="List接口的实现类们"><a href="#List接口的实现类们" class="headerlink" title="List接口的实现类们"></a>List接口的实现类们</h3><p>List接口的实现类有很多，常见的有：</p>
<p>ArrayList：动态数组</p>
<p>Vector：动态数组</p>
<p>LinkedList：双向链表</p>
<p>Stack：栈</p>
<p>它们的区别我们在数据结构部分再详细讲解</p>
<h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p>List 集合额外提供了一个 listIterator() 方法，该方法返回一个 ListIterator 对象， ListIterator 接口继承了 Iterator 接口，提供了专门操作 List 的方法：</p>
<ul>
<li>void add()：通过迭代器添加元素到对应集合</li>
<li>void set(Object obj)：通过迭代器替换正迭代的元素</li>
<li>void remove()：通过迭代器删除刚迭代的元素</li>
<li>boolean hasPrevious()：如果以逆向遍历列表，往前是否还有元素。</li>
<li>Object previous()：返回列表中的前一个元素。</li>
<li>int previousIndex()：返回列表中的前一个元素的索引</li>
<li>boolean hasNext()</li>
<li>Object next()</li>
<li>int nextIndex()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	List&lt;Student&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	c.add(<span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">	c.add(<span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">	c.add(<span class="keyword">new</span> Student(<span class="number">3</span>,<span class="string">&quot;王五&quot;</span>));</span><br><span class="line">	c.add(<span class="keyword">new</span> Student(<span class="number">4</span>,<span class="string">&quot;赵六&quot;</span>));</span><br><span class="line">	c.add(<span class="keyword">new</span> Student(<span class="number">5</span>,<span class="string">&quot;钱七&quot;</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//从指定位置往前遍历</span></span><br><span class="line">	ListIterator&lt;Student&gt; listIterator = c.listIterator(c.size());</span><br><span class="line">	<span class="keyword">while</span>(listIterator.hasPrevious())&#123;</span><br><span class="line">		Student previous = listIterator.previous();</span><br><span class="line">		System.out.println(previous);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>Set接口是Collection的子接口，set接口没有提供额外的方法。但是比<code>Collection</code>接口更加严格了。</p>
<p>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。</p>
<p>Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。</p>
<p>Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</p>
<p><code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，然后HashMap的底层物理实现是一个Hash表。（什么是哈希表，下一节在HashMap小节在细讲，这里先不展开）</p>
<p>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。因此，存储到HashSet的元素要重写hashCode和equals方法。</p>
<p>示例代码：定义一个Employee类，该类包含属性：name, birthday，其中 birthday 为 MyDate类的对象；MyDate为自定义类型，包含年、月、日属性。要求 name和birthday一样的视为同一个员工。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> MyDate birthday;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, MyDate birthday)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> MyDate <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> birthday;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(MyDate birthday)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">		result = prime * result + ((birthday == <span class="keyword">null</span>) ? <span class="number">0</span> : birthday.hashCode());</span><br><span class="line">		result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		Employee other = (Employee) obj;</span><br><span class="line">		<span class="keyword">if</span> (birthday == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (other.birthday != <span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!birthday.equals(other.birthday))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;, 生日：&quot;</span> + birthday;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> month;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.year = year;</span><br><span class="line">		<span class="keyword">this</span>.month = month;</span><br><span class="line">		<span class="keyword">this</span>.day = day;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> year;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setYear</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.year = year;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> month;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMonth</span><span class="params">(<span class="keyword">int</span> month)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.month = month;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> day;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDay</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.day = day;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">		result = prime * result + day;</span><br><span class="line">		result = prime * result + month;</span><br><span class="line">		result = prime * result + year;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		MyDate other = (MyDate) obj;</span><br><span class="line">		<span class="keyword">if</span> (day != other.day)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (month != other.month)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (year != other.year)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + day;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashSet</span> </span>&#123;</span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashSet&lt;Employee&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		set.add(<span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>, <span class="keyword">new</span> MyDate(<span class="number">1990</span>,<span class="number">1</span>,<span class="number">1</span>)));</span><br><span class="line">		<span class="comment">//重复元素无法添加，因为MyDate和Employee重写了hashCode和equals方法</span></span><br><span class="line">		set.add(<span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>, <span class="keyword">new</span> MyDate(<span class="number">1990</span>,<span class="number">1</span>,<span class="number">1</span>)));</span><br><span class="line">		set.add(<span class="keyword">new</span> Employee(<span class="string">&quot;李四&quot;</span>, <span class="keyword">new</span> MyDate(<span class="number">1992</span>,<span class="number">2</span>,<span class="number">2</span>)));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (Employee object : set) &#123;</span><br><span class="line">			System.out.println(object);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet是HashSet的子类，它在HashSet的基础上，在结点中增加两个属性before和after维护了结点的前后添加顺序。<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashSet&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		</span><br><span class="line">System.out.println(<span class="string">&quot;元素个数：&quot;</span> + set.size());</span><br><span class="line"><span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">	System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">元素个数：3</span><br><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br></pre></td></tr></table></figure>

<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层结构：里面维护了一个TreeMap，都是基于红黑树实现的！</p>
<p>特点：<br>    1、不允许重复<br>    2、实现排序<br>        自然排序或定制排序</p>
<p>如何实现去重的？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果使用的是自然排序，则通过调用实现的compareTo方法</span><br><span class="line">如果使用的是定制排序，则通过调用比较器的compare方法</span><br></pre></td></tr></table></figure>

<p>如何排序？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一：自然排序</span><br><span class="line">让待添加的元素类型实现Comparable接口，并重写compareTo方法</span><br><span class="line"></span><br><span class="line">方式二：定制排序</span><br><span class="line">创建Set对象时，指定Comparator比较器接口，并实现compare方法</span><br></pre></td></tr></table></figure>

<h4 id="自然顺序"><a href="#自然顺序" class="headerlink" title="自然顺序"></a>自然顺序</h4><p>如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值为0。</p>
<p>代码示例一：按照字符串Unicode编码值排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		TreeSet&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">		set.add(<span class="string">&quot;zhangsan&quot;</span>);  <span class="comment">//String它实现了java.lang.Comparable接口</span></span><br><span class="line">		set.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">				</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + set.size());</span><br><span class="line">		<span class="keyword">for</span> (String str : set) &#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h4><p>如果放到TreeSet中的元素的自然排序（Comparable）规则不符合当前排序需求时，或者元素的类型没有实现Comparable接口。那么在创建TreeSet时，可以单独指定一个Comparator的对象。使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。</p>
<p>代码示例：学生类型未实现Comparable接口，单独指定Comparator比较器，按照学生的学号排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//......这里省略了name属性的get/set</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	TreeSet&lt;Student&gt; set = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator&lt;Student&gt;()&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;);</span><br><span class="line">	set.add(<span class="keyword">new</span> Student(<span class="number">3</span>,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">	set.add(<span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">	set.add(<span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">&quot;王五&quot;</span>));</span><br><span class="line">	set.add(<span class="keyword">new</span> Student(<span class="number">3</span>,<span class="string">&quot;张三风&quot;</span>));</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">&quot;元素个数：&quot;</span> + set.size());</span><br><span class="line">	<span class="keyword">for</span> (Student stu : set) &#123;</span><br><span class="line">		System.out.println(stu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Collection系列的集合框架图"><a href="#Collection系列的集合框架图" class="headerlink" title="Collection系列的集合框架图"></a>Collection系列的集合框架图</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172832.png"></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map&lt;K,V&gt;</code>接口。</p>
<p>我们通过查看<code>Map</code>接口描述，发现<code>Map&lt;K,V&gt;</code>接口下的集合与<code>Collection&lt;E&gt;</code>接口下的集合，它们存储数据的形式不同。</p>
<ul>
<li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li>
<li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li>
<li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li>
<li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值（这个值可以是单个值，也可以是个数组或集合值）。</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172850.bmp"></p>
<h3 id="Map常用方法"><a href="#Map常用方法" class="headerlink" title="Map常用方法"></a>Map常用方法</h3><p>1、添加操作</p>
<ul>
<li>V put(K key,V value)</li>
<li>void putAll(Map&lt;? extends K,? extends V&gt; m)</li>
</ul>
<p>2、删除</p>
<ul>
<li>void clear()</li>
<li>V remove(Object key)</li>
</ul>
<p> 3、元素查询的操作</p>
<ul>
<li>V get(Object key)</li>
<li>boolean containsKey(Object key)</li>
<li>boolean containsValue(Object value)</li>
<li>boolean isEmpty()</li>
</ul>
<p> 4、元视图操作的方法：</p>
<ul>
<li>Set<K> keySet()</li>
<li>Collection<V> values()</li>
<li>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</li>
</ul>
<p> 5、其他方法</p>
<ul>
<li>int size()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 map对象</span></span><br><span class="line">        HashMap&lt;String, String&gt;  map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">&quot;黄晓明&quot;</span>, <span class="string">&quot;杨颖&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;文章&quot;</span>, <span class="string">&quot;马伊琍&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String remove(String key)</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;邓超&quot;</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想要查看 黄晓明的媳妇 是谁</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;黄晓明&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;邓超&quot;</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:</p>
<p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p>
<p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p>
</blockquote>
<h3 id="Map集合的遍历"><a href="#Map集合的遍历" class="headerlink" title="Map集合的遍历"></a>Map集合的遍历</h3><p>Collection集合的遍历：（1）foreach（2）通过Iterator对象遍历</p>
<p>Map的遍历，不能支持foreach，因为Map接口没有继承java.lang.Iterable<T>接口，也没有实现Iterator iterator()方法。只能用如下方式遍历：</p>
<p>（1）分开遍历：</p>
<ul>
<li>单独遍历所有key</li>
<li>单独遍历所有value</li>
</ul>
<p>（2）成对遍历：</p>
<ul>
<li>遍历的是映射关系Map.Entry类型的对象，Map.Entry是Map接口的内部接口。每一种Map内部有自己的Map.Entry的实现类。在Map中存储数据，实际上是将Key—-&gt;value的数据存储在Map.Entry接口的实例中，再在Map集合中插入Map.Entry的实例化对象，如图示： </li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172902.png" alt="1563725601891"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		map.put(<span class="string">&quot;许仙&quot;</span>, <span class="string">&quot;白娘子&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;董永&quot;</span>, <span class="string">&quot;七仙女&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;牛郎&quot;</span>, <span class="string">&quot;织女&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;许仙&quot;</span>, <span class="string">&quot;小青&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;所有的key:&quot;</span>);</span><br><span class="line">		Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">		<span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">			System.out.println(key);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;所有的value：&quot;</span>);</span><br><span class="line">		Collection&lt;String&gt; values = map.values();</span><br><span class="line">		<span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">			System.out.println(value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;所有的映射关系&quot;</span>);</span><br><span class="line">		Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String,String&gt; entry : entrySet) &#123;</span><br><span class="line"><span class="comment">//			System.out.println(entry);</span></span><br><span class="line">			System.out.println(entry.getKey()+<span class="string">&quot;-&gt;&quot;</span>+entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map的实现类们"><a href="#Map的实现类们" class="headerlink" title="Map的实现类们"></a>Map的实现类们</h3><p>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中HashMap是 Map 接口使用频率最高的实现类。</p>
<h4 id="HashMap和Hashtable的区别与联系"><a href="#HashMap和Hashtable的区别与联系" class="headerlink" title="HashMap和Hashtable的区别与联系"></a><strong>HashMap和Hashtable的区别与联系</strong></h4><ul>
<li>HashMap和Hashtable都是哈希表。</li>
</ul>
<ul>
<li><p>HashMap和Hashtable判断两个 key 相等的标准是：两个 key 的hashCode 值相等，并且 equals() 方法也返回 true。因此，为了成功地在哈希表中存储和获取对象，用作键的对象必须实现 hashCode 方法和 equals 方法。</p>
</li>
<li><p>Hashtable是线程安全的，任何非 null 对象都可以用作键或值。</p>
</li>
<li><p>HashMap是线程不安全的，并允许使用 null 值和 null 键。</p>
</li>
</ul>
<p>示例代码：添加员工姓名为key，薪资为value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	HashMap&lt;String,Double&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">10000.0</span>);</span><br><span class="line">	<span class="comment">//key相同，新的value会覆盖原来的value</span></span><br><span class="line">	<span class="comment">//因为String重写了hashCode和equals方法</span></span><br><span class="line">	map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">12000.0</span>);</span><br><span class="line">	map.put(<span class="string">&quot;李四&quot;</span>, <span class="number">14000.0</span>);</span><br><span class="line">	<span class="comment">//HashMap支持key和value为null值</span></span><br><span class="line">	String name = <span class="keyword">null</span>;</span><br><span class="line">	Double salary = <span class="keyword">null</span>;</span><br><span class="line">	map.put(name, salary);</span><br><span class="line">	</span><br><span class="line">	Set&lt;Entry&lt;String, Double&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">	<span class="keyword">for</span> (Entry&lt;String, Double&gt; entry : entrySet) &#123;</span><br><span class="line">		System.out.println(entry);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a><strong>LinkedHashMap</strong></h4><p>LinkedHashMap 是 HashMap 的子类。此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。</p>
<p>示例代码：添加员工姓名为key，薪资为value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	LinkedHashMap&lt;String,Double&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">	map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">10000.0</span>);</span><br><span class="line">	<span class="comment">//key相同，新的value会覆盖原来的value</span></span><br><span class="line">	<span class="comment">//因为String重写了hashCode和equals方法</span></span><br><span class="line">	map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">12000.0</span>);</span><br><span class="line">	map.put(<span class="string">&quot;李四&quot;</span>, <span class="number">14000.0</span>);</span><br><span class="line">	<span class="comment">//HashMap支持key和value为null值</span></span><br><span class="line">	String name = <span class="keyword">null</span>;</span><br><span class="line">	Double salary = <span class="keyword">null</span>;</span><br><span class="line">	map.put(name, salary);</span><br><span class="line">	</span><br><span class="line">	Set&lt;Entry&lt;String, Double&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">	<span class="keyword">for</span> (Entry&lt;String, Double&gt; entry : entrySet) &#123;</span><br><span class="line">		System.out.println(entry);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a><strong>TreeMap</strong></h4><p>基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</p>
<p>代码示例：添加员工姓名为key，薪资为value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTreeMap</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		TreeMap&lt;String,Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">		map.put(<span class="string">&quot;Jack&quot;</span>, <span class="number">11000</span>);</span><br><span class="line">		map.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">12000</span>);</span><br><span class="line">		map.put(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">13000</span>);</span><br><span class="line">		map.put(<span class="string">&quot;baitao&quot;</span>, <span class="number">14000</span>);</span><br><span class="line">		map.put(<span class="string">&quot;Lucy&quot;</span>, <span class="number">15000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//String实现了Comparable接口，默认按照Unicode编码值排序</span></span><br><span class="line">		Set&lt;Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;String, Integer&gt; entry : entrySet) &#123;</span><br><span class="line">			System.out.println(entry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//指定定制比较器Comparator，按照Unicode编码值排序，但是忽略大小写</span></span><br><span class="line">		TreeMap&lt;String,Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> o1.compareToIgnoreCase(o2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		map.put(<span class="string">&quot;Jack&quot;</span>, <span class="number">11000</span>);</span><br><span class="line">		map.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">12000</span>);</span><br><span class="line">		map.put(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">13000</span>);</span><br><span class="line">		map.put(<span class="string">&quot;baitao&quot;</span>, <span class="number">14000</span>);</span><br><span class="line">		map.put(<span class="string">&quot;Lucy&quot;</span>, <span class="number">15000</span>);</span><br><span class="line">		</span><br><span class="line">		Set&lt;Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;String, Integer&gt; entry : entrySet) &#123;</span><br><span class="line">			System.out.println(entry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a><strong>Properties</strong></h4><p>Properties 类是 Hashtable 的子类，Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。</p>
<p>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Properties properties = System.getProperties();</span><br><span class="line">	String p2 = properties.getProperty(<span class="string">&quot;file.encoding&quot;</span>);<span class="comment">//当前源文件字符编码</span></span><br><span class="line">	System.out.println(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Set集合与Map集合的关系"><a href="#Set集合与Map集合的关系" class="headerlink" title="Set集合与Map集合的关系"></a>Set集合与Map集合的关系</h3><p>Set的内部实现其实是一个Map。即HashSet的内部实现是一个HashMap，TreeSet的内部实现是一个TreeMap，LinkedHashSet的内部实现是一个LinkedHashMap。</p>
<p>部分源代码摘要：</p>
<p>HashSet源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">       addAll(c);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个构造器是给子类LinkedHashSet调用的</span></span><br><span class="line">   HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">       map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashSet源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);<span class="comment">//调用HashSet的某个构造器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="keyword">true</span>);<span class="comment">//调用HashSet的某个构造器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), <span class="number">.75f</span>, <span class="keyword">true</span>);<span class="comment">//调用HashSet的某个构造器</span></span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeSet源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，咱们存到Set中只有一个元素，又是怎么变成(key,value)的呢？</p>
<p>以HashSet中的源码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来是，把添加到Set中的元素作为内部实现map的key，然后用一个常量对象PRESENT对象，作为value。</p>
<p>这是因为Set的元素不可重复和Map的key不可重复有相同特点。Map有一个方法keySet()可以返回所有key。</p>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826172936.png"></p>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>参考操作数组的工具类：Arrays。</p>
<p>Collections 是一个操作 Set、List 和 Map 等集合的工具类。Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法：</p>
<ul>
<li>public static <T> boolean addAll(Collection&lt;? super T&gt; c,T… elements)将所有指定元素添加到指定 collection 中。</li>
<li>public static <T> int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。</li>
<li>public static <T> int binarySearch(List&lt;? extends T&gt; list,T key,Comparator&lt;? super T&gt; c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。</li>
<li>public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序</li>
<li>public static <T> T max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者</li>
<li>public static void reverse(List&lt;?&gt; list)反转指定列表List中元素的顺序。</li>
<li>public static void shuffle(List&lt;?&gt; list) List 集合元素进行随机排序，类似洗牌</li>
<li>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List<T> list)根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li>public static <T> void sort(List<T> list,Comparator&lt;? super T&gt; c)根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>public static void swap(List&lt;?&gt; list,int i,int j)将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
<li>public static int frequency(Collection&lt;?&gt; c,Object o)返回指定集合中指定元素的出现次数</li>
<li>public static <T> void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)将src中的内容复制到dest中</li>
<li>public static <T> boolean replaceAll(List<T> list，T oldVal，T newVal)：使用新值替换 List 对象的所有旧值</li>
<li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</li>
<li>Collections类中提供了多个unmodifiableXxx()方法，该方法返回指定 Xxx的不可修改的视图。</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h2><h3 id="泛型的引入"><a href="#泛型的引入" class="headerlink" title="泛型的引入"></a>泛型的引入</h3><p>例如：生产瓶子的厂家，一开始并不知道我们将来会用瓶子装什么，我们什么都可以装，但是有的时候，我们在使用时，想要限定某个瓶子只能用来装什么，这样我们不会装错，而用的时候也可以放心的使用，无需再三思量。我们生活中是<strong>在使用这个瓶子时在瓶子上“贴标签”</strong>，这样就轻松解决了问题。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173354.png" alt="1563412556491"></p>
<p>还有，在Java中我们在声明方法时，当在完成方法功能时如果有未知的数据需要参与，这些未知的数据需要在调用方法时才能确定，那么我们把这样的数据通过形参表示。那么在方法体中，用这个形参名来代表那个未知的数据，而调用者在调用时，对应的传入值就可以了。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173354.png" alt="1563414367674"></p>
<p>受以上两点启发，JDK1.5设计了泛型的概念。泛型即为“类型参数”，这个类型参数在声明它的类、接口或方法中，代表未知的通用的类型。例如：</p>
<p>java.lang.Comparable接口和java.util.Comparator接口，是用于对象比较大小的规范接口，这两个接口只是限定了当一个对象大于另一个对象时返回正整数，小于返回负整数，等于返回0。但是并不确定是什么类型的对象比较大小，之前的时候只能用Object类型表示，使用时既麻烦又不安全，因此JDK1.5就给它们增加了泛型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<T>就是类型参数，即泛型。</p>
<h3 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h3><p>示例代码：</p>
<p>JavaBean：圆类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> radius;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Circle [radius=&quot;</span> + radius + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//强制类型转换</span></span><br><span class="line">		Circle c1 = (Circle) o1;</span><br><span class="line">		Circle c2 = (Circle) o2;</span><br><span class="line">		<span class="keyword">return</span> Double.compare(c1.getRadius(), c2.getRadius());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		CircleComparator com = <span class="keyword">new</span> CircleComparator();</span><br><span class="line">		System.out.println(com.compare(<span class="keyword">new</span> Circle(<span class="number">1</span>), <span class="keyword">new</span> Circle(<span class="number">2</span>)));</span><br><span class="line">		</span><br><span class="line">		System.out.println(com.compare(<span class="string">&quot;圆1&quot;</span>, <span class="string">&quot;圆2&quot;</span>));<span class="comment">//运行时异常：ClassCastException</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们在使用如上面这样的接口时，如果没有泛型或不指定泛型，很麻烦，而且有安全隐患。</p>
<p>因为在设计（编译）Comparator接口时，不知道它会用于哪种类型的对象比较，因此只能将compare方法的形参设计为Object类型，而实际在compare方法中需要向下转型为Circle，才能调用Circle类的getRadius()获取半径值进行比较。</p>
<p>使用泛型：</p>
<p>比较器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Circle</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Circle o1, Circle o2)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//不再需要强制类型转换，代码更简洁</span></span><br><span class="line">		<span class="keyword">return</span> Double.compare(o1.getRadius(), o2.getRadius());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		CircleComparator com = <span class="keyword">new</span> CircleComparator();</span><br><span class="line">		System.out.println(com.compare(<span class="keyword">new</span> Circle(<span class="number">1</span>), <span class="keyword">new</span> Circle(<span class="number">2</span>)));</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		System.out.println(com.compare(&quot;圆1&quot;, &quot;圆2&quot;));//编译错误，因为&quot;圆1&quot;, &quot;圆2&quot;不是Circle类型，是String类型，编译器提前报错，而不是冒着风险在运行时再报错</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有了泛型并使用泛型，那么既能保证安全，又能简化代码。</p>
<p>因为把不安全的因素在编译期间就排除了；既然通过了编译，那么类型一定是符合要求的，就避免了类型转换。</p>
<h3 id="泛型的相关名词"><a href="#泛型的相关名词" class="headerlink" title="泛型的相关名词"></a>泛型的相关名词</h3><p>&lt;类型&gt;这种语法形式就叫泛型。</p>
<p>其中：</p>
<ul>
<li><p><T>是类型变量（Type Variables），而<T>是代表未知的数据类型，我们可以指定为<String>，<Integer>，<Circle>等，那么&lt;类型&gt;的形式我们成为类型参数；</p>
<ul>
<li>类比方法的参数的概念，我们可以把<T>，称为类型形参，将<Circle>称为类型实参，有助于我们理解泛型；</li>
</ul>
</li>
<li><p>Comparator<T>这种就称为参数化类型（Parameterized Types）。</p>
</li>
</ul>
<p>自从有了泛型之后，Java的数据类型就更丰富了：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173354.png" alt="image-20200521081637509"></p>
<p>Class：<code>Class</code> 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class  对象的一个类，所有具有相同元素类型和维数的数组都共享该 <code>Class</code> 对象。基本的 Java  类型（<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>  和 <code>double</code>）和关键字 <code>void</code> 也表示为 <code>Class</code> 对象。 </p>
<ul>
<li>GenericArrayType：泛化的数组类型，即T[]</li>
<li>ParameterizedType：参数化类型，例如：Comparator<T>，Comparator<String></li>
<li>TypeVariable：类型变量，例如：Comparator<T>中的T，Map&lt;K,V&gt;中的K,V</li>
<li>WildcardType：通配符类型，例如：Comparator&lt;?&gt;等</li>
</ul>
<h3 id="在哪里可以声明类型变量-lt-T-gt"><a href="#在哪里可以声明类型变量-lt-T-gt" class="headerlink" title="在哪里可以声明类型变量&lt;T&gt;"></a>在哪里可以声明类型变量&lt;T&gt;</h3><ul>
<li>声明类或接口时，在类名或接口名后面声明类型变量，我们把这样的类或接口称为泛型类或泛型接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名&lt;类型变量列表&gt; 【<span class="keyword">extends</span> 父类】 【<span class="keyword">implements</span> 父接口们】</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">interface</span> 接口名&lt;类型变量列表&gt; 【<span class="keyword">implements</span> 父接口们】</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;    </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<ul>
<li>声明方法时，在【修饰符】与返回值类型之间声明类型变量，我们把声明（是<font color='red'><strong>声明</strong></font>不是单纯的使用）了类型变量的方法称为泛型方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 &lt;类型变量列表&gt; 返回值类型 方法名(【形参列表】)【<span class="keyword">throws</span> 异常列表】&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例如：java.util.Arrays类中的</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参数类型：泛型类与泛型接口"><a href="#参数类型：泛型类与泛型接口" class="headerlink" title="参数类型：泛型类与泛型接口"></a>参数类型：泛型类与泛型接口</h2><p>当我们在声明类或接口时，类或接口中定义某个成员时，该成员有些类型是不确定的，而这个类型需要在使用这个类或接口时才可以确定，那么我们可以使用泛型。</p>
<h3 id="声明泛型类与泛型接口"><a href="#声明泛型类与泛型接口" class="headerlink" title="声明泛型类与泛型接口"></a>声明泛型类与泛型接口</h3><p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名&lt;类型变量列表&gt; 【<span class="keyword">extends</span> 父类】 【<span class="keyword">implements</span> 父接口们】</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">interface</span> 接口名&lt;类型变量列表&gt; 【<span class="keyword">implements</span> 父接口们】</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>&lt;类型变量列表&gt;：可以是一个或多个类型变量，一般都是使用单个的大写字母表示。例如：<T>、&lt;K,V&gt;等。</li>
<li>&lt;类型变量列表&gt;中的类型变量不能用于静态成员上。</li>
</ul>
<p>什么时候使用泛型类或泛型接口呢？</p>
<ul>
<li>当某个类的非静态实例变量的类型不确定，需要在创建对象或子类继承时才能确定</li>
<li>当某个（些）类的非静态方法的形参类型不确定，需要在创建对象或子类继承时才能确定</li>
</ul>
<p>示例代码：</p>
<p>例如：我们要声明一个学生类，该学生包含姓名、成绩，而此时学生的成绩类型不确定，为什么呢，因为，语文老师希望成绩是“优秀”、“良好”、“及格”、“不及格”，数学老师希望成绩是89.5, 65.0，英语老师希望成绩是’A’,’B’,’C’,’D’,’E’。那么我们在设计这个学生类时，就可以使用泛型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> T score;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, T score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(T score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;, 成绩：&quot;</span> + score;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用泛型类与泛型接口"><a href="#使用泛型类与泛型接口" class="headerlink" title="使用泛型类与泛型接口"></a>使用泛型类与泛型接口</h3><p>在使用这种参数化的类与接口时，我们需要指定泛型变量的实际类型参数：</p>
<p>（1）实际类型参数必须是引用数据类型，不能是基本数据类型</p>
<p>（2）在创建类的对象时指定类型变量对应的实际类型参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//语文老师使用时：</span></span><br><span class="line">		Student&lt;String&gt; stu1 = <span class="keyword">new</span> Student&lt;String&gt;(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;良好&quot;</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//数学老师使用时：</span></span><br><span class="line">        <span class="comment">//Student&lt;double&gt; stu2 = new Student&lt;double&gt;(&quot;张三&quot;, 90.5);//错误，必须是引用数据类型</span></span><br><span class="line">		Student&lt;Double&gt; stu2 = <span class="keyword">new</span> Student&lt;Double&gt;(<span class="string">&quot;张三&quot;</span>, <span class="number">90.5</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//英语老师使用时：</span></span><br><span class="line">		Student&lt;Character&gt; stu3 = <span class="keyword">new</span> Student&lt;Character&gt;(<span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//错误的指定</span></span><br><span class="line">        <span class="comment">//Student&lt;Object&gt; stu = new Student&lt;String&gt;();//错误的</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JDK1.7支持简写形式：Student<String> stu1 = new Student&lt;&gt;(“张三”, “良好”);</p>
<p>指定泛型实参时，必须左右两边一致，不存在多态现象</p>
</blockquote>
<p>（3）在继承泛型类或实现泛型接口时，指定类型变量对应的实际类型参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseStudent</span> <span class="keyword">extends</span> <span class="title">Student</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ChineseStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ChineseStudent</span><span class="params">(String name, String score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, score);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//语文老师使用时：</span></span><br><span class="line">		ChineseStudent stu = <span class="keyword">new</span> ChineseStudent(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;良好&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Circle</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> radius;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Circle [radius=&quot;</span> + radius + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Circle c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(radius,c.radius);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型变量的上限"><a href="#类型变量的上限" class="headerlink" title="类型变量的上限"></a>类型变量的上限</h3><p>当在声明类型变量时，如果不希望这个类型变量代表任意引用数据类型，而是某个系列的引用数据类型，那么可以设定类型变量的上限。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;类型变量  extends 上限&gt;</span><br></pre></td></tr></table></figure>

<p>如果有多个上限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;类型变量  extends 上限1 &amp; 上限2&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果多个上限中有类有接口，那么只能有一个类，而且必须写在最左边。接口的话，可以多个。</p>
<p>如果在声明&lt;类型变量&gt;时没有指定任何上限，默认上限是java.lang.Object。</p>
</blockquote>
<p>例如：我们要声明一个两个数求和的工具类，要求两个加数必须是Number数字类型，并且实现Comparable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTools</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T a;</span><br><span class="line">	<span class="keyword">private</span> T b;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SumTools</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.a = a;</span><br><span class="line">		<span class="keyword">this</span>.b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(a <span class="keyword">instanceof</span> BigInteger)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T) ((BigInteger) a).add((BigInteger)b);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> BigDecimal)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T) ((BigDecimal) a).add((BigDecimal)b);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)(Integer.valueOf((Integer)a+(Integer)b));</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Long)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)(Long.valueOf((Long)a+(Long)b));</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Float)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)(Float.valueOf((Float)a+(Float)b));</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Double)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)(Double.valueOf((Double)a+(Double)b));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;不支持该操作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SumTools&lt;Integer&gt; s = <span class="keyword">new</span> SumTools&lt;Integer&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">		Integer sum = s.getSum();</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		SumTools&lt;String&gt; s = new SumTools&lt;String&gt;(&quot;1&quot;,&quot;2&quot;);//错误，因为String类型不是extends Number</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>当使用参数化类型的类或接口时，如果没有指定泛型，那么会怎么样呢？</p>
<p>会发生泛型擦除，自动按照最左边的第一个上限处理。如果没有指定上限，上限即为Object。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	SumTools s = <span class="keyword">new</span> SumTools(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">	Number sum = s.getSum();</span><br><span class="line">	System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//强制类型转换</span></span><br><span class="line">		Circle c1 = (Circle) o1;</span><br><span class="line">		Circle c2 = (Circle) o2;</span><br><span class="line">		<span class="keyword">return</span> Double.compare(c1.getRadius(), c2.getRadius());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1-1"><a href="#练习1-1" class="headerlink" title="练习1"></a>练习1</h4><p>1、声明一个坐标类Coordinate<T>，它有两个属性：x,y，都为T类型<br>2、在测试类中，创建两个不同的坐标类对象，<br>分别指定T类型为String和Double，并为x,y赋值，打印对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExer1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Coordinate&lt;String&gt; c1 = <span class="keyword">new</span> Coordinate&lt;&gt;(<span class="string">&quot;北纬38.6&quot;</span>, <span class="string">&quot;东经36.8&quot;</span>);</span><br><span class="line">		System.out.println(c1);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		Coordinate&lt;Double&gt; c2 = new Coordinate&lt;&gt;(38.6, 38);//自动装箱与拆箱只能与对应的类型 38是int，自动装为Integer</span></span><br><span class="line">		Coordinate&lt;Double&gt; c2 = <span class="keyword">new</span> Coordinate&lt;&gt;(<span class="number">38.6</span>, <span class="number">36.8</span>);</span><br><span class="line">		System.out.println(c2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T x;</span><br><span class="line">	<span class="keyword">private</span> T y;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Coordinate</span><span class="params">(T x, T y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Coordinate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(T y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Coordinate [x=&quot;</span> + x + <span class="string">&quot;, y=&quot;</span> + y + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2"></a>练习2</h4><p>1、声明一个Person类，包含姓名和伴侣属性，其中姓名是String类型，而伴侣的类型不确定，<br>因为伴侣可以是Person，可以是Animal（例如：金刚），可以是Ghost鬼（例如：倩女幽魂），<br>可以是Demon妖（例如：白娘子），可以是Robot机器人（例如：剪刀手爱德华）。。。</p>
<p>2、在测试类中，创建Person对象，并为它指定伴侣，打印显示信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExer3</span> </span>&#123;</span><br><span class="line">	<span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person&lt;Demon&gt; xu = <span class="keyword">new</span> Person&lt;Demon&gt;(<span class="string">&quot;许仙&quot;</span>,<span class="keyword">new</span> Demon(<span class="string">&quot;白娘子&quot;</span>));</span><br><span class="line">		System.out.println(xu);</span><br><span class="line">		</span><br><span class="line">		Person&lt;Person&gt; xie = <span class="keyword">new</span> Person&lt;Person&gt;(<span class="string">&quot;谢学建&quot;</span>,<span class="keyword">new</span> Person(<span class="string">&quot;徐余龙&quot;</span>));</span><br><span class="line">		Person fere = xie.getFere();</span><br><span class="line">		fere.setFere(xie);</span><br><span class="line">		System.out.println(xie);</span><br><span class="line">		System.out.println(fere);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demon</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Demon</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Demon [name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> T fere;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, T fere)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.fere = fere;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getFere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fere;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFere</span><span class="params">(T fere)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.fere = fere;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(fere <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">			Person p = (Person) fere;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, fere=&quot;</span> + p.getName() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, fere=&quot;</span> + fere + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h4><p>1、声明员工类型Employee，包含姓名（String），薪资（double），年龄（int）</p>
<p>2、员工类Employee实现java.lang.Comparable<T>接口，指定T为Employee类型，重写抽象方法，按照薪资比较大小，薪资相同的按照姓名的自然顺序比较大小。</p>
<p>3、在测试类中创建Employee数组，然后调用Arrays.sort(Object[] arr)方法进行排序，遍历显示员工信息</p>
<p>4、再次调用Arrays.sort(Object[] arr,Comparator<T> c)方法进行按照年龄排序，年龄相同的安装姓名自然顺序比较大小，遍历显示员工信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExer3</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Employee[] arr = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">		arr[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Irene&quot;</span>, <span class="number">18000</span>, <span class="number">18</span>);</span><br><span class="line">		arr[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Jack&quot;</span>, <span class="number">14000</span>, <span class="number">28</span>);</span><br><span class="line">		arr[<span class="number">2</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Alice&quot;</span>, <span class="number">14000</span>, <span class="number">24</span>);</span><br><span class="line">		</span><br><span class="line">		Arrays.sort(arr);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.println(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Employee[] arr = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">		arr[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Irene&quot;</span>, <span class="number">18000</span>, <span class="number">18</span>);</span><br><span class="line">		arr[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Jack&quot;</span>, <span class="number">14000</span>, <span class="number">28</span>);</span><br><span class="line">		arr[<span class="number">2</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Alice&quot;</span>, <span class="number">14000</span>, <span class="number">24</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//Arrays.sort(T[] arr,Comparator&lt;T&gt; c)</span></span><br><span class="line">		Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;Employee&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//按照年龄排序，年龄相同的安装姓名自然顺序比较大小</span></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Employee o1, Employee o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(o1.getAge() != o2.getAge()) &#123;</span><br><span class="line">					<span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.println(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.salary = salary;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Employee [name=&quot;</span> + name + <span class="string">&quot;, salary=&quot;</span> + salary + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//重写抽象方法，按照薪资比较大小，薪资相同的按照姓名的自然顺序比较大小。</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.salary != o.salary) &#123;</span><br><span class="line">			<span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.salary, o.salary);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(o.name);<span class="comment">//name是String类型，有compareTo方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>前面介绍了在定义类、接口时可以声明&lt;类型变量&gt;，在该类的方法和属性定义、接口的方法定义中，这些&lt;类型变量&gt;可被当成普通类型来用。但是，在另外一些情况下，</p>
<p>（1）如果我们定义类、接口时没有使用&lt;类型变量&gt;，但是某个方法形参类型不确定时，可以单独这个方法定义&lt;类型变量&gt;；</p>
<p>（2）另外我们之前说类和接口上的类型形参是不能用于静态方法中，那么当某个静态方法的形参类型不确定时，可以单独定义&lt;类型变量&gt;。</p>
<p>那么，JDK1.5之后，还提供了泛型方法的支持。</p>
<p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 &lt;类型变量列表&gt; 返回值类型 方法名(【形参列表】)【<span class="keyword">throws</span> 异常列表】&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;类型变量列表&gt;：可以是一个或多个类型变量，一般都是使用单个的大写字母表示。例如：<T>、&lt;K,V&gt;等。</li>
<li>&lt;类型变量&gt;同样也可以指定上限</li>
</ul>
<p>示例代码：</p>
<p>我们编写一个数组工具类，包含可以给任意对象数组进行从小到大排序，要求数组元素类型必须实现Comparable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrays</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-i; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j].compareTo(arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					T temp = arr[j];</span><br><span class="line">					arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//		MyArrays.sort(arr);//错误的，因为int[]不是对象数组</span></span><br><span class="line">		</span><br><span class="line">		String[] strings = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;chai&quot;</span>&#125;;</span><br><span class="line">		MyArrays.sort(strings);</span><br><span class="line">		System.out.println(Arrays.toString(strings));</span><br><span class="line">		</span><br><span class="line">		Circle[] circles = &#123;<span class="keyword">new</span> Circle(<span class="number">2.0</span>),<span class="keyword">new</span> Circle(<span class="number">1.2</span>),<span class="keyword">new</span> Circle(<span class="number">3.0</span>)&#125;;</span><br><span class="line">		MyArrays.sort(circles);</span><br><span class="line">		System.out.println(Arrays.toString(circles));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h2><p>当我们声明一个变量/形参时，这个变量/形参的类型是一个泛型类或泛型接口，例如：Comparator<T>类型，但是我们仍然无法确定这个泛型类或泛型接口的类型变量<T>的具体类型，此时我们考虑使用类型通配符。</p>
<p>例如：</p>
<p>这个学生类是一个参数化的泛型类，代码如下（详细请看$12.2.1中的示例说明）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> T score;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, T score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(T score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;, 成绩：&quot;</span> + score;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lt-gt-任意类型"><a href="#lt-gt-任意类型" class="headerlink" title="&lt;?&gt;任意类型"></a>&lt;?&gt;任意类型</h3><p>例如：我们要声明一个学生管理类，这个管理类要包含一个方法，可以遍历学生数组。</p>
<p>学生管理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Student&lt;?&gt;[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.println(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 语文老师使用时：</span></span><br><span class="line">		Student&lt;String&gt; stu1 = <span class="keyword">new</span> Student&lt;String&gt;(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;良好&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 数学老师使用时：</span></span><br><span class="line">		<span class="comment">// Student&lt;double&gt; stu2 = new Student&lt;double&gt;(&quot;张三&quot;, 90.5);//错误，必须是引用数据类型</span></span><br><span class="line">		Student&lt;Double&gt; stu2 = <span class="keyword">new</span> Student&lt;Double&gt;(<span class="string">&quot;张三&quot;</span>, <span class="number">90.5</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 英语老师使用时：</span></span><br><span class="line">		Student&lt;Character&gt; stu3 = <span class="keyword">new</span> Student&lt;Character&gt;(<span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		Student&lt;?&gt;[] arr = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">		arr[<span class="number">0</span>] = stu1;</span><br><span class="line">		arr[<span class="number">1</span>] = stu2;</span><br><span class="line">		arr[<span class="number">2</span>] = stu3;</span><br><span class="line"></span><br><span class="line">		StudentService.print(arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lt-extends-上限-gt"><a href="#lt-extends-上限-gt" class="headerlink" title="&lt;? extends 上限&gt;"></a>&lt;? extends 上限&gt;</h3><p>例如：我们要声明一个学生管理类，这个管理类要包含一个方法，找出学生数组中成绩最高的学生对象。</p>
<p>要求学生的成绩的类型必须可比较大小，实现Comparable接口。</p>
<p>学生管理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Student&lt;? extends Comparable&gt; max(Student&lt;? extends Comparable&gt;[] arr)&#123;</span><br><span class="line">		Student&lt;? extends Comparable&gt; max = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i].getScore().compareTo(max.getScore())&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				max = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">	<span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Student&lt;? extends Double&gt;[] arr = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">		arr[<span class="number">0</span>] = <span class="keyword">new</span> Student&lt;Double&gt;(<span class="string">&quot;张三&quot;</span>, <span class="number">90.5</span>);</span><br><span class="line">		arr[<span class="number">1</span>] = <span class="keyword">new</span> Student&lt;Double&gt;(<span class="string">&quot;李四&quot;</span>, <span class="number">80.5</span>);</span><br><span class="line">		arr[<span class="number">2</span>] = <span class="keyword">new</span> Student&lt;Double&gt;(<span class="string">&quot;王五&quot;</span>, <span class="number">94.5</span>);</span><br><span class="line">		</span><br><span class="line">		Student&lt;? extends Comparable&gt; max = StudentService.max(arr);</span><br><span class="line">		System.out.println(max);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lt-super-下限-gt"><a href="#lt-super-下限-gt" class="headerlink" title="&lt;? super 下限&gt;"></a>&lt;? super 下限&gt;</h3><p>现在要声明一个数组工具类，包含可以给任意对象数组进行从小到大排序，只要你指定定制比较器对象，而且这个定制比较器对象可以是当前数组元素类型自己或其父类的定制比较器对象</p>
<p>数组工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArrays</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-i; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(c.compare(arr[j], arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					T temp = arr[j];</span><br><span class="line">					arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：有如下JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, age);</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">&quot;,score=&quot;</span> + score;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Student[] all = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">		all[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="number">89</span>);</span><br><span class="line">		all[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>, <span class="number">99</span>);</span><br><span class="line">		all[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">&quot;王五&quot;</span>, <span class="number">25</span>, <span class="number">67</span>);</span><br><span class="line">		</span><br><span class="line">		MyArrays.sort(all, <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">		</span><br><span class="line">		MyArrays.sort(all, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> o1.getScore() - o2.getScore();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 使用类型通配符来指定类型参数的问题</span><br><span class="line"></span><br><span class="line">&lt;?&gt;：不可变，因为&lt;?&gt;类型不确定，编译时，任意类型都是错</span><br><span class="line"></span><br><span class="line">&lt;? extends 上限&gt;：因为&lt;? extends 上限&gt;的?可能是上限或上限的子类，即类型不确定，编译按任意类型处理都是错。</span><br><span class="line"></span><br><span class="line">&lt;? super 下限&gt;：可以将值修改为下限或下限子类的对象，因为&lt;? super 下限&gt;?代表是下限或下限的父类，那么设置为下限或下限子类的对象是安全的。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class TestGeneric &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Student&lt;?&gt; stu1 = new Student&lt;&gt;();</span><br><span class="line">		stu1.setScore(null);//除了null，无法设置为其他值</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Student&lt;? extends Number&gt; stu2 = new Student&lt;&gt;();</span><br><span class="line">		stu2.setScore(null);//除了null，无法设置为其他值</span><br><span class="line">		</span><br><span class="line">		Student&lt;? super Number&gt; stu3 = new Student&lt;&gt;();</span><br><span class="line">		stu3.setScore(56);//可以设置Number或其子类的对象</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student&lt;T&gt;&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private T score;</span><br><span class="line">	</span><br><span class="line">	public Student() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">	public Student(String name, T score) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	public T getScore() &#123;</span><br><span class="line">		return score;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setScore(T score) &#123;</span><br><span class="line">		this.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;姓名：&quot; + name + &quot;, 成绩：&quot; + score;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 练习</span><br><span class="line">在数组工具类中声明如下泛型方法：</span><br><span class="line"></span><br><span class="line">（1）可以在任意类型的对象数组中，查找某个元素的下标，按照顺序查找，如果有重复的，就返回第一个找到的，如果没有返回-1</span><br><span class="line"></span><br><span class="line">（2）可以在任意类型的对象数组中，查找最大值，要求元素必须实现Comparable接口</span><br><span class="line"></span><br><span class="line">（3）可以在任意类型的对象数组中，查找最大值，按照指定定制比较器来比较元素大小</span><br><span class="line"></span><br><span class="line">（4）可以给任意对象数组进行从小到大排序，要求数组元素类型必须实现Comparable接口</span><br><span class="line"></span><br><span class="line">（5）可以给任意对象数组进行从小到大排序，只要你指定定制比较器对象，不要求数组元素实现Comparable接口</span><br><span class="line"></span><br><span class="line">（6）可以将任意对象数组的元素拼接为一个字符串返回</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class MyArrays &#123;</span><br><span class="line">	//可以在任意类型的对象数组中，查找某个元素的下标，按照顺序查找，如果有重复的，就返回第一个找到的，如果没有返回-1</span><br><span class="line">	public static &lt;T&gt; int find(T[] arr, T value) &#123;</span><br><span class="line">		for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">			if(arr[i].equals(value)) &#123;//使用==比较太严格，使用equals方法，因为任意对象都有equals方法</span><br><span class="line">				return i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//可以在任意类型的对象数组中，查找最大值，要求元素必须实现Comparable接口</span><br><span class="line">	public static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(T[] arr) &#123;</span><br><span class="line">		T max = arr[0];</span><br><span class="line">		for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">			if(max.compareTo(arr[i])&lt;0) &#123;//if(max &lt; arr[i]) &#123;</span><br><span class="line">				max = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return max;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//可以在任意类型的对象数组中，查找最大值，按照指定定制比较器来比较元素大小</span><br><span class="line">	public static &lt;T&gt; T max(T[] arr, Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">		T max = arr[0];</span><br><span class="line">		for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">			if(c.compare(max, arr[i])&lt;0) &#123;//if(max &lt; arr[i]) &#123;</span><br><span class="line">				max = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return max;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//可以给任意对象数组进行从小到大排序，要求数组元素类型必须实现Comparable接口</span><br><span class="line">	public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(T[] arr) &#123;</span><br><span class="line">		for (int i = 0; i &lt; arr.length-1; i++) &#123;</span><br><span class="line">			int minIndex = i;</span><br><span class="line">			for (int j = i+1; j &lt; arr.length; j++) &#123;</span><br><span class="line">				if(arr[minIndex].compareTo(arr[j])&gt;0) &#123;</span><br><span class="line">					minIndex = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(minIndex!=i) &#123;</span><br><span class="line">				T temp = arr[minIndex];</span><br><span class="line">				arr[minIndex] = arr[i];</span><br><span class="line">				arr[i] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//可以给任意对象数组进行从小到大排序，只要你指定定制比较器对象，不要求数组元素实现Comparable接口</span><br><span class="line">	public static &lt;T&gt; void sort(T[] arr, Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">		for (int i = 0; i &lt; arr.length-1; i++) &#123;</span><br><span class="line">			int minIndex = i;</span><br><span class="line">			for (int j = i+1; j &lt; arr.length; j++) &#123;</span><br><span class="line">				if(c.compare(arr[minIndex],arr[j])&gt;0) &#123;</span><br><span class="line">					minIndex = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(minIndex!=i) &#123;</span><br><span class="line">				T temp = arr[minIndex];</span><br><span class="line">				arr[minIndex] = arr[i];</span><br><span class="line">				arr[i] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//可以将任意对象数组的元素拼接为一个字符串返回</span><br><span class="line">	public static &lt;T&gt; String toString(T[] arr) &#123;</span><br><span class="line">		String str = &quot;[&quot;;</span><br><span class="line">		for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">			if(i==0) &#123;</span><br><span class="line">				str += arr[i];</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				str += &quot;,&quot; + arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		str += &quot;]&quot;;</span><br><span class="line">		return str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>数据结构</strong>就是研究数据的<strong>逻辑结构和物理结构</strong>以及它们之间相互关系，并对这种结构定义<strong>相应的运算</strong>，而且确保经过这些运算后所得到的新结构仍然是原来的结构类型。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173623.png" alt="1572588929059"></p>
<p>数据的逻辑结构指反映数据元素之间的逻辑关系，而与他们在计算机中的存储位置无关：</p>
<ul>
<li>集合（数学中集合的概念）：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系；</li>
<li>线性结构：数据结构中的元素存在一对一的相互关系；</li>
<li>树形结构：数据结构中的元素存在一对多的相互关系；</li>
<li>图形结构：数据结构中的元素存在多对多的相互关系。</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173626.png" alt="1572589085415"></p>
<p>数据的物理结构/存储结构：是描述数据具体在内存中的存储（如：顺序结构、链式结构、索引结构、哈希结构）等，一种数据逻辑结构可表示成一种或多种物理存储结构。</p>
<p>数据结构和算法是一门完整并且复杂的课程，那么我们今天只是简单的讨论常见的几种数据结构，让我们对数据结构与算法有一个初步的了解。</p>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h3 id="动态数组的特点"><a href="#动态数组的特点" class="headerlink" title="动态数组的特点"></a>动态数组的特点</h3><p>逻辑结构：线性的</p>
<p>物理结构：顺序结构</p>
<p>申请内存：一次申请一大段连续的空间，一旦申请到了，内存就固定了。</p>
<p>存储特点：所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔。</p>
<p>例如：整型数组</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173633.png" alt="1563432676234"></p>
<p>例如：对象数组</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173636.png" alt="1563432696340"></p>
<h3 id="动态数组的基本操作"><a href="#动态数组的基本操作" class="headerlink" title="动态数组的基本操作"></a>动态数组的基本操作</h3><p>与数据结构相关的数据操作：</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>修改</li>
<li>查找</li>
<li>遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index,E value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(E e)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">	<span class="function">E <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, E value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(E old, E value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E e)</span></span>;</span><br><span class="line">	<span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">	Object[] getAll();</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态数组实现"><a href="#动态数组实现" class="headerlink" title="动态数组实现"></a>动态数组实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Container</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object[] all;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">		all = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">		ensureCapacityEnough();</span><br><span class="line">		all[total++] = e;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(total &gt;= all.length)&#123;</span><br><span class="line">			all = Arrays.copyOf(all, all.length*<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, E value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//是否需要扩容</span></span><br><span class="line">		ensureCapacityEnough();</span><br><span class="line">		addCheckIndex(index);</span><br><span class="line">		<span class="keyword">if</span>(total-index&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			System.arraycopy(all, index, all, index+<span class="number">1</span>, total-index);</span><br><span class="line">		&#125;</span><br><span class="line">		all[index]=value;</span><br><span class="line">		total++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCheckIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;total)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(index+<span class="string">&quot;越界&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = indexOf(e);</span><br><span class="line">		<span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(e+<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		delete(index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		checkIndex(index);</span><br><span class="line">		<span class="keyword">if</span>(total-index-<span class="number">1</span>&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			System.arraycopy(all, index+<span class="number">1</span>, all, index, total-index-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		all[--total] = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;total)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(index+<span class="string">&quot;越界&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, E value)</span> </span>&#123;</span><br><span class="line">		checkIndex(index);</span><br><span class="line">		E oldValue = get(index);</span><br><span class="line">		all[index]=value;</span><br><span class="line">		<span class="keyword">return</span> oldValue;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(E old, E value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = indexOf(old);</span><br><span class="line">		<span class="keyword">if</span>(index!=-<span class="number">1</span>)&#123;</span><br><span class="line">			update(index, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> indexOf(e) != -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(e==<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(e == all[i])&#123;</span><br><span class="line">					index = i;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(e.equals(all[i]))&#123;</span><br><span class="line">					index = i;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		checkIndex(index);</span><br><span class="line">		<span class="keyword">return</span> (E) all[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object[] getAll() &#123;</span><br><span class="line">		<span class="keyword">return</span> Arrays.copyOf(all, total);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> cursor!=total;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (E) all[cursor++];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			MyArrayList.<span class="keyword">this</span>.delete(--cursor);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态数组测试"><a href="#动态数组测试" class="headerlink" title="动态数组测试"></a>动态数组测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyArrayList</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">		MyArrayList&lt;String&gt; my = <span class="keyword">new</span> MyArrayList&lt;String&gt;();</span><br><span class="line">		my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + my.size());</span><br><span class="line">		Object[] all = my.getAll();</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">		</span><br><span class="line">		my.insert(<span class="number">2</span>, <span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + my.size());</span><br><span class="line">		all = my.getAll();</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">		MyArrayList&lt;String&gt; my = <span class="keyword">new</span> MyArrayList&lt;String&gt;();</span><br><span class="line">		my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		my.delete(<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + my.size());</span><br><span class="line">		Object[] all = my.getAll();</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">		</span><br><span class="line">		my.delete(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + my.size());</span><br><span class="line">		all = my.getAll();</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">		MyArrayList&lt;String&gt; my = <span class="keyword">new</span> MyArrayList&lt;String&gt;();</span><br><span class="line">		my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		String update = my.update(<span class="number">3</span>, <span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + my.size());</span><br><span class="line">		System.out.println(<span class="string">&quot;被替换的是：&quot;</span> + update);</span><br><span class="line">		Object[] all = my.getAll();</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">		</span><br><span class="line">		my.update(<span class="string">&quot;java&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + my.size());</span><br><span class="line">		System.out.println(<span class="string">&quot;被替换的是：java&quot;</span>);</span><br><span class="line">		all = my.getAll();</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">		MyArrayList&lt;String&gt; my = <span class="keyword">new</span> MyArrayList&lt;String&gt;();</span><br><span class="line">		my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(my.contains(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">		System.out.println(my.indexOf(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">		System.out.println(my.get(<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">		MyArrayList&lt;String&gt; my = <span class="keyword">new</span> MyArrayList&lt;String&gt;();</span><br><span class="line">		my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (String string : my) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">		MyArrayList&lt;String&gt; my = <span class="keyword">new</span> MyArrayList&lt;String&gt;();</span><br><span class="line">		my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		Iterator&lt;String&gt; iterator = my.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			String next = iterator.next();</span><br><span class="line">			<span class="keyword">if</span>(next.length()&gt;<span class="number">4</span>) &#123;</span><br><span class="line">				iterator.remove();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String string : my) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java核心类库中的动态数组"><a href="#Java核心类库中的动态数组" class="headerlink" title="Java核心类库中的动态数组"></a>Java核心类库中的动态数组</h3><p>Java的List接口的实现类中有两个动态数组的实现：Vector和ArrayList。</p>
<h4 id="ArrayList与Vector的区别？"><a href="#ArrayList与Vector的区别？" class="headerlink" title="ArrayList与Vector的区别？"></a>ArrayList与Vector的区别？</h4><p>它们的底层物理结构都是数组，我们称为动态数组。</p>
<ul>
<li>ArrayList是新版的动态数组，线程不安全，效率高，Vector是旧版的动态数组，线程安全，效率低。</li>
<li>动态数组的扩容机制不同，ArrayList扩容为原来的1.5倍，Vector扩容增加为原来的2倍。</li>
<li>数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，没有显式指定初始化容量，那么Vector的内部数组的初始容量默认为10，而ArrayList在JDK1.6及之前的版本也是10，而JDK1.7之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组。</li>
<li>Vector因为版本古老，支持Enumeration 迭代器。但是该迭代器不支持快速失败。而Iterator和ListIterator迭代器支持快速失败。如果在迭代器创建后的任意时间从结构上修改了向量（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，而不是冒着在将来不确定的时间任意发生不确定行为的风险。</li>
</ul>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="Vector源码分析"><a href="#Vector源码分析" class="headerlink" title="Vector源码分析"></a>Vector源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量initialCapacity为10</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);<span class="comment">//指定capacityIncrement增量为0</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement增量为<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       <span class="comment">//判断了形参初始容量initialCapacity的合法性</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="comment">//创建了一个Object[]类型的数组</span></span><br><span class="line">       <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//默认是10</span></span><br><span class="line">       <span class="comment">//增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量</span></span><br><span class="line">       <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//synchronized意味着线程安全的   </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">    	<span class="comment">//看是否需要扩容</span></span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//把新的元素存入[elementCount]，存入后，elementCount元素的个数增1</span></span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">//看是否超过了当前数组的容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);<span class="comment">//扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//获取目前数组的长度</span></span><br><span class="line">        <span class="comment">//如果capacityIncrement增量是0，新容量 = oldCapacity的2倍</span></span><br><span class="line">        <span class="comment">//如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果新容量超过了最大数组限制，那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把旧数组中的数据复制到新数组中，新数组的长度为newCapacity</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//查找obj在当前Vector中的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">    <span class="comment">//如果i&gt;=0，说明存在，删除[i]位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//要查找的元素是null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)<span class="comment">//如果是null值，用==null判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//要查找的元素是非null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//如果是非null值，用equals判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//判断下标的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">&quot; &gt;= &quot;</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//j是要移动的元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果需要移动元素，就调用System.arraycopy进行移动</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//把index+1位置以及后面的元素往前移动</span></span><br><span class="line">        <span class="comment">//index+1的位置的元素移动到index位置，依次类推</span></span><br><span class="line">        <span class="comment">//一共移动j个</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的总个数减少</span></span><br><span class="line">    elementCount--;</span><br><span class="line">    <span class="comment">//将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收</span></span><br><span class="line">    elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h5><p>JDK1.6：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量为10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">      <span class="comment">//检查初始容量的合法性</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      <span class="comment">//数组初始化为长度为initialCapacity的数组</span></span><br><span class="line"><span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认初始容量10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//数组初始化为一个空数组</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;<span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">           <span class="comment">//minCapacity按照 默认初始容量和minCapacity中的的最大值处理</span></span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//看是否需要扩容处理</span></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>JDK1.8</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//初始化为空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存入新元素到[size]位置，然后size自增1</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">//那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//查看是否需要扩容</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要的最小容量  比  当前数组的长度  大，即当前数组不够存，就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//当前数组容量</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">        <span class="comment">//看旧数组的1.5倍是否够</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//看旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复制一个新数组</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先找到o在当前ArrayList的数组中的下标</span></span><br><span class="line">    <span class="comment">//分o是否为空两种情况讨论</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;<span class="comment">//null值用==比较</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;<span class="comment">//非null值用equals比较</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">    <span class="comment">//需要移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">      modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span></span><br><span class="line">      E oldValue = elementData(index);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//需要移动的元素个数</span></span><br><span class="line">      <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">      elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">//用element替换[index]位置的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);<span class="comment">//返回[index]位置的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从前往后找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从后往前找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p>逻辑结构：有线性的和非线性的</p>
<p>物理结构：不要求连续的存储空间</p>
<p>存储特点：数据必须封装到“结点”中，结点包含多个数据项，数据值只是其中的一个数据项，其他的数据项用来记录与之有关的结点的地址。</p>
<p>例如：以下列出几种常见的链式存储结构（当然远不止这些）</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173718.png" alt="1563448858180"></p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表结点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	Object data;</span><br><span class="line">	Node next;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data, Node next)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">		<span class="keyword">this</span>.next = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单链表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneWayLinkedList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Node&lt;E&gt; head;<span class="comment">//头结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total;<span class="comment">//记录实际元素个数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">		E data;</span><br><span class="line">		Node&lt;E&gt; next;</span><br><span class="line">		Node(E data, Node&lt;E&gt; next) &#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>双链表结点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	Node prev;</span><br><span class="line">	Object data;</span><br><span class="line">	Node next;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node prev, Object data, Node next)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.prev = prev;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">		<span class="keyword">this</span>.next = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双向链表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Node&lt;E&gt; first;<span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; last;<span class="comment">//尾结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total;<span class="comment">//记录实际元素个数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">		E data;</span><br><span class="line">		Node&lt;E&gt; next;</span><br><span class="line">		Node(Node&lt;E&gt; prev, E data, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173735.png" alt="1563449427345"></p>
<h4 id="二叉树实现基本结构"><a href="#二叉树实现基本结构" class="headerlink" title="二叉树实现基本结构"></a>二叉树实现基本结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	Node parent;</span><br><span class="line">	Node left;</span><br><span class="line">	Object data;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node parent,Node left, Object data, Node right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.parent = parent;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">        Node&lt;E&gt; parent;</span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        E data;</span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node&lt;E&gt; parent, Node&lt;E&gt; left, E data, Node&lt;E&gt; right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树分类"><a href="#二叉树分类" class="headerlink" title="二叉树分类"></a>二叉树分类</h4><ul>
<li><p>满二叉树： 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 第n层的结点数是2的n-1次方，2的n次方-1</p>
<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173732.png" alt="1574575163883"></p>
</li>
<li><p>完全二叉树： 叶结点只能出现在最底层的两层，且最底层叶结点均处于次底层叶结点的左侧。</p>
<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173741.png" alt="1574575180247"></p>
</li>
<li><p>平衡二叉树：平衡二叉树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树， 但不要求非叶节点都有两个子结点 。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci(斐波那契)数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。</p>
</li>
</ul>
<p>例如：斐波那契数列（Fibonacci）：1，1，2，3，5，8，13…..</p>
<p>规律：除了第一个和第二个数以外，后面的数等于前两个数之和，</p>
<p>​    f(0) =1，</p>
<p>​    f(1) = 1，</p>
<p>​    f(2) = f(0) + f(1) =2，</p>
<p>​    f(3) = f(1) + f(2) = 3, </p>
<p>​    f(4) = f(2) + f(3) = 5</p>
<p>​    …</p>
<p>​    f(n) = f(n-2) + f(n-1);</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173744.png" alt="1574575518730"></p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173747.png" alt="1574575739236"></p>
<p>前序遍历：ABDHIECFG</p>
<p>中序遍历：HDIBEAFCG</p>
<p>后序遍历：HIDEBFGCA</p>
<h2 id="单链表-1"><a href="#单链表-1" class="headerlink" title="单链表"></a>单链表</h2><h3 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h3><p>逻辑结构：单向链表</p>
<p>物理结构：链式顺序结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneWayLinkedList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Node&lt;E&gt; head;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">		E data;</span><br><span class="line">		Node&lt;E&gt; next;</span><br><span class="line">		Node(E data, Node&lt;E&gt; next) &#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">		Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(e,<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">			head = newNode;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			Node&lt;E&gt; node = head;</span><br><span class="line">			<span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">				node = node.next;</span><br><span class="line">			&#125;</span><br><span class="line">			node.next = newNode;</span><br><span class="line">		&#125;</span><br><span class="line">		total++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">		Node&lt;E&gt; node = head;</span><br><span class="line">		Node&lt;E&gt; find = <span class="keyword">null</span>;</span><br><span class="line">		Node&lt;E&gt; last = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(e==<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(node.data==<span class="keyword">null</span>)&#123;</span><br><span class="line">					find = node;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				last = node;</span><br><span class="line">				node = node.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(e.equals(node.data))&#123;</span><br><span class="line">					find = node;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				last = node;</span><br><span class="line">				node = node.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(find != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(last==<span class="keyword">null</span>)&#123;</span><br><span class="line">				head = find.next;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				last.next = find.next;</span><br><span class="line">			&#125;</span><br><span class="line">			total--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(E old, E value)</span> </span>&#123;</span><br><span class="line">		Node&lt;E&gt; node = head;</span><br><span class="line">		Node&lt;E&gt; find = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(old==<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(node.data==<span class="keyword">null</span>)&#123;</span><br><span class="line">					find = node;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(old.equals(node.data))&#123;</span><br><span class="line">					find = node;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(find != <span class="keyword">null</span>)&#123;</span><br><span class="line">			find.data = value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> indexOf(e) != -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(e==<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(Node&lt;E&gt; node = head; node!=<span class="keyword">null</span>; node=node.next )&#123;</span><br><span class="line">				<span class="keyword">if</span>(node.data==e)&#123;</span><br><span class="line">					index=i;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(Node&lt;E&gt; node = head; node!=<span class="keyword">null</span>; node=node.next )&#123;</span><br><span class="line">				<span class="keyword">if</span>(e.equals(node.data))&#123;</span><br><span class="line">					index=i;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Object[] getAll() &#123;</span><br><span class="line">		Object[] all = <span class="keyword">new</span> Object[total];</span><br><span class="line">		Node&lt;E&gt; node = head;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all.length; i++,node = node.next) &#123;</span><br><span class="line">			all[i] = node.data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> all;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表的测试"><a href="#单链表的测试" class="headerlink" title="单链表的测试"></a>单链表的测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOneWayLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">		OneWayLinkedList&lt;String&gt; my = <span class="keyword">new</span> OneWayLinkedList&lt;String&gt;();</span><br><span class="line">		my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + my.size());</span><br><span class="line">		Object[] all = my.getAll();</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">		OneWayLinkedList&lt;String&gt; my = <span class="keyword">new</span> OneWayLinkedList&lt;String&gt;();</span><br><span class="line">		my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		my.delete(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + my.size());</span><br><span class="line">		Object[] all = my.getAll();</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">		</span><br><span class="line">		my.delete(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + my.size());</span><br><span class="line">		all = my.getAll();</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">		</span><br><span class="line">		my.delete(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + my.size());</span><br><span class="line">		all = my.getAll();</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">		OneWayLinkedList&lt;String&gt; my = <span class="keyword">new</span> OneWayLinkedList&lt;String&gt;();</span><br><span class="line">		my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		my.update(<span class="string">&quot;java&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + my.size());</span><br><span class="line">		Object[] all = my.getAll();</span><br><span class="line">		System.out.println(Arrays.toString(all));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">		OneWayLinkedList&lt;String&gt; my = <span class="keyword">new</span> OneWayLinkedList&lt;String&gt;();</span><br><span class="line">		my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(my.contains(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">		System.out.println(my.indexOf(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">		OneWayLinkedList&lt;String&gt; my = <span class="keyword">new</span> OneWayLinkedList&lt;String&gt;();</span><br><span class="line">		my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">		my.add(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (String string : my) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双链表-1"><a href="#双链表-1" class="headerlink" title="双链表"></a>双链表</h2><p>Java中有双链表的实现：LinkedList，它是List接口的实现类。</p>
<h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">Node&lt;E&gt; first;<span class="comment">//记录第一个结点的位置</span></span><br><span class="line">Node&lt;E&gt; last;<span class="comment">//记录最后一个结点的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;<span class="comment">//元素数据</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//下一个结点</span></span><br><span class="line">        Node&lt;E&gt; prev;<span class="comment">//前一个结点</span></span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);<span class="comment">//默认把新元素链接到链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//用l 记录原来的最后一个结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//现在的新结点是最后一个结点了</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果l==null，说明原来的链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//那么新结点同时也是第一个结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则把新结点链接到原来的最后一个结点的next中</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//元素个数增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//分o是否为空两种情况</span></span><br><span class="line">      <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//找到o对应的结点x</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//找到o对应的结点x</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                  unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;<span class="comment">//x是要被删除的结点</span></span><br><span class="line">      <span class="comment">// assert x != null;</span></span><br><span class="line">      <span class="keyword">final</span> E element = x.item;<span class="comment">//被删除结点的数据</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//被删除结点的下一个结点</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//被删除结点的上一个结点</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span></span><br><span class="line">      <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那么被删除结点的下一个结点变为第一个结点</span></span><br><span class="line">          first = next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是第一个结点</span></span><br><span class="line">          <span class="comment">//被删除结点的上一个结点的next指向被删除结点的下一个结点</span></span><br><span class="line">          prev.next = next;</span><br><span class="line">          <span class="comment">//断开被删除结点与上一个结点的链接</span></span><br><span class="line">          x.prev = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span></span><br><span class="line">      <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那么被删除结点的上一个结点变为最后一个结点</span></span><br><span class="line">          last = prev;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是最后一个结点</span></span><br><span class="line">          <span class="comment">//被删除结点的下一个结点的prev执行被删除结点的上一个结点</span></span><br><span class="line">          next.prev = prev;</span><br><span class="line">          <span class="comment">//断开被删除结点与下一个结点的连接</span></span><br><span class="line">          x.next = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//把被删除结点的数据也置空，使得GC回收</span></span><br><span class="line">      x.item = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//元素个数减少</span></span><br><span class="line">      size--;</span><br><span class="line">      <span class="comment">//修改次数增加</span></span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="comment">//返回被删除结点的数据</span></span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表与动态数组的区别"><a href="#链表与动态数组的区别" class="headerlink" title="链表与动态数组的区别"></a>链表与动态数组的区别</h3><p>动态数组底层的物理结构是数组，因此根据索引访问的效率非常高，但是根据索引的插入和删除效率不高，因为涉及到移动元素，而且添加操作时可能涉及到扩容问题，那么就会增加时空消耗。</p>
<p>链表底层的物理结构是链表，因此根据索引访问的效率不高，但是插入和删除的效率高，因为不需要移动元素，只需要修改前后元素的指向关系即可，而链表的添加不会涉及到扩容问题。</p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>堆栈是一种先进后出（FILO：first in last out）或后进先出（LIFI：last in first out）的结构。</p>
<p>队列是一种（但并非一定）先进先出（FIFO）的结构。</p>
<h3 id="Stack类"><a href="#Stack类" class="headerlink" title="Stack类"></a>Stack类</h3><p>java.util.Stack<E>是Vector<E>集合的子类。</p>
<p>比Vector多了几个方法</p>
<ul>
<li> (1)peek：查看栈顶元素，不弹出</li>
<li> (2)pop：弹出栈</li>
<li> (3)push：压入栈         即添加到链表的头</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Stack&lt;Integer&gt; list = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		list.push(<span class="number">1</span>);</span><br><span class="line">		list.push(<span class="number">2</span>);</span><br><span class="line">		list.push(<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*System.out.println(list.pop());</span></span><br><span class="line"><span class="comment">		System.out.println(list.pop());</span></span><br><span class="line"><span class="comment">		System.out.println(list.pop());</span></span><br><span class="line"><span class="comment">		System.out.println(list.pop());//java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(list.peek());</span><br><span class="line">		System.out.println(list.peek());</span><br><span class="line">		System.out.println(list.peek());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Queue和Deque接口"><a href="#Queue和Deque接口" class="headerlink" title="Queue和Deque接口"></a>Queue和Deque接口</h3><p><code>Queue</code>除了基本的 <code>Collection</code>操作外，队列还提供其他的插入、提取和检查操作。每个方法都存在两种形式：一种抛出异常（操作失败时），另一种返回一个特殊值（<code>null</code> 或  <code>false</code>，具体取决于操作）。<code>Queue</code> 实现通常不允许插入  元素，尽管某些实现（如 ）并不禁止插入  。即使在允许 null 的实现中，也不应该将  插入到  中，因为  也用作  方法的一个特殊返回值，表明队列不包含元素。 </p>
<table>
<thead>
<tr>
<th></th>
<th><em>抛出异常</em></th>
<th><em>返回特殊值</em></th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<p><code>Deque</code>，名称 <em>deque</em> 是“double ended queue（双端队列）”的缩写，通常读为“deck”。此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（<code>null</code>  或 <code>false</code>，具体取决于操作）。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>第一个元素（头部）</strong></th>
<th></th>
<th><strong>最后一个元素（尾部）</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><em>抛出异常</em></td>
<td><em>特殊值</em></td>
<td><em>抛出异常</em></td>
<td><em>特殊值</em></td>
</tr>
<tr>
<td><strong>插入</strong></td>
<td>addFirst(e)</td>
<td>offerFirst(e)</td>
<td>addLast(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td><strong>移除</strong></td>
<td>removeFirst()</td>
<td>pollFirst()</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td><strong>检查</strong></td>
<td>getFirst()</td>
<td>peekFirst()</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>此接口扩展了 <code>Queue</code>接口。在将双端队列用作队列时，将得到  FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 <code>Queue</code> 接口继承的方法完全等效于  <code>Deque</code> 方法，如下表所示：  </p>
<table>
<thead>
<tr>
<th><strong><code>Queue</code> 方法</strong></th>
<th><strong>等效 <code>Deque</code> 方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>add(e)</td>
<td>addLast(e)</td>
</tr>
<tr>
<td>offer(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>poll()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<p>双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 <code>Stack</code> 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 <code>Deque</code> 方法，如下表所示：  </p>
<table>
<thead>
<tr>
<th><strong>堆栈方法</strong></th>
<th><strong>等效 <code>Deque</code> 方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>push(e)</td>
<td>addFirst(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<p>结论：Deque接口的实现类既可以用作FILO堆栈使用，又可以用作FIFO队列使用。</p>
<p>Deque接口的实现类有ArrayDeque和LinkedList，它们一个底层是使用数组实现，一个使用双向链表实现。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>HashMap和Hashtable都是哈希表。</p>
<h3 id="hashCode值"><a href="#hashCode值" class="headerlink" title="hashCode值"></a><strong>hashCode值</strong></h3><p>hash算法是一种可以从任何数据中提取出其“指纹”的数据摘要算法，它将任意大小的数据映射到一个固定大小的序列上，这个序列被称为hash code、数据摘要或者指纹。比较出名的hash算法有MD5、SHA。hash是具有唯一性且不可逆的，唯一性是指相同的“对象”产生的hash code永远是一样的。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173824.png" alt="1563797150134"></p>
<h3 id="哈希表的物理结构"><a href="#哈希表的物理结构" class="headerlink" title="哈希表的物理结构"></a><strong>哈希表的物理结构</strong></h3><p>HashMap和Hashtable是散列表，其中维护了一个长度为<strong>2的幂次方</strong>的Entry类型的数组table，数组的每一个元素被称为一个桶(bucket)，你添加的映射关系(key,value)最终都被封装为一个Map.Entry类型的对象，放到了某个table[index]桶中。使用数组的目的是查询和添加的效率高，可以根据索引直接定位到某个table[index]。</p>
<h4 id="数组元素类型：Map-Entry"><a href="#数组元素类型：Map-Entry" class="headerlink" title="数组元素类型：Map.Entry"></a><strong>数组元素类型：Map.Entry</strong></h4><p>JDK1.7：</p>
<p>映射关系被封装为HashMap.Entry类型，而这个类型实现了Map.Entry接口。</p>
<p>观察HashMap.Entry类型是个结点类型，即table[index]下的映射关系可能串起来一个链表。因此我们把table[index]称为“桶bucket”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> K key;</span><br><span class="line">            V value;</span><br><span class="line">            Entry&lt;K,V&gt; next;</span><br><span class="line">            <span class="keyword">int</span> hash;</span><br><span class="line">            <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173830.png" alt="1563799072234"></p>
<p>JDK1.8：</p>
<p>映射关系被封装为HashMap.Node类型或HashMap.TreeNode类型，它俩都直接或间接的实现了Map.Entry接口。</p>
<p>存储到table数组的可能是Node结点对象，也可能是TreeNode结点对象，它们也是Map.Entry接口的实现类。即table[index]下的映射关系可能串起来一个链表或一棵红黑树（自平衡的二叉树）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">            <span class="keyword">final</span> K key;</span><br><span class="line">            V value;</span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;</span><br><span class="line">        <span class="keyword">boolean</span> red;<span class="comment">//是红结点还是黑结点</span></span><br><span class="line">        <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173835.png" alt="1563799238793"></p>
<h4 id="数组的长度始终是2的n次幂"><a href="#数组的长度始终是2的n次幂" class="headerlink" title="数组的长度始终是2的n次幂"></a>数组的长度始终是2的n次幂</h4><p>table数组的默认初始化长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>如果你手动指定的table长度不是2的n次幂，会通过如下方法给你纠正为2的n次幂</p>
<p>JDK1.7：</p>
<p>HashMap处理容量方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Integer包装类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果数组不够了，扩容了怎么办？扩容了还是2的n次幂，因为每次数组扩容为原来的2倍</p>
<p>JDK1.7：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//扩容为原来的2倍</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//oldCap原来的容量</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;<span class="comment">//newCap = oldCap &lt;&lt; 1  新容量=旧容量扩容为原来的2倍</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       	&#125;</span><br><span class="line">  		<span class="comment">//......此处省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么为什么要保持table数组一直是2的n次幂呢？</p>
<h4 id="那么HashMap是如何决定某个映射关系存在哪个桶的呢？"><a href="#那么HashMap是如何决定某个映射关系存在哪个桶的呢？" class="headerlink" title="那么HashMap是如何决定某个映射关系存在哪个桶的呢？"></a>那么HashMap是如何决定某个映射关系存在哪个桶的呢？</h4><p>因为hash值是一个整数，而数组的长度也是一个整数，有两种思路：</p>
<p>①hash 值 % table.length会得到一个[0,table.length-1]范围的值，正好是下标范围，但是用%运算，不能保证均匀存放，可能会导致某些table[index]桶中的元素太多，而另一些太少，因此不合适。</p>
<p>②hash 值 &amp; (table.length-1)，因为table.length是2的幂次方，因此table.length-1是一个二进制低位全是1的数，所以&amp;操作完，也会得到一个[0,table.length-1]范围的值。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173846.png" alt="1563800372286"></p>
<p>JDK1.7：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); <span class="comment">//此处h就是hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)  <span class="comment">// i = (n - 1) &amp; hash</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//....省略大量代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hash是hashCode的再运算"><a href="#hash是hashCode的再运算" class="headerlink" title="hash是hashCode的再运算"></a>hash是hashCode的再运算</h4><p>不管是JDK1.7还是JDK1.8中，都不是直接用key的hashCode值直接与table.length-1计算求下标的，而是先对key的hashCode值进行了一个运算，JDK1.7和JDK1.8关于hash()的实现代码不一样，但是不管怎么样都是为了提高hash code值与 (table.length-1)的按位与完的结果，尽量的均匀分布。</p>
<p>JDK1.7：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>虽然算法不同，但是思路都是将hashCode值的高位二进制与低位二进制值进行了异或，然高位二进制参与到index的计算中。</p>
<p>为什么要hashCode值的二进制的高位参与到index计算呢？</p>
<p>因为一个HashMap的table数组一般不会特别大，至少在不断扩容之前，那么table.length-1的大部分高位都是0，直接用hashCode和table.length-1进行&amp;运算的话，就会导致总是只有最低的几位是有效的，那么就算你的hashCode()实现的再好也难以避免发生碰撞，这时让高位参与进来的意义就体现出来了。它对hashcode的低位添加了随机性并且混合了高位的部分特征，显著减少了碰撞冲突的发生。</p>
<h4 id="解决-index-冲突问题"><a href="#解决-index-冲突问题" class="headerlink" title="解决[index]冲突问题"></a>解决[index]冲突问题</h4><p>虽然从设计hashCode()到上面HashMap的hash()函数，都尽量减少冲突，但是仍然存在两个不同的对象返回的hashCode值相同，或者hashCode值就算不同，通过hash()函数计算后，得到的index也会存在大量的相同，因此key分布完全均匀的情况是不存在的。那么发生碰撞冲突时怎么办？</p>
<p>JDK1.8之间使用：数组+链表的结构。</p>
<p>JDK1.8之后使用：数组+链表/红黑树的结构。</p>
<p>即hash相同或hash&amp;(table.lengt-1)的值相同，那么就存入同一个“桶”table[index]中，使用链表或红黑树连接起来。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173858.png" alt="1563802656661"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173855.png" alt="1563802665708"></p>
<h4 id="为什么JDK1-8会出现红黑树和链表共存呢？"><a href="#为什么JDK1-8会出现红黑树和链表共存呢？" class="headerlink" title="为什么JDK1.8会出现红黑树和链表共存呢？"></a>为什么JDK1.8会出现红黑树和链表共存呢？</h4><p>因为当冲突比较严重时，table[index]下面的链表就会很长，那么会导致查找效率大大降低，而如果此时选用二叉树可以大大提高查询效率。</p>
<p>但是二叉树的结构又过于复杂，如果结点个数比较少的时候，那么选择链表反而更简单。</p>
<p>所以会出现红黑树和链表共存。</p>
<h4 id="什么时候树化？什么时候反树化？"><a href="#什么时候树化？什么时候反树化？" class="headerlink" title="什么时候树化？什么时候反树化？"></a>什么时候树化？什么时候反树化？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;<span class="comment">//树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;<span class="comment">//反树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;<span class="comment">//最小树化容量</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>当某table[index]下的链表的结点个数达到8，并且table.length&gt;=64，那么如果新Entry对象还添加到该table[index]中，那么就会将table[index]的链表进行树化。</p>
</li>
<li><p>当某table[index]下的红黑树结点个数少于6个，此时，</p>
<ul>
<li>如果继续删除table[index]下树结点，一直删除到2个以下时就会变回链表。</li>
<li>如果继续添加映射关系到当前map中，如果添加导致了map的table重新resize，那么只要table[index]下的树结点仍然&lt;=6个，那么会变回链表</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyKey</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyKey</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.num = num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&lt;=<span class="number">20</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">			<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">			result = prime * result + num;</span><br><span class="line">			<span class="keyword">return</span> result;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		MyKey other = (MyKey) obj;</span><br><span class="line">		<span class="keyword">if</span> (num != other.num)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashMap</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//这里为了演示的效果，我们造一个特殊的类，这个类的hashCode（）方法返回固定值1</span></span><br><span class="line">		<span class="comment">//因为这样就可以造成冲突问题，使得它们都存到table[1]中</span></span><br><span class="line">		HashMap&lt;MyKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">			map.put(<span class="keyword">new</span> MyKey(i), <span class="string">&quot;value&quot;</span>+i);<span class="comment">//树化演示</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		HashMap&lt;MyKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">			map.put(<span class="keyword">new</span> MyKey(i), <span class="string">&quot;value&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">11</span>; i++) &#123;</span><br><span class="line">			map.remove(<span class="keyword">new</span> MyKey(i));<span class="comment">//反树化演示</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		HashMap&lt;MyKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">			map.put(<span class="keyword">new</span> MyKey(i), <span class="string">&quot;value&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">			map.remove(<span class="keyword">new</span> MyKey(i));</span><br><span class="line">		&#125;<span class="comment">//table[1]下剩余6个结点</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">21</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">			map.put(<span class="keyword">new</span> MyKey(i), <span class="string">&quot;value&quot;</span>+i);<span class="comment">//添加到扩容时，反树化</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK1-7的put方法源码分析"><a href="#JDK1-7的put方法源码分析" class="headerlink" title="JDK1.7的put方法源码分析"></a>JDK1.7的put方法源码分析</h3><p>（1）几个关键的常量和变量值的作用：</p>
<p>初始化容量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;<span class="comment">//16</span></span><br></pre></td></tr></table></figure>

<p>①默认负载因子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<p>②阈值：扩容的临界值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threshold = table.length * loadFactor;</span><br></pre></td></tr></table></figure>

<p>③负载因子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>负载因子的值大小有什么关系？</p>
<p>如果太大，threshold就会很大，那么如果冲突比较严重的话，就会导致table[index]下面的结点个数很多，影响效率。</p>
<p>如果太小，threshold就会很小，那么数组扩容的频率就会提高，数组的使用率也会降低，那么会造成空间的浪费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//DEFAULT_INITIAL_CAPACITY：默认初始容量16</span></span><br><span class="line">  	<span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">      <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//校验initialCapacity合法性</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">      <span class="comment">//校验initialCapacity合法性                                       initialCapacity);</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="comment">//校验loadFactor合法性</span></span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line"><span class="comment">//加载因子，初始化为0.75</span></span><br><span class="line">      <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">      <span class="comment">// threshold 初始为初始容量                                  </span></span><br><span class="line">      threshold = initialCapacity;</span><br><span class="line">      init();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果table数组是空的，那么先创建数组</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            <span class="comment">//threshold一开始是初始容量的值</span></span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果key是null，单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对key的hashCode进行干扰，算出一个hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算新的映射关系应该存到table[i]位置，</span></span><br><span class="line">        <span class="comment">//i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//添加新的映射关系</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">        <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);<span class="comment">//容量是等于toSize值的最接近的2的n次方</span></span><br><span class="line">		<span class="comment">//计算阈值 = 容量 * 加载因子</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//创建Entry[]数组，长度为capacity</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果key是null，直接存入[0]的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有重复的key，如果有重复的，就替换value</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//把新的映射关系存入[0]的位置，而且key的hash值用0表示</span></span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否需要库容</span></span><br><span class="line">        <span class="comment">//扩容：（1）size达到阈值（2）table[i]正好非空</span></span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            <span class="comment">//table扩容为原来的2倍，并且扩容后，会重新调整所有映射关系的存储位置</span></span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            <span class="comment">//新的映射关系的hash和index也会重新计算</span></span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//存入table中</span></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">//原来table[i]下面的映射关系作为新的映射关系next</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;<span class="comment">//个数增加</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>1、put(key,value)</p>
<p>（1）当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Entry</strong>的数组，这个HashMap$Entry类型是实现了java.util.<strong>Map.Entry</strong>接口</p>
<p>（2）特殊考虑：如果key为null，index直接是[0],hash也是0</p>
<p>（3）如果key不为null，在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p>
<p>（4）计算index = table.length-1 &amp; hash;</p>
<p>（5）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p>
<p>（6）如果没有相同的，会把新的映射关系添加到链表的头，原来table[index]下面的Entry对象连接到新的映射关系的next中。</p>
<p>（7）添加之前先判断if(size &gt;= threshold  &amp;&amp;  table[index]!=null)如果该条件为true，会扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(size &gt;= threshold  &amp;&amp;  table[index]!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">	①会扩容</span><br><span class="line"></span><br><span class="line">	②会重新计算key的hash</span><br><span class="line"></span><br><span class="line">	③会重新计算index</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（8）size++</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173912.png" alt="1563804039202"></p>
<p>2、get(key)</p>
<p>（1）计算key的hash值，用这个方法hash(key)</p>
<p>（2）找index = table.length-1 &amp; hash;</p>
<p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value</p>
<p>3、remove(key)</p>
<p>（1）计算key的hash值，用这个方法hash(key)</p>
<p>（2）找index = table.length-1 &amp; hash;</p>
<p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p>
<h3 id="JDK1-8的put方法源码分析"><a href="#JDK1-8的put方法源码分析" class="headerlink" title="JDK1.8的put方法源码分析"></a>JDK1.8的put方法源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">几个常量和变量：</span><br><span class="line">（<span class="number">1</span>）DEFAULT_INITIAL_CAPACITY：默认的初始容量 <span class="number">16</span></span><br><span class="line">（<span class="number">2</span>）MAXIMUM_CAPACITY：最大容量  <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line">（<span class="number">3</span>）DEFAULT_LOAD_FACTOR：默认加载因子 <span class="number">0.75</span></span><br><span class="line">（<span class="number">4</span>）TREEIFY_THRESHOLD：默认树化阈值<span class="number">8</span>，当链表的长度达到这个值后，要考虑树化</span><br><span class="line">（<span class="number">5</span>）UNTREEIFY_THRESHOLD：默认反树化阈值<span class="number">6</span>，当树中的结点的个数达到这个阈值后，要考虑变为链表</span><br><span class="line">（<span class="number">6</span>）MIN_TREEIFY_CAPACITY：最小树化容量<span class="number">64</span></span><br><span class="line">		当单个的链表的结点个数达到<span class="number">8</span>，并且table的长度达到<span class="number">64</span>，才会树化。</span><br><span class="line">		当单个的链表的结点个数达到<span class="number">8</span>，但是table的长度未达到<span class="number">64</span>，会先扩容</span><br><span class="line">（<span class="number">7</span>）Node&lt;K,V&gt;[] table：数组</span><br><span class="line">（<span class="number">8</span>）size：记录有效映射关系的对数，也是Entry对象的个数</span><br><span class="line">（<span class="number">9</span>）<span class="keyword">int</span> threshold：阈值，当size达到阈值时，考虑扩容</span><br><span class="line">（<span class="number">10</span>）<span class="keyword">double</span> loadFactor：加载因子，影响扩容的频率</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">    <span class="comment">// all other fields defaulted，其他字段都是默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//目的：干扰hashCode值</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">	<span class="comment">//如果key是null，hash是0</span></span><br><span class="line">	<span class="comment">//如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或</span></span><br><span class="line">	<span class="comment">//		即就是用key的hashCode值高16位与低16位进行了异或的干扰运算</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	index = hash &amp; table.length-1</span></span><br><span class="line"><span class="comment">	如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。</span></span><br><span class="line"><span class="comment">	这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; <span class="comment">//数组</span></span><br><span class="line">	Node&lt;K,V&gt; p; <span class="comment">//一个结点</span></span><br><span class="line">	<span class="keyword">int</span> n, i;<span class="comment">//n是数组的长度   i是下标</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//tab和table等价</span></span><br><span class="line">	<span class="comment">//如果table是空的</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">		tab = resize();</span></span><br><span class="line"><span class="comment">		n = tab.length;*/</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12</span></span><br><span class="line"><span class="comment">		n = 16</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span></span><br><span class="line">	<span class="comment">//p = tab[i] 第1个结点</span></span><br><span class="line">	<span class="comment">//if(p==null) 条件满足的话说明 table[i]还没有元素</span></span><br><span class="line">	<span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="comment">//把新的映射关系直接放入table[i]</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">//newNode（）方法就创建了一个Node类型的新结点，新结点的next是null</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; </span><br><span class="line">		K k;</span><br><span class="line">		<span class="comment">//p是table[i]中第一个结点</span></span><br><span class="line">		<span class="comment">//if(table[i]的第一个结点与新的映射关系的key重复)</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">               e = p;<span class="comment">//用e记录这个table[i]的第一个结点</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;<span class="comment">//如果table[i]第一个结点是一个树结点</span></span><br><span class="line">               <span class="comment">//单独处理树结点</span></span><br><span class="line">               <span class="comment">//如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null</span></span><br><span class="line">               <span class="comment">//如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null</span></span><br><span class="line">			e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//table[i]的第一个结点不是树结点，也与新的映射关系的key不重复</span></span><br><span class="line">			<span class="comment">//binCount记录了table[i]下面的结点的个数</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">				<span class="comment">//如果p的下一个结点是空的，说明当前的p是最后一个结点</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">//把新的结点连接到table[i]的最后</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//如果binCount&gt;=8-1，达到7个时</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)&#123; <span class="comment">// -1 for 1st</span></span><br><span class="line">                           <span class="comment">//要么扩容，要么树化</span></span><br><span class="line">						treeifyBin(tab, hash);</span><br><span class="line">					&#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">				<span class="comment">//如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                   p = e;<span class="comment">//下一次循环，e=p.next，就类似于e=e.next，往链表下移动</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="comment">//如果这个e不是null，说明有key重复，就考虑替换原来的value</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">			&#125;</span><br><span class="line">               afterNodeAccess(e);<span class="comment">//什么也没干</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//元素个数增加</span></span><br><span class="line">	<span class="comment">//size达到阈值</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">           resize();<span class="comment">//一旦扩容，重新调整所有映射关系的位置</span></span><br><span class="line">	&#125;</span><br><span class="line">       afterNodeInsertion(evict);<span class="comment">//什么也没干</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;	</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab原来的table</span></span><br><span class="line">	<span class="comment">//oldCap：原来数组的长度</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//oldThr：原来的阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;<span class="comment">//最开始threshold是0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//newCap，新容量</span></span><br><span class="line">	<span class="comment">//newThr：新阈值</span></span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//说明原来不是空数组</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//是否达到数组最大限制</span></span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123;</span><br><span class="line">			<span class="comment">//newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span></span><br><span class="line">			<span class="comment">//新容量：32,64，...</span></span><br><span class="line">			<span class="comment">//oldCap &gt;= 初始容量16</span></span><br><span class="line">			<span class="comment">//新阈值重新算 = 24，48 ....</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">		&#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)&#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//新容量是默认初始化容量16</span></span><br><span class="line">		<span class="comment">//新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span></span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;<span class="comment">//阈值赋值为新阈值12，24.。。。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建了一个新数组，长度为newCap，16，32,64.。。</span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//原来不是空数组</span></span><br><span class="line">		<span class="comment">//把原来的table中映射关系，倒腾到新的table中</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;<span class="comment">//e是table下面的结点</span></span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;<span class="comment">//把旧的table[j]位置清空</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果是最后一个结点</span></span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//重新计算e的在新table中的存储位置，然后放入</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果e是树结点</span></span><br><span class="line">					<span class="comment">//把原来的树拆解，放到新的table</span></span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					把原来table[i]下面的整个链表，重新挪到了新的table中</span></span><br><span class="line"><span class="comment">					*/</span></span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;	</span><br><span class="line"></span><br><span class="line">   <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个新结点</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n, index; </span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="comment">//MIN_TREEIFY_CAPACITY：最小树化容量64</span></span><br><span class="line">	<span class="comment">//如果table是空的，或者  table的长度没有达到64</span></span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();<span class="comment">//先扩容</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//用e记录table[index]的结点的地址</span></span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		do...while，把table[index]链表的Node结点变为TreeNode类型的结点</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                   hd = p;<span class="comment">//hd记录根结点</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">		</span><br><span class="line">           <span class="comment">//如果table[index]下面不是空</span></span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">               hd.treeify(tab);<span class="comment">//将table[index]下面的链表进行树化</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;	</span><br></pre></td></tr></table></figure>

<p>1、添加过程</p>
<p>A. 先计算key的hash值，如果key是null，hash值就是0，如果为null，使用(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)得到hash值；</p>
<p>B. 如果table是空的，先初始化table数组；</p>
<p>C. 通过hash值计算存储的索引位置index = hash &amp; (table.length-1)</p>
<p>D. 如果table[index]==null，那么直接创建一个Node结点存储到table[index]中即可</p>
<p>E. 如果table[index]!=null</p>
<p>​    a) 判断table[index]的根结点的key是否与新的key“相同”（hash值相同并且(满足key的地址相同或key的equals返回true)），如果是那么用e记录这个根结点</p>
<p>​    b) 如果table[index]的根结点的key与新的key“不相同”，而且table[index]是一个TreeNode结点，说明table[index]下是一棵红黑树，如果该树的某个结点的key与新的key“相同”（hash值相同并且(满足key的地址相同或key的equals返回true)），那么用e记录这个相同的结点，否则将(key,value)封装为一个TreeNode结点，连接到红黑树中</p>
<p>​    c) 如果table[index]的根结点的key与新的key“不相同”，并且table[index]不是一个TreeNode结点，说明table[index]下是一个链表，如果该链表中的某个结点的key与新的key“相同”，那么用e记录这个相同的结点，否则将新的映射关系封装为一个Node结点直接链接到链表尾部，并且判断table[index]下结点个数达到**TREEIFY_THRESHOLD(8)<strong>个，如果table[index]下结点个数已经达到，那么再判断table.length是否达到</strong>MIN_TREEIFY_CAPACITY(64)<strong>，如果没达到，那么先扩容，扩容会导致所有元素重新计算index，并调整位置，如果table[index]下结点个数已经达到</strong>TREEIFY_THRESHOLD(8)<strong>个并table.length也已经达到</strong>MIN_TREEIFY_CAPACITY(64)**，那么会将该链表转成一棵自平衡的红黑树。</p>
<p>F. 如果在table[index]下找到了新的key“相同”的结点，即e不为空，那么用新的value替换原来的value，并返回旧的value，结束put方法</p>
<p>G. 如果新增结点而不是替换，那么size++，并且还要重新判断size是否达到threshold阈值，如果达到，还要扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(size &gt; threshold )&#123;</span><br><span class="line">	①会扩容</span><br><span class="line"></span><br><span class="line">	②会重新计算key的hash</span><br><span class="line"></span><br><span class="line">	③会重新计算index</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826173936.png" alt="1572870448458"></p>
<p>2、remove(key)</p>
<p>（1）计算key的hash值，用这个方法hash(key)</p>
<p>（2）找index = table.length-1 &amp; hash;</p>
<p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p>
<p>（4）如果table[index]下面原来是红黑树，结点删除后，个数小于等于6，会把红黑树变为链表</p>
<h3 id="关于映射关系的key是否可以修改？"><a href="#关于映射关系的key是否可以修改？" class="headerlink" title="关于映射关系的key是否可以修改？"></a>关于映射关系的key是否可以修改？</h3><p>映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</p>
<p>这个规则也同样适用于LinkedHashMap、HashSet、LinkedHashSet、Hashtable等所有散列存储结构的集合。</p>
<p>JDK1.7：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> K key;</span><br><span class="line">            V value;</span><br><span class="line">            Entry&lt;K,V&gt; next;</span><br><span class="line">            <span class="keyword">int</span> hash; <span class="comment">//记录Entry映射关系的key的hash(key.hashCode())值</span></span><br><span class="line">            <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//记录Node映射关系的key的hash(key.hashCode())值</span></span><br><span class="line">            <span class="keyword">final</span> K key;</span><br><span class="line">            V value;</span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashMap</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashMap&lt;ID,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		ID i1 = <span class="keyword">new</span> ID(<span class="number">1</span>);</span><br><span class="line">		ID i2 = <span class="keyword">new</span> ID(<span class="number">2</span>);</span><br><span class="line">		ID i3 = <span class="keyword">new</span> ID(<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		map.put(i1, <span class="string">&quot;haha&quot;</span>);</span><br><span class="line">		map.put(i2, <span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">		map.put(i3, <span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(map.get(i1));<span class="comment">//haha</span></span><br><span class="line">		i1.setId(<span class="number">10</span>);</span><br><span class="line">		System.out.println(map.get(i1));<span class="comment">//null</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ID</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">		result = prime * result + id;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		ID other = (ID) obj;</span><br><span class="line">		<span class="keyword">if</span> (id != other.id)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以实际开发中，经常选用String，Integer等作为key，因为它们都是不可变对象。</p>
</blockquote>
<h1 id="File类与IO流"><a href="#File类与IO流" class="headerlink" title="File类与IO流"></a>File类与IO流</h1><h2 id="java-io-File类"><a href="#java-io-File类" class="headerlink" title="java.io.File类"></a>java.io.File类</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>File类是java.io包下代表与平台无关的文件和目录，也就是说如果希望在程序中操作文件和目录都可以通过File类来完成，File类能新建、删除、重命名文件和目录。</p>
<p>在API中File的解释是文件和目录路径名的抽象表示形式，即File类是文件或目录的路径，而不是文件本身，因此File类不能直接访问文件内容本身，如果需要访问文件内容本身，则需要使用输入/输出流。 </p>
<blockquote>
<p>File类代表磁盘或网络中某个文件或目录的路径名称，如：/atguigu/javase/io/佟刚.jpg</p>
<p>但不能直接通过File对象读取和写入数据，如果要操作数据，需要IO流。File对象好比是到水库的“路线地址”，要“存取”里面的水到你“家里”，需要“管道”。</p>
</blockquote>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174045.png" alt="1563809289418"></p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li>
<li><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li>
<li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li>
</ul>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname = <span class="string">&quot;D:\\aaa.txt&quot;</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(pathname); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname2 = <span class="string">&quot;D:\\aaa\\bbb.txt&quot;</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(pathname2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> String parent = <span class="string">&quot;d:\\aaa&quot;</span>;</span><br><span class="line"> String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> File file3 = <span class="keyword">new</span> File(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li>
<li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li>
</ol>
</blockquote>
<h3 id="常用方法（了解）"><a href="#常用方法（了解）" class="headerlink" title="常用方法（了解）"></a>常用方法（了解）</h3><h4 id="获取文件和目录基本信息的方法"><a href="#获取文件和目录基本信息的方法" class="headerlink" title="获取文件和目录基本信息的方法"></a>获取文件和目录基本信息的方法</h4><ul>
<li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p>
</li>
<li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p>
</li>
<li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p>
</li>
<li><p><code>public long lastModified()</code>：返回File对象对应的文件或目录的最后修改时间（毫秒值）</p>
<p>  方法演示，代码如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa/bbb.txt&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span>+f.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件最后修改时间：&quot;</span> + LocalDateTime.ofInstant(Instant.ofEpochMilli(f.lastModified()),ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span>+f2.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件最后修改时间：&quot;</span> + LocalDateTime.ofInstant(Instant.ofEpochMilli(f.lastModified()),ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">636</span>字节</span><br><span class="line">文件最后修改时间：<span class="number">2019</span>-<span class="number">07</span>-23T22:<span class="number">01</span>:<span class="number">32.065</span></span><br><span class="line"></span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">4096</span>字节</span><br><span class="line">文件最后修改时间：<span class="number">2019</span>-<span class="number">07</span>-23T22:<span class="number">01</span>:<span class="number">32.065</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p>
</blockquote>
<h4 id="各种路径问题"><a href="#各种路径问题" class="headerlink" title="各种路径问题"></a>各种路径问题</h4><ul>
<li><code>public String getPath()</code> ：将此File转换为路径名字符串。 </li>
<li><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</li>
<li><code>String getCanonicalPath()</code>：返回此File对象所对应的规范路径名。</li>
</ul>
<p>File类可以使用文件路径字符串来创建File实例，该文件路径字符串既可以是绝对路径，也可以是相对路径。</p>
<p>默认情况下，系统总是依据用户的工作路径来解释相对路径，这个路径由系统属性“user.dir”指定，通常也就是运行Java虚拟机时所作的路径。</p>
<ul>
<li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径</strong>：相对于<strong>项目目录</strong>的路径，这是一个便捷的路径，开发中经常使用。</li>
<li><strong>规范路径</strong>：所谓规范路径名，即对路径中的“..”等进行解析后的路径名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	File f1 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\atguigu\\javase\\HelloIO.java&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的名称：&quot;</span> + f1.getName());</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的构造路径名：&quot;</span> + f1.getPath());</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的绝对路径名：&quot;</span> + f1.getAbsolutePath());</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的规范路径名：&quot;</span> + f1.getCanonicalPath());</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的父目录名：&quot;</span> + f1.getParent());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	File f2 = <span class="keyword">new</span> File(<span class="string">&quot;HelloIO.java&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;user.dir =&quot;</span> + System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的名称：&quot;</span> + f2.getName());</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的构造路径名：&quot;</span> + f2.getPath());</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的绝对路径名：&quot;</span> + f2.getAbsolutePath());</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的规范路径名：&quot;</span> + f2.getCanonicalPath());</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的父目录名：&quot;</span> + f2.getParent());</span><br><span class="line">&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	File f3 = <span class="keyword">new</span> File(<span class="string">&quot;../../HelloIO.java&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;user.dir =&quot;</span> + System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的名称：&quot;</span> + f3.getName());</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的构造路径名：&quot;</span> + f3.getPath());</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的绝对路径名：&quot;</span> + f3.getAbsolutePath());</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的规范路径名：&quot;</span> + f3.getCanonicalPath());</span><br><span class="line">	System.out.println(<span class="string">&quot;文件/目录的父目录名：&quot;</span> + f3.getParent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>window的路径分隔符使用“\”，而Java程序中的“\”表示转义字符，所以在Windows中表示路径，需要用“\”。或者直接使用“/”也可以，Java程序支持将“/”当成平台无关的路径分隔符。或者直接使用File.separator常量值表示。</p>
</li>
<li><p>把构造File对象指定的文件或目录的路径名，称为构造路径，它可以是绝对路径，也可以是相对路径</p>
</li>
<li><p>当构造路径是绝对路径时，那么getPath和getAbsolutePath结果一样</p>
</li>
<li><p>当构造路径是相对路径时，那么getAbsolutePath的路径 = user.dir的路径 + 构造路径</p>
</li>
<li><p>当路径中不包含”..”和”/开头”等形式的路径，那么规范路径和绝对路径一样，否则会将..等进行解析。路径中如果出现“..”表示上一级目录，路径名如果以“/”开头，表示从“根目录”下开始导航。</p>
</li>
</ul>
<h4 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h4><ul>
<li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li>
<li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li>
<li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li>
</ul>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());</span><br><span class="line">      	<span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?:<span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?:<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果文件或目录不存在，那么exists()、isFile()和isDirectory()都是返回true</p>
</blockquote>
<h4 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h4><ul>
<li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li>
<li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  只能删除空目录。</li>
<li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li>
<li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li>
</ul>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line">		</span><br><span class="line">     	<span class="comment">// 目录的创建</span></span><br><span class="line">      	File f2= <span class="keyword">new</span> File(<span class="string">&quot;newDir&quot;</span>);	</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f2.mkdir());	<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建多级目录</span></span><br><span class="line">      	File f3= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 文件的删除</span></span><br><span class="line">       	System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p>
</blockquote>
<h3 id="递归实现多级目录操作（了解，有时间作为复习递归练习用）"><a href="#递归实现多级目录操作（了解，有时间作为复习递归练习用）" class="headerlink" title="递归实现多级目录操作（了解，有时间作为复习递归练习用）"></a>递归实现多级目录操作（了解，有时间作为复习递归练习用）</h3><ul>
<li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li>
</ul>
<ul>
<li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </li>
<li><code>public File[] listFiles(FileFilter filter)</code>：返回所有满足指定过滤器的文件和目录。如果给定 filter 为 null，则接受所有路径名。否则，当且仅当在路径名上调用过滤器的 FileFilter.accept(java.io.File) 方法返回 true 时，该路径名才满足过滤器。如果当前File对象不表示一个目录，或者发生 I/O 错误，则返回 null。</li>
</ul>
<h4 id="递归打印多级目录"><a href="#递归打印多级目录" class="headerlink" title="递归打印多级目录"></a>递归打印多级目录</h4><p><strong>分析</strong>：多级目录的打印。遍历之前，无从知道到底有多少级目录，所以我们可以使用递归实现。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 File dir = <span class="keyword">new</span> File(<span class="string">&quot;d:/atguigu&quot;</span>);</span><br><span class="line">	 listSubFiles(dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listSubFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dir != <span class="keyword">null</span> &amp;&amp; dir.isDirectory()) &#123;</span><br><span class="line">		File[] listFiles = dir.listFiles();</span><br><span class="line">		<span class="keyword">if</span> (listFiles != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (File sub : listFiles) &#123;</span><br><span class="line">				listSubFiles(sub);<span class="comment">//递归调用</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归打印某目录下（包括子目录）中所有满足条件的文件"><a href="#递归打印某目录下（包括子目录）中所有满足条件的文件" class="headerlink" title="递归打印某目录下（包括子目录）中所有满足条件的文件"></a>递归打印某目录下（包括子目录）中所有满足条件的文件</h4><p>示例代码：列出”D:/atguigu”下所有”.java”文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 File dir = <span class="keyword">new</span> File(<span class="string">&quot;D:/atguigu&quot;</span>);</span><br><span class="line">	 listByFileFilter(dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listByFileFilter</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (file != <span class="keyword">null</span> &amp;&amp; file.isDirectory()) &#123;</span><br><span class="line">		File[] listFiles = file.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> name.endsWith(<span class="string">&quot;.java&quot;</span>) || <span class="keyword">new</span> File(dir,name).isDirectory();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">if</span> (listFiles != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (File sub : listFiles) &#123;</span><br><span class="line">				<span class="keyword">if</span>(sub.isFile())&#123;</span><br><span class="line">					System.out.println(sub);</span><br><span class="line">				&#125;</span><br><span class="line">				listByFileFilter(sub);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归求目录总大小"><a href="#递归求目录总大小" class="headerlink" title="递归求目录总大小"></a>递归求目录总大小</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 File dir = <span class="keyword">new</span> File(<span class="string">&quot;D:/atguigu&quot;</span>);</span><br><span class="line">	 <span class="keyword">long</span> length = getLength(dir);</span><br><span class="line">	 System.out.println(<span class="string">&quot;大小：&quot;</span> + length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLength</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dir != <span class="keyword">null</span> &amp;&amp; dir.isDirectory()) &#123;</span><br><span class="line">		File[] listFiles = dir.listFiles();</span><br><span class="line">		<span class="keyword">if</span>(listFiles!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (File sub : listFiles) &#123;</span><br><span class="line">				sum += getLength(sub);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(dir != <span class="keyword">null</span> &amp;&amp; dir.isFile())&#123;</span><br><span class="line">		<span class="keyword">return</span> dir.length();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归删除非空目录"><a href="#递归删除非空目录" class="headerlink" title="递归删除非空目录"></a>递归删除非空目录</h4><p>如果目录非空，连同目录下的文件和文件夹一起删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 File dir = <span class="keyword">new</span> File(<span class="string">&quot;D:/atguigu/javase&quot;</span>);</span><br><span class="line">	 forceDeleteDir(dir);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceDeleteDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dir != <span class="keyword">null</span> &amp;&amp; dir.isDirectory()) &#123;</span><br><span class="line">		File[] listFiles = dir.listFiles();</span><br><span class="line">		<span class="keyword">if</span>(listFiles!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (File sub : listFiles) &#123;</span><br><span class="line">				forceDeleteDir(sub);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dir.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IO概述"><a href="#IO概述" class="headerlink" title="IO概述"></a>IO概述</h2><h3 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h3><p>生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了<code>ctrl+s</code> ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。</p>
<p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p>
<p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p>
<h3 id="IO的分类"><a href="#IO的分类" class="headerlink" title="IO的分类"></a>IO的分类</h3><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 <ul>
<li>以InputStream,Reader结尾</li>
</ul>
</li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。<ul>
<li>以OutputStream、Writer结尾</li>
</ul>
</li>
</ul>
<p>根据数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。<ul>
<li>以InputStream和OutputStream结尾</li>
</ul>
</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。<ul>
<li>以Reader和Writer结尾</li>
</ul>
</li>
</ul>
<p>根据IO流的角色不同分为：<strong>节点流</strong>和<strong>处理流</strong>。</p>
<ul>
<li><p><strong>节点流</strong>：可以从或向一个特定的地方（节点）读写数据。如FileReader.</p>
</li>
<li><p><strong>处理流</strong>：是对一个已存在的流进行连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</p>
</li>
</ul>
<blockquote>
<p>这种设计是装饰模式（Decorator Pattern）也称为包装模式（Wrapper Pattern），其使用一种对客户端透明的方式来动态地扩展对象的功能，它是通过继承扩展功能的替代方案之一。在现实生活中你也有很多装饰者的例子，例如：人需要各种各样的衣着，不管你穿着怎样，但是，对于你个人本质来说是不变的，充其量只是在外面加上了一些装饰，有，“遮羞的”、“保暖的”、“好看的”、“防雨的”….</p>
</blockquote>
<p><strong>常用的节点流：</strong> 　</p>
<ul>
<li>文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。</li>
<li>字符串 StringReader StringWriter 对字符串进行处理的节点流。</li>
<li>数 组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li>
<li>管 道 PipedInputStream、PipedOutputStream、PipedReader、PipedWriter对管道进行处理的节点流。</li>
</ul>
<p><strong>常用处理流：</strong></p>
<ul>
<li><p>缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter—增加缓冲功能，避免频繁读写硬盘。</p>
</li>
<li><p>转换流：InputStreamReader、OutputStreamReader—实现字节流和字符流之间的转换。</p>
</li>
<li><p>数据流：DataInputStream、DataOutputStream -提供读写Java基础数据类型功能</p>
</li>
<li><p>对象流：ObjectInputStream、ObjectOutputStream–提供直接读写Java对象功能</p>
</li>
</ul>
<h3 id="4大顶级抽象父类们"><a href="#4大顶级抽象父类们" class="headerlink" title="4大顶级抽象父类们"></a>4大顶级抽象父类们</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>输入流</strong></th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center">字节输入流<strong>InputStream</strong></td>
<td align="center">字节输出流<strong>OutputStream</strong></td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center">字符输入流<strong>Reader</strong></td>
<td align="center">字符输出流<strong>Writer</strong></td>
</tr>
</tbody></table>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="一切皆为字节"><a href="#一切皆为字节" class="headerlink" title="一切皆为字节"></a>一切皆为字节</h3><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h3 id="字节输出流【OutputStream】"><a href="#字节输出流【OutputStream】" class="headerlink" title="字节输出流【OutputStream】"></a>字节输出流【OutputStream】</h3><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li>
<li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li>
<li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li>
<li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li>
<li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<h3 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h3><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。</p>
<p><code>java.io.FileOutputStream </code>类是文件输出流，用于将数据写出到文件。</p>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li>
<li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h4><ol>
<li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">      	fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">      	fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;尚硅谷&quot;</span>.getBytes();</span><br><span class="line">      	<span class="comment">// 写出字节数组数据</span></span><br><span class="line">      	fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">尚硅谷</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>

<h4 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h4><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p>
<ul>
<li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li>
<li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。  </li>
</ul>
<p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure>

<h4 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h4><p>Windows系统里，换行符号是<code>\r\n</code> 。把</p>
<p>以指定是否追加续写了，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);  </span><br><span class="line">      	<span class="comment">// 定义字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">      	<span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          	<span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          	<span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul>
<li>回车符：回到一行的开头（return）。</li>
<li>换行符：下一行（newline）。</li>
</ul>
</li>
<li>系统中的换行：<ul>
<li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="字节输入流【InputStream】"><a href="#字节输入流【InputStream】" class="headerlink" title="字节输入流【InputStream】"></a>字节输入流【InputStream】</h3><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li>
<li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li>
<li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<h3 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h3><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li>
<li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h4><ol>
<li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="keyword">int</span> read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">      	<span class="comment">// 读取到末尾,返回-1</span></span><br><span class="line">       	read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>循环改进读取方式，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然读取了一个字节，但是会自动提升为int类型。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>

<p>错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全替换，所以要通过<code>len</code> ，获取有效的字节，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p>
</blockquote>
<h3 id="字节流练习：图片复制"><a href="#字节流练习：图片复制" class="headerlink" title="字节流练习：图片复制"></a>字节流练习：图片复制</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174207.jpg"></p>
<p>复制图片文件，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 指定数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2 指定目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读写数据</span></span><br><span class="line">        <span class="comment">// 2.1 定义数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 2.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 2.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.4 写出数据</span></span><br><span class="line">            fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>流的关闭原则：先开后关，后开先关。</p>
</blockquote>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<h3 id="字符输入流【Reader】"><a href="#字符输入流【Reader】" class="headerlink" title="字符输入流【Reader】"></a>字符输入流【Reader】</h3><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li>
<li><code>public int read()</code>： 从输入流读取一个字符。 </li>
<li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li>
</ul>
<h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><p><code>java.io.FileReader </code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<blockquote>
<p>小贴士：</p>
<ol>
<li>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。</li>
</ol>
<p>eclipse中默认GBK，idea中默认UTF-8</p>
<ol start="2">
<li>字节缓冲区：一个字节数组，用来临时存储字节数据。</li>
</ol>
</blockquote>
<h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li>
<li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h4><ol>
<li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">尚</span><br><span class="line">硅</span><br><span class="line">谷</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p>
</blockquote>
<ol start="2">
<li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">         <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(cbuf));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">尚硅</span><br><span class="line">谷硅</span><br></pre></td></tr></table></figure>

<p>获取有效的字符改进，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">尚硅</span><br><span class="line">谷</span><br></pre></td></tr></table></figure>

<h3 id="字符输出流【Writer】"><a href="#字符输出流【Writer】" class="headerlink" title="字符输出流【Writer】"></a>字符输出流【Writer】</h3><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>void write(int c)</code> 写入单个字符。</li>
<li><code>void write(char[] cbuf) </code>写入字符数组。 </li>
<li><code>abstract  void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li>
<li><code>void write(String str) </code>写入字符串。 </li>
<li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li>
<li><code>void flush() </code>刷新该流的缓冲。  </li>
<li><code>void close()</code> 关闭此流，但要先刷新它。 </li>
</ul>
<h3 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h3><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li>
<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h4><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">      	fw.write(<span class="number">30000</span>); <span class="comment">// 写出第4个字符，中文编码表中30000对应一个汉字。</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        【注意】关闭资源时,与FileOutputStream不同。</span></span><br><span class="line"><span class="comment">      	 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// fw.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abC田</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li>
<li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li>
</ol>
</blockquote>
<h4 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h4><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<ul>
<li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
</blockquote>
<h4 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h4><ol>
<li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">char</span>[] chars = <span class="string">&quot;尚硅谷&quot;</span>.toCharArray();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出字符数组</span></span><br><span class="line">      	fw.write(chars); <span class="comment">// 尚硅谷</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 写出从索引1开始，2个字节。索引1是&#x27;硅&#x27;，两个字节，也就是&#x27;硅谷&#x27;。</span></span><br><span class="line">        fw.write(b,<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 硅谷</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串</span></span><br><span class="line">      	String msg = <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出字符数组</span></span><br><span class="line">      	fw.write(msg); <span class="comment">//尚硅谷</span></span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 写出从索引1开始，2个字节。索引1是&#x27;硅&#x27;，两个字节，也就是&#x27;硅谷&#x27;。</span></span><br><span class="line">        fw.write(msg,<span class="number">1</span>,<span class="number">2</span>);	<span class="comment">// 尚硅谷</span></span><br><span class="line">      	</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>续写和换行</strong>：操作类似于FileOutputStream。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，可以续写数据</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;尚&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">      	fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">  		fw.write(<span class="string">&quot;硅谷&quot;</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">尚</span><br><span class="line">硅谷</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p>
<p>当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</p>
</blockquote>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>缓冲流,也叫高效流，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;bis.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;bos.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="效率测试-1"><a href="#效率测试-1" class="headerlink" title="效率测试"></a>效率测试</h4><p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p>
<ol>
<li>基本流，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdk9.exe&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copy.exe&quot;</span>);</span><br><span class="line">        	<span class="comment">// 读写数据</span></span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">十几分钟过去了...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>缓冲流，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdk9.exe&quot;</span>));</span><br><span class="line">	    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copy.exe&quot;</span>));</span><br><span class="line">        <span class="comment">// 读写数据</span></span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缓冲流复制时间:<span class="number">8016</span> 毫秒</span><br></pre></td></tr></table></figure>

<p>如何更快呢？</p>
<p>使用数组的方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">		BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdk9.exe&quot;</span>));</span><br><span class="line">		BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copy.exe&quot;</span>));</span><br><span class="line">          	<span class="comment">// 读写数据</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">缓冲流使用数组复制时间:<span class="number">666</span> 毫秒</span><br></pre></td></tr></table></figure>

<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><h4 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;br.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;bw.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h4><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li>
<li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li>
</ul>
<p><code>readLine</code>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	 <span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">      	<span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(line);</span><br><span class="line">            System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newLine</code>方法演示，代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">      	<span class="comment">// 创建流对象</span></span><br><span class="line">		BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;尚&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;硅&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;谷&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出效果:</span><br><span class="line">尚</span><br><span class="line">硅</span><br><span class="line">谷</span><br></pre></td></tr></table></figure>

<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><h3 id="字符编码和字符集"><a href="#字符编码和字符集" class="headerlink" title="字符编码和字符集"></a>字符编码和字符集</h3><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p>
<p>编码:字符(能看懂的)–字节(看不懂的)</p>
<p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p>
<ul>
<li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p>  编码表:生活中文字和计算机中二进制的对应规则</p>
</li>
</ul>
<h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><ul>
<li>**字符集 <code>Charset</code>**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
</ul>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174333.jpg"></p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<ul>
<li><strong>ASCII字符集</strong> ：<ul>
<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li>
<li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。</li>
<li>ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li>
</ul>
</li>
<li><strong>ISO-8859-1字符集</strong>：<ul>
<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li>
</ul>
</li>
<li><strong>GBxxx字符集</strong>：<ul>
<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul>
</li>
<li><strong>Unicode字符集</strong> ：<ul>
<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li>
<li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol>
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。 </li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="编码引出的问题"><a href="#编码引出的问题" class="headerlink" title="编码引出的问题"></a>编码引出的问题</h3><p>在Eclipse中，使用<code>FileReader</code> 读取项目中的文本文件。由于Eclipse的设置UTF-8编码但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:\\File_GBK.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">���</span><br></pre></td></tr></table></figure>

<p>那么如何读取GBK编码的文件呢？ </p>
<h3 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h3><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h4 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>构造举例，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">        String FileName = <span class="string">&quot;E:\\file_gbk.txt&quot;</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName));</span><br><span class="line">      	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">		<span class="comment">// 定义变量,保存字符</span></span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">      	<span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read); <span class="comment">// ��Һ�</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);<span class="comment">// 大家好</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h3><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h4 id="构造方法-9"><a href="#构造方法-9" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>构造举例，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStreamWriter isr = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line">OutputStreamWriter isr2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="指定编码写出"><a href="#指定编码写出" class="headerlink" title="指定编码写出"></a>指定编码写出</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径</span></span><br><span class="line">        String FileName = <span class="string">&quot;E:\\out.txt&quot;</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw.write(<span class="string">&quot;你好&quot;</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">        osw.close();</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 定义文件路径</span></span><br><span class="line">		String FileName2 = <span class="string">&quot;E:\\out2.txt&quot;</span>;</span><br><span class="line">     	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName2),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw2.write(<span class="string">&quot;你好&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">        osw2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h3><p><strong>转换流是字节与字符间的桥梁！</strong></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174352.jpg"></p>
<h3 id="练习：转换文件编码"><a href="#练习：转换文件编码" class="headerlink" title="练习：转换文件编码"></a>练习：转换文件编码</h3><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><ol>
<li>指定GBK编码的转换流，读取文本文件。</li>
<li>使用UTF-8编码的转换流，写出文本文件。</li>
</ol>
<h4 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      </span><br><span class="line">    	<span class="comment">// 1.定义文件路径</span></span><br><span class="line">     	String srcFile = <span class="string">&quot;file_gbk.txt&quot;</span>;</span><br><span class="line">        String destFile = <span class="string">&quot;file_utf8.txt&quot;</span>;</span><br><span class="line">		<span class="comment">// 2.创建流对象</span></span><br><span class="line">    	<span class="comment">// 2.1 转换输入流,指定GBK编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(srcFile) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    	<span class="comment">// 2.2 转换输出流,默认utf8编码</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(destFile));</span><br><span class="line">		<span class="comment">// 3.读写数据</span></span><br><span class="line">    	<span class="comment">// 3.1 定义数组</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    	<span class="comment">// 3.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">    	<span class="comment">// 3.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环写出</span></span><br><span class="line">          	osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 4.释放资源</span></span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>前面学习的IO流，在程序代码中，要么将数据直接按照字节处理，要么按照字符处理。那么，如果要在程序中直接处理Java的基础数据类型，怎么办呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = “巫师”;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">char</span> gender = ‘男’;</span><br><span class="line"><span class="keyword">int</span> energy = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">double</span> price = <span class="number">75.5</span>;</span><br><span class="line"><span class="keyword">boolean</span> relive = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>完成这个需求，可以使用DataOutputStream进行写，随后用DataInputStream进行读取，而且顺序要一致。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestData</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		String name = <span class="string">&quot;巫师&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> age = <span class="number">300</span>;</span><br><span class="line">		<span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">		<span class="keyword">int</span> energy = <span class="number">5000</span>;</span><br><span class="line">		<span class="keyword">double</span> price = <span class="number">75.5</span>;</span><br><span class="line">		<span class="keyword">boolean</span> relive = <span class="keyword">true</span>;</span><br><span class="line">		</span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;game.dat&quot;</span>));</span><br><span class="line">		dos.writeUTF(name);</span><br><span class="line">		dos.writeInt(age);</span><br><span class="line">		dos.writeChar(gender);</span><br><span class="line">		dos.writeInt(energy);</span><br><span class="line">		dos.writeDouble(price);</span><br><span class="line">		dos.writeBoolean(relive);</span><br><span class="line">		dos.close();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;game.dat&quot;</span>));</span><br><span class="line">		String name = dis.readUTF();</span><br><span class="line">		<span class="keyword">int</span> age = dis.readInt();</span><br><span class="line">		<span class="keyword">char</span> gender = dis.readChar();</span><br><span class="line">		<span class="keyword">int</span> energy = dis.readInt();</span><br><span class="line">		<span class="keyword">double</span> price = dis.readDouble();</span><br><span class="line">		<span class="keyword">boolean</span> relive = dis.readBoolean();</span><br><span class="line">		</span><br><span class="line">		System.out.println(name+<span class="string">&quot;,&quot;</span> + age + <span class="string">&quot;,&quot;</span> + gender + <span class="string">&quot;,&quot;</span> + energy + <span class="string">&quot;,&quot;</span> + price + <span class="string">&quot;,&quot;</span> + relive);</span><br><span class="line">		</span><br><span class="line">		dis.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174411.jpg"></p>
<h3 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h3><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<h4 id="构造方法-10"><a href="#构造方法-10" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</li>
</ul>
<p>构造举例，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>

<h4 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h4><ul>
<li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。<ul>
<li>如果对象的某个属性也是引用数据类型，那么如果该属性也要序列化的话，也要实现<code>Serializable</code> 接口</li>
</ul>
</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
<li>静态变量的值不会序列化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String company = <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.写出对象方法</p>
<ul>
<li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">    	Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">    	e.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    	e.address = <span class="string">&quot;beiqinglu&quot;</span>;</span><br><span class="line">    	e.age = <span class="number">20</span>; </span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">      		<span class="comment">// 创建序列化流对象</span></span><br><span class="line">          ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;employee.txt&quot;</span>));</span><br><span class="line">        	<span class="comment">// 写出对象</span></span><br><span class="line">        	out.writeObject(e);</span><br><span class="line">        	<span class="comment">// 释放资源</span></span><br><span class="line">        	out.close();</span><br><span class="line">        	fileOut.close();</span><br><span class="line">        	System.out.println(<span class="string">&quot;Serialized data is saved&quot;</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure>

<h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p>
<h4 id="构造方法-11"><a href="#构造方法-11" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li>
</ul>
<h4 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h4><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p>
<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;		</span><br><span class="line">             <span class="comment">// 创建反序列化流</span></span><br><span class="line">             FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line">             ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">             <span class="comment">// 读取一个对象</span></span><br><span class="line">             e = (Employee) in.readObject();</span><br><span class="line">             <span class="comment">// 释放资源</span></span><br><span class="line">             in.close();</span><br><span class="line">             fileIn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">             <span class="comment">// 捕获其他异常</span></span><br><span class="line">             i.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException c)  &#123;</span><br><span class="line">        	<span class="comment">// 捕获类找不到异常</span></span><br><span class="line">             System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">             c.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);	<span class="comment">// zhangsan</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">        System.out.println(<span class="string">&quot;age: &quot;</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p>
<h4 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h4><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>该类包含未知数据类型  </li>
</ul>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 加入序列版本号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">     <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String address;</span><br><span class="line">     <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> eid; </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习：序列化集合"><a href="#练习：序列化集合" class="headerlink" title="练习：序列化集合"></a>练习：序列化集合</h3><ol>
<li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li>
<li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><ol>
<li>把若干学生对象 ，保存到集合中。</li>
<li>把集合序列化。</li>
<li>反序列化读取时，只需要读取一次，转换为集合类型。</li>
<li>遍历集合，可以打印所有的学生信息</li>
</ol>
<h4 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建 学生对象</span></span><br><span class="line">		Student student = <span class="keyword">new</span> Student(<span class="string">&quot;老王&quot;</span>, <span class="string">&quot;laow&quot;</span>);</span><br><span class="line">		Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;老张&quot;</span>, <span class="string">&quot;laoz&quot;</span>);</span><br><span class="line">		Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;老李&quot;</span>, <span class="string">&quot;laol&quot;</span>);</span><br><span class="line"></span><br><span class="line">		ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		arrayList.add(student);</span><br><span class="line">		arrayList.add(student2);</span><br><span class="line">		arrayList.add(student3);</span><br><span class="line">		<span class="comment">// 序列化操作</span></span><br><span class="line">		<span class="comment">// serializ(arrayList);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 反序列化  </span></span><br><span class="line">		ObjectInputStream ois  = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 读取对象,强转为ArrayList类型</span></span><br><span class="line">		ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();</span><br><span class="line">		</span><br><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++ )&#123;</span><br><span class="line">          	Student s = list.get(i);</span><br><span class="line">        	System.out.println(s.getName()+<span class="string">&quot;--&quot;</span>+ s.getPwd());</span><br><span class="line">      	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serializ</span><span class="params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建 序列化流 </span></span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 写出对象</span></span><br><span class="line">		oos.writeObject(arrayList);</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		oos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-io-Externalizable接口"><a href="#java-io-Externalizable接口" class="headerlink" title="java.io.Externalizable接口"></a>java.io.Externalizable接口</h3><p>除了Serializable接口之外，还可以实现java.io.Externalizable接口，但是要求重写：</p>
<p>void readExternal(ObjectInput in)<br>void writeExternal(ObjectOutput out)</p>
<p>  关于哪些属性序列化和反序列化，由程序员自己定。<strong>虽然可以自己决定任意属性的输出和读取，但是还是建议不要输出静态的和transient属性。</strong></p>
<p>学生类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Externalizable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String school = <span class="string">&quot;atguigu&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSchool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> school;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSchool</span><span class="params">(String school)</span> </span>&#123;</span><br><span class="line">		Student.school = school;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name +<span class="string">&quot;,age =&quot;</span> +age + <span class="string">&quot;, score=&quot;</span> + score +<span class="string">&quot;,schoool = &quot;</span> + school+ <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//一下两个方法不是程序员手动调用，而是在对象被序列化和反序列时，IO流自动调用</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//在这个方法中，程序员自己定，哪些属性需要序列化，及其顺序</span></span><br><span class="line">		out.writeUTF(school);</span><br><span class="line">		out.writeUTF(name);</span><br><span class="line">		out.writeInt(score);</span><br><span class="line">		out.writeInt(age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">		<span class="comment">//读取的顺序要与写的顺序一致</span></span><br><span class="line">		school = in.readUTF();</span><br><span class="line">		name = in.readUTF();</span><br><span class="line">		score = in.readInt();</span><br><span class="line">		age = in.readInt();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。</span></span><br><span class="line"><span class="comment"> * 		序列化接口没有方法或字段，仅用于标识可序列化的语义。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * java.io.Externalizable 实例类的唯一特性是可以被写入序列化流中，该类负责保存和恢复实例内容。 </span></span><br><span class="line"><span class="comment"> * 		则它要实现 Externalizable 接口的 writeExternal 和 readExternal 方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  void readExternal(ObjectInput in) </span></span><br><span class="line"><span class="comment"> *  void writeExternal(ObjectOutput out)  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  虽然可以自己决定任意属性的输出和读取，但是还是建议不要输出静态的和transient属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExternalizable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span><span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;stu.dat&quot;</span>);</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">		</span><br><span class="line">		Object obj = ois.readObject();</span><br><span class="line">		</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">		</span><br><span class="line">		ois.close();</span><br><span class="line">		fis.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		Student student = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="number">89</span>);</span><br><span class="line">		Student.setSchool(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;stu.dat&quot;</span>);</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">		</span><br><span class="line">		oos.writeObject(student);</span><br><span class="line">		</span><br><span class="line">		oos.close();</span><br><span class="line">		fos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="重新认识PrintStream和Scanner、System-in和out"><a href="#重新认识PrintStream和Scanner、System-in和out" class="headerlink" title="重新认识PrintStream和Scanner、System.in和out"></a>重新认识PrintStream和Scanner、System.in和out</h2><h3 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h3><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<h4 id="构造方法-12"><a href="#构造方法-12" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li>
</ul>
<p>构造举例，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;ps.txt&quot;</span>)；</span><br></pre></td></tr></table></figure>

<h4 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h4><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;ps.txt&quot;</span>);</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">      	<span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h3><h4 id="构造方法-13"><a href="#构造方法-13" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li>Scanner(File source) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。 </li>
<li>Scanner(File source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。 </li>
<li>Scanner(InputStream source) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。 </li>
<li>Scanner(InputStream source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。</li>
</ul>
<h4 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h4><ul>
<li>boolean hasNextXxx()： 如果通过使用nextXxx()方法，此扫描器输入信息中的下一个标记可以解释为默认基数中的一个 Xxx 值，则返回 true。</li>
<li>Xxx nextXxx()： 将输入信息的下一个标记扫描为一个Xxx</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			System.out.print(<span class="string">&quot;请输入一个单词：&quot;</span>);</span><br><span class="line">			String str = input.nextLine();</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">&quot;stop&quot;</span>.equals(str))&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			list.add(str);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		input.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;1.txt&quot;</span>));</span><br><span class="line">		<span class="keyword">while</span>(input.hasNextLine())&#123;</span><br><span class="line">			String str = input.nextLine();</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">		input.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">		System.setIn(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;1.txt&quot;</span>));</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">while</span>(input.hasNextLine())&#123;</span><br><span class="line">			String str = input.nextLine();</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">		input.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK1-7之后引入新try-catch"><a href="#JDK1-7之后引入新try-catch" class="headerlink" title="JDK1.7之后引入新try..catch"></a>JDK1.7之后引入新try..catch</h2><p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(需要关闭的资源对象的声明)&#123;</span><br><span class="line">    业务逻辑代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    处理异常代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    处理异常代码</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>它没有finally，也不需要程序员去关闭资源对象，无论是否发生异常，都会关闭资源对象</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//从d:/1.txt(GBK)文件中，读取内容，写到项目根目录下1.txt(UTF-8)文件中</span></span><br><span class="line">	<span class="keyword">try</span>(</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:/1.txt&quot;</span>);</span><br><span class="line">		InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">		</span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">		OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line">	)&#123;</span><br><span class="line">		String str;</span><br><span class="line">		<span class="keyword">while</span>((str = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">			bw.write(str);</span><br><span class="line">			bw.newLine();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><ul>
<li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、红蜘蛛、飞秋等软件。</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174537.jpg"></p>
<p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有IE、谷歌、火狐等。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174541.jpg"></p>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><h3 id="TCP-IP协议参考模型"><a href="#TCP-IP协议参考模型" class="headerlink" title="TCP/IP协议参考模型"></a>TCP/IP协议参考模型</h3><ul>
<li><p><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p>
</li>
<li><p><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p>
</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174545.png" alt="1564019044385"></p>
<p>上图中，OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广。 TCP/IP参考模型(或TCP/IP协议)：事实上的国际标准。</p>
<ul>
<li>TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>  链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</li>
<li>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。而IP协议是一种非常重要的协议。IP（internet protocal）又称为互联网协议。IP的责任就是把数据从源传送到目的地。它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。</li>
<li>传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。TCP（Transmission Control Protocol）协议，即传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。UDP(User Datagram Protocol，用户数据报协议)：是一个无连接的传输层协议、提供面向事务的简单不可靠的信息传送服务。</li>
<li>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</li>
</ul>
<p>而通常我们说的TCP/IP协议，其实是指TCP/IP协议族，因为该协议家族的两个最核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准，所以简称为TCP/IP协议。</p>
<h3 id="TCP与UDP协议"><a href="#TCP与UDP协议" class="headerlink" title="TCP与UDP协议"></a>TCP与UDP协议</h3><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。</p>
<ul>
<li><p><strong>非面向连的，不可靠的：</strong>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>  由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>  但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。</p>
</li>
<li><p><strong>大小限制的</strong>：数据被限制在64kb以内，超出这个范围就不能发送了。</p>
</li>
<li><p>**数据报(Datagram)**：网络传输的基本单位 </p>
</li>
</ul>
</li>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。</p>
<ul>
<li><p><strong>面向连接的，可靠的</strong>：TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。是一种面向连接的、可靠的、基于字节流的传输层的通信协议，可以连续传输大量的数据。类似于打电话的效果。</p>
<p>  这是因为它为当一台计算机需要与另一台远程计算机连接时，TCP协议会采用“三次握手”方式让它们建立一个连接，用于发送和接收数据的虚拟链路。数据传输完毕TCP协议会采用“四次挥手”方式断开连接。</p>
<p>  TCP协议负责收集这些信息包，并将其按适当的次序放好传送，在接收端收到后再将其正确的还原。TCP协议保证了数据包在传送中准确无误。TCP协议使用重发机制，当一个通信实体发送一个消息给另一个通信实体后，需要收到另一个通信实体确认信息，如果没有收到另一个通信实体确认信息，则会再次重复刚才发送的消息。</p>
</li>
</ul>
</li>
<li><p><strong>三次握手：</strong>TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</p>
<ul>
<li><p>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</p>
</li>
<li><p>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</p>
</li>
<li><p>第三次握手，客户端再次向服务器端发送确认信息，确认连接。</p>
</li>
</ul>
</li>
</ul>
<p> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174548.png" alt="1564020243342"></p>
<ul>
<li><strong>四次挥手：</strong>TCP协议中，在发送数据结束后，释放连接时需要经过四次挥手。<ul>
<li>第一次挥手：客户端向服务器端提出结束连接，让服务器做最后的准备工作。此时，客户端处于半关闭状态，即表示不再向服务器发送数据了，但是还可以接受数据。</li>
<li>第二次挥手：服务器接收到客户端释放连接的请求后，会将最后的数据发给客户端。并告知上层的应用进程不再接收数据。</li>
<li>第三次挥手：服务器发送完数据后，会给客户端发送一个释放连接的报文。那么客户端接收后就知道可以正式释放连接了。</li>
<li>第四次挥手：客户端接收到服务器最后的释放连接报文后，要回复一个彻底断开的报文。这样服务器收到后才会彻底释放连接。这里客户端，发送完最后的报文后，会等待2MSL，因为有可能服务器没有收到最后的报文，那么服务器迟迟没收到，就会再次给客户端发送释放连接的报文，此时客户端在等待时间范围内接收到，会重新发送最后的报文，并重新计时。如果等待2MSL后，没有收到，那么彻底断开。</li>
</ul>
</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174551.png" alt="1564021582928"></p>
<p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p>
<h2 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</p>
<p><strong>IP地址分类方式一：</strong></p>
<ul>
<li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p>
<p>  为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><strong>IP地址分类方式二：</strong></p>
<p>公网地址( 万维网使用)和 私有地址( 局域网使用)。192.168.开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用</p>
<p><strong>常用命令：</strong></p>
<ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span></span><br></pre></td></tr></table></figure>

<p><strong>特殊的IP地址：</strong></p>
<ul>
<li>本地回环地址(hostAddress)：<code>127.0.0.1</code>  </li>
<li>主机名(hostName)：<code>localhost</code></li>
</ul>
<p><strong>域名：</strong></p>
<p>因为IP地址数字不便于记忆，因此出现了域名，域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接。 ——- 域名解析</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174555.png" alt="1564021975715"></p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。<ul>
<li>公认端口：0~1023。被预先定义的服务通信占用，如：HTTP（80），FTP（21），Telnet（23）</li>
<li>注册端口：1024~49151。分配给用户进程或应用程序。如：Tomcat（8080），MySQL（3306），Oracle（1521）。</li>
<li>动态/ 私有端口：49152~65535。</li>
</ul>
</li>
</ul>
<p>如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</p>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<h2 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h2><p>InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address。</p>
<p>Internet上的主机有两种方式表示地址：</p>
<ul>
<li>域名(hostName)：<a target="_blank" rel="noopener" href="http://www.atguigu.com/">www.atguigu.com</a></li>
<li>IP 地址(hostAddress)：202.108.35.210</li>
</ul>
<p>lInetAddress 类没有提供公共的构造器，而是提供 了 如下几个 静态方法来获取InetAddress 实例</p>
<ul>
<li>public static InetAddress getLocalHost()</li>
<li>public static InetAddress getByName(String host)</li>
<li>public static InetAddress getByAddress(byte[] addr)</li>
</ul>
<p>InetAddress 提供了如下几个常用的方法</p>
<ul>
<li>public String getHostAddress() ：返回 IP 地址字符串（以文本表现形式）。</li>
<li>public String getHostName() ：获取此 IP 地址的主机名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInetAddress</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException</span>&#123;</span><br><span class="line">		InetAddress localHost = InetAddress.getLocalHost();</span><br><span class="line">		System.out.println(localHost);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span><span class="keyword">throws</span> UnknownHostException</span>&#123;</span><br><span class="line">		InetAddress atguigu = InetAddress.getByName(<span class="string">&quot;www.atguigu.com&quot;</span>);</span><br><span class="line">		System.out.println(atguigu);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span><span class="keyword">throws</span> UnknownHostException</span>&#123;</span><br><span class="line"><span class="comment">//		byte[] addr = &#123;112,54,108,98&#125;;</span></span><br><span class="line">		<span class="keyword">byte</span>[] addr = &#123;(<span class="keyword">byte</span>)<span class="number">192</span>,(<span class="keyword">byte</span>)<span class="number">168</span>,<span class="number">24</span>,<span class="number">56</span>&#125;;</span><br><span class="line">		InetAddress atguigu = InetAddress.getByAddress(addr);</span><br><span class="line">		System.out.println(atguigu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174559.png" alt="1564024137998"></p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>通信的两端都要有Socket（也可以叫“套接字”），是两台机器间通信的端点。网络通信其实就是Socket间的通信。Socket可以分为：</p>
<ul>
<li>流套接字（stream socket）：使用TCP提供可依赖的字节流服务<ul>
<li>ServerSocket：此类实现TCP服务器套接字。服务器套接字等待请求通过网络传入。</li>
<li>Socket：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。</li>
</ul>
</li>
<li>数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务<ul>
<li>DatagramSocket：此类表示用来发送和接收UDP数据报包的套接字。 </li>
</ul>
</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174601.png" alt="1564024229499"></p>
<h2 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h2><h3 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h3><p>Java语言的基于套接字TCP编程分为服务端编程和客户端编程，其通信模型如图所示：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826174604.png" alt="1564025942044"></p>
<h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><p>服务器 程序的工作过程包含以下四个基本的 步骤：</p>
<ul>
<li>调用 ServerSocket(int port)  ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li>
<li>调用 accept() ：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</li>
<li>调用  该Socket 类对象的 getOutputStream()  和 getInputStream () ：获取输出流和输入流，开始网络数据的发送和接收。</li>
<li>关闭Socket 对象：客户端访问结束，关闭通信套接字。</li>
</ul>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>客户端Socket 的工作过程包含以下四个基本的步骤 ：</p>
<ul>
<li>创建 Socket ：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li>
<li>打开连接到 Socket  的输入/ 出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输</li>
<li>按照一定的协议对 Socket 进行读/ 写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线路。</li>
<li>关闭 Socket ：断开客户端到服务器的连接，释放线路</li>
</ul>
<h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p><strong>ServerSocket类的构造方法：</strong></p>
<ul>
<li>ServerSocket(int port) ：创建绑定到特定端口的服务器套接字。</li>
</ul>
<p><strong>ServerSocket类的常用方法：</strong></p>
<ul>
<li>Socket accept()：侦听并接受到此套接字的连接。 </li>
</ul>
<p><strong>Socket类的常用构造方法</strong>：</p>
<ul>
<li>public Socket(InetAddress address,int port)：创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</li>
<li>public Socket(String host,int port)：创建一个流套接字并将其连接到指定主机上的指定端口号。</li>
</ul>
<p><strong>Socket类的常用方法</strong>：</p>
<ul>
<li>public InputStream getInputStream()：返回此套接字的输入流，可以用于接收消息</li>
<li>public OutputStream getOutputStream()：返回此套接字的输出流，可以用于发送消息</li>
<li>public InetAddress getInetAddress()：此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。</li>
<li>public InetAddress getLocalAddress()：获取套接字绑定的本地地址。</li>
<li>public int getPort()：此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。</li>
<li>public int getLocalPort()：返回此套接字绑定到的本地端口。如果尚未绑定套接字，则返回 -1。</li>
<li>public void close()：关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和 OutputStream。 </li>
<li>public void shutdownInput()：如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。</li>
<li>public void shutdownOutput()：禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。</li>
</ul>
<p><strong>注意：</strong>先后调用Socket的shutdownInput()和shutdownOutput()方法，仅仅关闭了输入流和输出流，并不等于调用Socket的close()方法。在通信结束后，仍然要调用Scoket的close()方法，因为只有该方法才会释放Socket占用的资源，比如占用的本地端口号等。</p>
<h3 id="示例一：单个客户端与服务器单次通信"><a href="#示例一：单个客户端与服务器单次通信" class="headerlink" title="示例一：单个客户端与服务器单次通信"></a>示例一：单个客户端与服务器单次通信</h3><p>需求：客户端连接服务器，连接成功后给服务发送“lalala”，服务器收到消息后，给客户端返回“欢迎登录”，客户端接收消息后，断开连接</p>
<h4 id="客户端示例代码"><a href="#客户端示例代码" class="headerlink" title="客户端示例代码"></a>客户端示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 1、准备Socket，连接服务器，需要指定服务器的IP地址和端口号</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2、获取输出流，用来发送数据给服务器</span></span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		<span class="comment">// 发送数据</span></span><br><span class="line">		out.write(<span class="string">&quot;lalala&quot;</span>.getBytes());</span><br><span class="line">		<span class="comment">//会在流末尾写入一个“流的末尾”标记，对方才能读到-1，否则对方的读取方法会一致阻塞</span></span><br><span class="line">		socket.shutdownOutput();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、获取输入流，用来接收服务器发送给该客户端的数据</span></span><br><span class="line">		InputStream input = socket.getInputStream();</span><br><span class="line">		<span class="comment">// 接收数据</span></span><br><span class="line">		<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		<span class="keyword">while</span> ((len = input.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			s.append(<span class="keyword">new</span> String(data, <span class="number">0</span>, len));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;服务器返回的消息是：&quot;</span> + s);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4、关闭socket，不再与服务器通信，即断开与服务器的连接</span></span><br><span class="line">		<span class="comment">//socket关闭，意味着InputStream和OutputStream也关闭了</span></span><br><span class="line">		socket.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务器端示例代码"><a href="#服务器端示例代码" class="headerlink" title="服务器端示例代码"></a>服务器端示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1、准备一个ServerSocket对象，并绑定8888端口</span></span><br><span class="line">		ServerSocket server =  <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//2、在8888端口监听客户端的连接，该方法是个阻塞的方法，如果没有客户端连接，将一直等待</span></span><br><span class="line">		Socket socket = server.accept();</span><br><span class="line">		System.out.println(<span class="string">&quot;一个客户端连接成功！！&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、获取输入流，用来接收该客户端发送给服务器的数据</span></span><br><span class="line">		InputStream input = socket.getInputStream();</span><br><span class="line">		<span class="comment">//接收数据</span></span><br><span class="line">		<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		<span class="keyword">while</span> ((len = input.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			s.append(<span class="keyword">new</span> String(data, <span class="number">0</span>, len));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;客户端发送的消息是：&quot;</span> + s);</span><br><span class="line">				</span><br><span class="line">		<span class="comment">//4、获取输出流，用来发送数据给该客户端</span></span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		<span class="comment">//发送数据</span></span><br><span class="line">		out.write(<span class="string">&quot;欢迎登录&quot;</span>.getBytes());</span><br><span class="line">		out.flush();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5、关闭socket，不再与该客户端通信</span></span><br><span class="line">		<span class="comment">//socket关闭，意味着InputStream和OutputStream也关闭了</span></span><br><span class="line">		socket.close();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//6、如果不再接收任何客户端通信，可以关闭ServerSocket</span></span><br><span class="line">		server.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例二：多个客户端与服务器之间的多次通信"><a href="#示例二：多个客户端与服务器之间的多次通信" class="headerlink" title="示例二：多个客户端与服务器之间的多次通信"></a>示例二：多个客户端与服务器之间的多次通信</h3><p>通常情况下，服务器不应该只接受一个客户端请求，而应该不断地接受来自客户端的所有请求，所以Java程序通常会通过循环，不断地调用ServerSocket的accept()方法。</p>
<p>如果服务器端要“同时”处理多个客户端的请求，因此服务器端需要为<strong>每一个客户端单独分配一个线程</strong>来处理，否则无法实现“同时”。</p>
<p>咱们之前学习IO流的时候，提到过装饰者设计模式，该设计使得不管底层IO流是怎样的节点流：文件流也好，网络Socket产生的流也好，程序都可以将其包装成处理流，甚至可以多层包装，从而提供更多方便的处理。</p>
<p>案例需求：多个客户端连接服务器，并进行多次通信</p>
<ul>
<li>每一个客户端连接成功后，从键盘输入英文单词或中国成语，并发送给服务器</li>
<li>服务器收到客户端的消息后，把词语“反转”后返回给客户端</li>
<li>客户端接收服务器返回的“词语”，打印显示</li>
<li>当客户端输入“stop”时断开与服务器的连接</li>
<li>多个客户端可以同时给服务器发送“词语”，服务器可以“同时”处理多个客户端的请求</li>
</ul>
<p><img src="H:/00%25E3%2580%2581%25E5%25B0%259A%25E7%25A1%2585%25E8%25B0%25B7%25E5%25A4%25A7%25E8%25AF%25BE/2021%25E5%25B9%25B4%25E5%25B0%259A%25E7%25A1%2585%25E8%25B0%25B7Java%25E5%2590%258E%25E7%25AB%25AF%25E9%259D%25A2%25E6%258E%2588%25E7%258F%25AD%25E3%2580%25902021%25E5%25B9%25B45%25E6%259C%2588%25E7%25BB%2593%25E8%25AF%25BE%25E3%2580%2591/%25E8%25AF%25BE%25E4%25BB%25B6/%25E8%25AF%25BE%25E4%25BB%25B6/1.JAVA%25E6%25A0%25B8%25E5%25BF%2583%25E5%259F%25BA%25E7%25A1%2580/1.JAVA%25E6%25A0%25B8%25E5%25BF%2583%25E5%259F%25BA%25E7%25A1%2580%25E3%2580%2590%25E6%25B5%25B7%25E9%2587%258Fit%25E8%25B5%2584%25E6%25BA%2590%25EF%25BC%259A666java.com%25E3%2580%2591/%25E8%25AF%25BE%25E4%25BB%25B6/%25E7%25AC%25AC15%25E7%25AB%25A0%2520%25E7%25BD%2591%25E7%25BB%259C%25E7%25BC%2596%25E7%25A8%258B/imgs/1564027041074.png" alt="1564027041074"></p>
<h4 id="客户端示例代码-1"><a href="#客户端示例代码-1" class="headerlink" title="客户端示例代码"></a>客户端示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 1、准备Socket，连接服务器，需要指定服务器的IP地址和端口号</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2、获取输出流，用来发送数据给服务器</span></span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 3、获取输入流，用来接收服务器发送给该客户端的数据</span></span><br><span class="line">		InputStream input = socket.getInputStream();</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input));</span><br><span class="line">		</span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;输入发送给服务器的单词或成语：&quot;</span>);</span><br><span class="line">			String message = scanner.nextLine();</span><br><span class="line">			<span class="keyword">if</span>(message.equals(<span class="string">&quot;stop&quot;</span>))&#123;</span><br><span class="line">				socket.shutdownOutput();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 4、 发送数据</span></span><br><span class="line">			ps.println(message);</span><br><span class="line">			<span class="comment">// 接收数据</span></span><br><span class="line">			String feedback  = br.readLine();</span><br><span class="line">			System.out.println(<span class="string">&quot;从服务器收到的反馈是：&quot;</span> + feedback);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5、关闭socket，断开与服务器的连接</span></span><br><span class="line">		scanner.close();</span><br><span class="line">		socket.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="服务器端示例代码-1"><a href="#服务器端示例代码-1" class="headerlink" title="服务器端示例代码"></a>服务器端示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 1、准备一个ServerSocket</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;等待连接...&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="comment">// 2、监听一个客户端的连接</span></span><br><span class="line">			Socket socket = server.accept();</span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span> + ++count + <span class="string">&quot;个客户端&quot;</span>+socket.getInetAddress().getHostAddress()+<span class="string">&quot;连接成功！！&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			ClientHandlerThread ct = <span class="keyword">new</span> ClientHandlerThread(socket);</span><br><span class="line">			ct.start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//这里没有关闭server，永远监听</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ClientHandlerThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.socket = socket;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="comment">//（1）获取输入流，用来接收该客户端发送给服务器的数据</span></span><br><span class="line">				BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">				<span class="comment">//（2）获取输出流，用来发送数据给该客户端</span></span><br><span class="line">				PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line">				String str;</span><br><span class="line">				<span class="comment">// （3）接收数据</span></span><br><span class="line">				<span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">//（4）反转</span></span><br><span class="line">					StringBuilder word = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">					word.reverse();</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//（5）返回给客户端</span></span><br><span class="line">					ps.println(word);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(socket.getInetAddress().getHostAddress()+<span class="string">&quot;正常退出&quot;</span>);</span><br><span class="line">			&#125;<span class="keyword">catch</span>(Exception  e)&#123;</span><br><span class="line">				System.out.println(socket.getInetAddress().getHostAddress()+<span class="string">&quot;意外退出&quot;</span>);</span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">//（6）断开连接</span></span><br><span class="line">					socket.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h2><p>UDP(User Datagram Protocol，用户数据报协议)：是一个无连接的传输层协议、提供面向事务的简单不可靠的信息传送服务，类似于短信。</p>
<p>UDP协议是一种<strong>面向非连接</strong>的协议，面向非连接指的是在正式通信前不必与对方先建立连接，不管对方状态就直接发送，至于对方是否可以接收到这些数据内容，UDP协议无法控制，因此说，UDP协议是一种<strong>不可靠的</strong>协议。无连接的好处就是快，省内存空间和流量，因为维护连接需要创建大量的数据结构。UDP会尽最大努力交付数据，但不保证可靠交付，没有TCP的确认机制、重传机制，如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息。</p>
<p>UDP协议是面向数据报文的信息传送服务。UDP在发送端没有缓冲区，对于应用层交付下来的报文在添加了首部之后就直接交付于ip层，不会进行合并，也不会进行拆分，而是一次交付一个完整的报文。比如我们要发送100个字节的报文，我们调用一次send()方法就会发送100字节，接收方也需要用receive()方法一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。</p>
<p>UDP协议没有拥塞控制，所以当网络出现的拥塞不会导致主机发送数据的速率降低。虽然UDP的接收端有缓冲区，但是这个缓冲区只负责接收，并不会保证UDP报文的到达顺序是否和发送的顺序一致。因为网络传输的时候，由于网络拥塞的存在是很大的可能导致先发的报文比后发的报文晚到达。如果此时缓冲区满了，后面到达的报文将直接被丢弃。这个对实时应用来说很重要，比如：视频通话、直播等应用。</p>
<p>因此UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境，数据报大小限制在64K以下。</p>
<h3 id="相关API-1"><a href="#相关API-1" class="headerlink" title="相关API"></a>相关API</h3><p>基于UDP协议的网络编程仍然需要在通信实例的两端各建立一个Socket，但这两个Socket之间并没有虚拟链路，这两个Socket只是发送、接收数据报的对象，Java提供了DatagramSocket对象作为基于UDP协议的Socket，使用DatagramPacket代表DatagramSocket发送、接收的数据报。</p>
<p><strong>DatagramSocket 类的常用方法：</strong></p>
<ul>
<li>public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。</li>
<li>public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。 </li>
<li>public void close()关闭此数据报套接字。 </li>
<li>public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。 </li>
<li>public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时，DatagramPacket 的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。 </li>
</ul>
<p><strong>DatagramPacket类的常用方法：</strong></p>
<ul>
<li>public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 length 参数必须小于等于 buf.length。</li>
<li>public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length 参数必须小于等于 buf.length。</li>
<li>public int getLength()返回将要发送或接收到的数据的长度。 </li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="发送端："><a href="#发送端：" class="headerlink" title="发送端："></a>发送端：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		1、建立发送端的DatagramSocket</span></span><br><span class="line">		DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//要发送的数据</span></span><br><span class="line">		ArrayList&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		all.add(<span class="string">&quot;尚硅谷让天下没有难学的技术！&quot;</span>);</span><br><span class="line">		all.add(<span class="string">&quot;学高端前沿的IT技术来尚硅谷！&quot;</span>);</span><br><span class="line">		all.add(<span class="string">&quot;尚硅谷让你的梦想变得更具体！&quot;</span>);</span><br><span class="line">		all.add(<span class="string">&quot;尚硅谷让你的努力更有价值！&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//接收方的IP地址</span></span><br><span class="line">		InetAddress ip = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">		<span class="comment">//接收方的监听端口号</span></span><br><span class="line">		<span class="keyword">int</span> port = <span class="number">9999</span>;</span><br><span class="line">         <span class="comment">//发送多个数据报</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all.size(); i++) &#123;</span><br><span class="line"><span class="comment">//			2、建立数据包DatagramPacket</span></span><br><span class="line">			<span class="keyword">byte</span>[] data = all.get(i).getBytes();</span><br><span class="line">			DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data, data.length, ip, port);</span><br><span class="line"><span class="comment">//			3、调用Socket的发送方法</span></span><br><span class="line">			ds.send(dp);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		4、关闭Socket</span></span><br><span class="line">		ds.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="接收端："><a href="#接收端：" class="headerlink" title="接收端："></a>接收端：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		1、建立接收端的DatagramSocket，需要指定本端的监听端口号</span></span><br><span class="line">		DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//一直监听数据</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="comment">//		2、建立数据包DatagramPacket</span></span><br><span class="line">			<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">			DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buffer , buffer.length);</span><br><span class="line">			</span><br><span class="line">	<span class="comment">//		3、调用Socket的接收方法</span></span><br><span class="line">			ds.receive(dp);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//4、拆封数据</span></span><br><span class="line">			String str = <span class="keyword">new</span> String(buffer,<span class="number">0</span>,dp.getLength());</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="反射（Reflect）"><a href="#反射（Reflect）" class="headerlink" title="反射（Reflect）"></a>反射（Reflect）</h1><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类在内存中的生命周期：加载–&gt;使用–&gt;卸载</p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。</p>
<p>类的加载又分为三个阶段：</p>
<p>（1）加载：load</p>
<p>就是指将类型的clas字节码数据读入内存</p>
<p>（2）连接：link</p>
<p>①验证：校验合法性等</p>
<p>②准备：准备对应的内存（方法区），创建Class对象，为类变量赋默认值，为静态常量赋初始值。</p>
<p>③解析：把字节码中的符号引用替换为对应的直接地址引用</p>
<p>（3）初始化：initialize（类初始化）即执行<code>&lt;clinit&gt;</code>类初始化方法，大多数情况下，类的加载就完成了类的初始化，有些情况下，会延迟类的初始化。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210826175028.png" alt="1560767438339"></p>
<h3 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h3><p>1、哪些操作会导致类的初始化？</p>
<p>（1）运行主方法所在的类，要先完成类初始化，再执行main方法</p>
<p>（2）第一次使用某个类型就是在new它的对象，此时这个类没有初始化的话，先完成类初始化再做实例初始化</p>
<p>（3）调用某个类的静态成员（类变量和类方法），此时这个类没有初始化的话，先完成类初始化</p>
<p>（4）子类初始化时，发现它的父类还没有初始化的话，那么先初始化父类</p>
<p>（5）通过反射操作某个类时，如果这个类没有初始化，也会导致该类先初始化</p>
<blockquote>
<p>类初始化执行的是<clinit>()，该方法由（1）类变量的显式赋值代码（2）静态代码块中的代码构成</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;main方法所在的类的父类(1)&quot;</span>);<span class="comment">//初始化子类时，会初始化父类</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClinit1</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;main方法所在的类(2)&quot;</span>);<span class="comment">//主方法所在的类会初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> A();<span class="comment">//第一次使用A就是创建它的对象，会初始化A类</span></span><br><span class="line">		</span><br><span class="line">		B.test();<span class="comment">//直接使用B类的静态成员会初始化B类</span></span><br><span class="line">		</span><br><span class="line">		Class clazz = Class.forName(<span class="string">&quot;com.atguigu.test02.C&quot;</span>);<span class="comment">//通过反射操作C类，会初始化C类</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;A类初始化&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B类初始化&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B类的静态方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;C类初始化&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、哪些使用类的操作，但是不会导致类的初始化？</p>
<p>（1）使用某个类的静态的常量（static  final）</p>
<p>（2）通过子类调用父类的静态变量，静态方法，只会导致父类初始化，不会导致子类初始化，即只有声明静态成员的类才会初始化</p>
<p>（3）用某个类型声明数组并创建数组对象时，不会导致这个类初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClinit2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(D.NUM);<span class="comment">//D类不会初始化，因为NUM是final的</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(F.num);</span><br><span class="line">		F.test();<span class="comment">//F类不会初始化，E类会初始化，因为num和test()是在E类中声明的</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//G类不会初始化，此时还没有正式用的G类</span></span><br><span class="line">		G[] arr = <span class="keyword">new</span> G[<span class="number">5</span>];<span class="comment">//没有创建G的对象，创建的是准备用来装G对象的数组对象</span></span><br><span class="line">        <span class="comment">//G[]是一种新的类型，是数组类想，动态编译生成的一种新的类型</span></span><br><span class="line">        <span class="comment">//G[].class</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D类的初始化&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;E父类的初始化&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;父类的静态方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">E</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;F子类的初始化&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;G类的初始化&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>很多开发人员都遇到过java.lang.ClassNotFoundException或java.lang.NoClassDefError，想要更好的解决这类问题，或者在一些特殊的应用场景，比如需要支持类的动态加载或需要对编译后的字节码文件进行加密解密操作，那么需要你自定义类加载器，因此了解类加载器及其类加载机制也就成了每一个Java开发人员的必备技能之一。</p>
<p><strong>1、类加载器分为：</strong></p>
<p>（1）引导类加载器（Bootstrap Classloader）又称为根类加载器</p>
<pre><code>它负责加载jre/rt.jar核心库
它本身不是Java代码实现的，也不是ClassLoader的子类，获取它的对象时往往返回null
</code></pre>
<p>（2）扩展类加载器（Extension ClassLoader）</p>
<pre><code>它负责加载jre/lib/ext扩展库
它是ClassLoader的子类
</code></pre>
<p>（3）应用程序类加载器（Application Classloader）</p>
<pre><code>它负责加载项目的classpath路径下的类

它是ClassLoader的子类
</code></pre>
<p>（4）自定义类加载器</p>
<pre><code>当你的程序需要加载“特定”目录下的类，可以自定义类加载器；
当你的程序的字节码文件需要加密时，那么往往会提供一个自定义类加载器对其进行解码
后面会见到的自定义类加载器：tomcat中
</code></pre>
<p><strong>2、Java系统类加载器的双亲委托模式</strong></p>
<p>简单描述：</p>
<pre><code>下一级的类加载器，如果接到任务时，会先搜索是否加载过，如果没有，会先把任务往上传，如果都没有加载过，一直到根加载器，如果根加载器在它负责的路径下没有找到，会往回传，如果一路回传到最后一级都没有找到，那么会报ClassNotFoundException或NoClassDefError，如果在某一级找到了，就直接返回Class对象。
</code></pre>
<p>应用程序类加载器  把  扩展类加载器视为父加载器，</p>
<p>扩展类加载器 把 引导类加载器视为父加载器。</p>
<p>不是继承关系，是组合的方式实现的。</p>
<h2 id="javalang-Class类"><a href="#javalang-Class类" class="headerlink" title="javalang.Class类"></a>javalang.Class类</h2><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p>
<p>要想解剖一个类，必须先要获取到该类的Class对象。而剖析一个类或用反射解决具体的问题就是使用相关API（1）java.lang.Class（2）java.lang.reflect.*。所以，Class对象是反射的根源。</p>
<h3 id="哪些类型可以获取Class对象"><a href="#哪些类型可以获取Class对象" class="headerlink" title="哪些类型可以获取Class对象"></a>哪些类型可以获取Class对象</h3><p>所有Java类型</p>
<p>用代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1）基本数据类型和void</span></span><br><span class="line">例如：<span class="keyword">int</span>.class</span><br><span class="line">	 <span class="keyword">void</span>.class</span><br><span class="line"><span class="comment">//（2）类和接口</span></span><br><span class="line">例如：String.class</span><br><span class="line">	Comparable.class</span><br><span class="line"><span class="comment">//（3）枚举</span></span><br><span class="line">例如：ElementType.class</span><br><span class="line"><span class="comment">//（4）注解</span></span><br><span class="line">例如：Override.class</span><br><span class="line"><span class="comment">//（5）数组</span></span><br><span class="line">例如：<span class="keyword">int</span>[].class</span><br></pre></td></tr></table></figure>

<h3 id="获取Class对象的四种方式"><a href="#获取Class对象的四种方式" class="headerlink" title="获取Class对象的四种方式"></a>获取Class对象的四种方式</h3><p>（1）类型名.class</p>
<p>要求编译期间已知类型</p>
<p>（2）对象.getClass()</p>
<p>获取对象的运行时类型</p>
<p>（3）Class.forName(类型全名称)</p>
<p> 可以获取编译期间未知的类型</p>
<p>（4）ClassLoader的类加载器对象.loadClass(类型全名称)</p>
<p>可以用系统类加载对象或自定义加载器对象加载指定路径下的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">		Class c = TestClass.class;</span><br><span class="line">		ClassLoader loader = c.getClassLoader();</span><br><span class="line">		</span><br><span class="line">		Class c2 = loader.loadClass(<span class="string">&quot;com.atguigu.test05.Employee&quot;</span>);</span><br><span class="line">		Class c3 = Employee.class;</span><br><span class="line">		System.out.println(c2 == c3);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">		Class c2 = String.class;</span><br><span class="line">		Class c1 = <span class="string">&quot;&quot;</span>.getClass();</span><br><span class="line">		Class c3 = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(c1 == c2);</span><br><span class="line">		System.out.println(c1 == c3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看某个类的类加载器对象"><a href="#查看某个类的类加载器对象" class="headerlink" title="查看某个类的类加载器对象"></a>查看某个类的类加载器对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取应用程序类加载器对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取扩展类加载器对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取根加载器对象</span></span><br></pre></td></tr></table></figure>



<h2 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h2><h3 id="获取类型的详细信息"><a href="#获取类型的详细信息" class="headerlink" title="获取类型的详细信息"></a>获取类型的详细信息</h3><p>可以获取：包、修饰符、类型名、父类（包括泛型父类）、父接口（包括泛型父接口）、成员（属性、构造器、方法）、注解（类上的、方法上的、属性上的）</p>
<p>示例代码获取常规信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassInfo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, SecurityException </span>&#123;</span><br><span class="line">		<span class="comment">//1、先得到某个类型的Class对象</span></span><br><span class="line">		Class clazz = String.class;</span><br><span class="line">		<span class="comment">//比喻clazz好比是镜子中的影子</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、获取类信息</span></span><br><span class="line">		<span class="comment">//（1）获取包对象，即所有java的包，都是Package的对象</span></span><br><span class="line">		Package pkg = clazz.getPackage();</span><br><span class="line">		System.out.println(<span class="string">&quot;包名：&quot;</span> + pkg.getName());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//（2）获取修饰符</span></span><br><span class="line">		<span class="comment">//其实修饰符是Modifier，里面有很多常量值</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 0x是十六进制</span></span><br><span class="line"><span class="comment">		 * PUBLIC           = 0x00000001;  1    1</span></span><br><span class="line"><span class="comment">		 * PRIVATE          = 0x00000002;  2	10</span></span><br><span class="line"><span class="comment">		 * PROTECTED        = 0x00000004;  4	100</span></span><br><span class="line"><span class="comment">		 * STATIC           = 0x00000008;  8	1000</span></span><br><span class="line"><span class="comment">		 * FINAL            = 0x00000010;  16	10000</span></span><br><span class="line"><span class="comment">		 * ...</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 设计的理念，就是用二进制的某一位是1，来代表一种修饰符，整个二进制中只有一位是1，其余都是0</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * mod = 17          0x00000011</span></span><br><span class="line"><span class="comment">		 * if ((mod &amp; PUBLIC) != 0)  说明修饰符中有public</span></span><br><span class="line"><span class="comment">		 * if ((mod &amp; FINAL) != 0)   说明修饰符中有final</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> mod = clazz.getModifiers();</span><br><span class="line">		System.out.println(Modifier.toString(mod));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//（3）类型名</span></span><br><span class="line">		String name = clazz.getName();</span><br><span class="line">		System.out.println(name);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//（4）父类，父类也有父类对应的Class对象</span></span><br><span class="line">		Class superclass = clazz.getSuperclass();</span><br><span class="line">		System.out.println(superclass);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//（5）父接口们</span></span><br><span class="line">		Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">		<span class="keyword">for</span> (Class class1 : interfaces) &#123;</span><br><span class="line">			System.out.println(class1);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//（6）类的属性，  你声明的一个属性，它是Field的对象</span></span><br><span class="line"><span class="comment">/*		Field clazz.getField(name)  根据属性名获取一个属性对象，但是只能得到公共的</span></span><br><span class="line"><span class="comment">		Field[] clazz.getFields();  获取所有公共的属性</span></span><br><span class="line"><span class="comment">		Field clazz.getDeclaredField(name)  根据属性名获取一个属性对象，可以获取已声明的</span></span><br><span class="line"><span class="comment">		Field[] clazz.getDeclaredFields()	获取所有已声明的属性</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		Field valueField = clazz.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">//		System.out.println(&quot;valueField = &quot; +valueField);</span></span><br><span class="line">		</span><br><span class="line">		Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">		<span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">			<span class="comment">//修饰符、数据类型、属性名    </span></span><br><span class="line">			<span class="keyword">int</span> modifiers = field.getModifiers();</span><br><span class="line">			System.out.println(<span class="string">&quot;属性的修饰符：&quot;</span> + Modifier.toString(modifiers));</span><br><span class="line">			</span><br><span class="line">			String name2 = field.getName();</span><br><span class="line">			System.out.println(<span class="string">&quot;属性名：&quot;</span> + name2);</span><br><span class="line">			</span><br><span class="line">			Class&lt;?&gt; type = field.getType();</span><br><span class="line">			System.out.println(<span class="string">&quot;属性的数据类型：&quot;</span> + type);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">		<span class="comment">//（7）构造器们</span></span><br><span class="line">		Constructor[] constructors = clazz.getDeclaredConstructors();</span><br><span class="line">		<span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">			<span class="comment">//修饰符、构造器名称、构造器形参列表  、抛出异常列表</span></span><br><span class="line">			<span class="keyword">int</span> modifiers = constructor.getModifiers();</span><br><span class="line">			System.out.println(<span class="string">&quot;构造器的修饰符：&quot;</span> + Modifier.toString(modifiers));</span><br><span class="line">			</span><br><span class="line">			String name2 = constructor.getName();</span><br><span class="line">			System.out.println(<span class="string">&quot;构造器名：&quot;</span> + name2);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//形参列表</span></span><br><span class="line">			System.out.println(<span class="string">&quot;形参列表：&quot;</span>);</span><br><span class="line">			Class[] parameterTypes = constructor.getParameterTypes();</span><br><span class="line">			<span class="keyword">for</span> (Class parameterType : parameterTypes) &#123;</span><br><span class="line">				System.out.println(parameterType);</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//异常列表</span></span><br><span class="line">			System.out.println(<span class="string">&quot;异常列表：&quot;</span>);</span><br><span class="line">			Class&lt;?&gt;[] exceptionTypes = constructor.getExceptionTypes();</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; exceptionType : exceptionTypes) &#123;</span><br><span class="line">				System.out.println(exceptionType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;=--------------------------------&quot;</span>);</span><br><span class="line">		<span class="comment">//(8)方法们</span></span><br><span class="line">		Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">		<span class="keyword">for</span> (Method method : declaredMethods) &#123;</span><br><span class="line">			<span class="comment">//修饰符、返回值类型、方法名、形参列表 、异常列表 </span></span><br><span class="line">			<span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">			System.out.println(<span class="string">&quot;方法的修饰符：&quot;</span> + Modifier.toString(modifiers));</span><br><span class="line">			</span><br><span class="line">			Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">			System.out.println(<span class="string">&quot;返回值类型:&quot;</span> + returnType);</span><br><span class="line">			</span><br><span class="line">			String name2 = method.getName();</span><br><span class="line">			System.out.println(<span class="string">&quot;方法名：&quot;</span> + name2);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//形参列表</span></span><br><span class="line">			System.out.println(<span class="string">&quot;形参列表：&quot;</span>);</span><br><span class="line">			Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line">			<span class="keyword">for</span> (Class parameterType : parameterTypes) &#123;</span><br><span class="line">				System.out.println(parameterType);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//异常列表</span></span><br><span class="line">			System.out.println(<span class="string">&quot;异常列表：&quot;</span>);</span><br><span class="line">			Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; exceptionType : exceptionTypes) &#123;</span><br><span class="line">				System.out.println(exceptionType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="创建任意引用类型的对象"><a href="#创建任意引用类型的对象" class="headerlink" title="创建任意引用类型的对象"></a>创建任意引用类型的对象</h3><p>两种方式：</p>
<p>1、直接通过Class对象来实例化（要求必须有无参构造）</p>
<p>2、通过获取构造器对象来进行实例化</p>
<p>方式一的步骤：</p>
<p>（1）获取该类型的Class对象（2）创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.atguigu.test.Student&quot;</span>);</span><br><span class="line">		<span class="comment">//Caused by: java.lang.NoSuchMethodException: com.atguigu.test.Student.&lt;init&gt;()</span></span><br><span class="line">		<span class="comment">//即说明Student没有无参构造，就没有无参实例初始化方法&lt;init&gt;</span></span><br><span class="line">		Object stu = clazz.newInstance();</span><br><span class="line">		System.out.println(stu);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException</span>&#123;</span><br><span class="line"><span class="comment">//		AtGuigu obj = new AtGuigu();//编译期间无法创建</span></span><br><span class="line">		</span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.atguigu.test.AtGuigu&quot;</span>);</span><br><span class="line">		<span class="comment">//clazz代表com.atguigu.test.AtGuigu类型</span></span><br><span class="line">		<span class="comment">//clazz.newInstance()创建的就是AtGuigu的对象</span></span><br><span class="line">		Object obj = clazz.newInstance();</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>方式二的步骤：</p>
<p>（1）获取该类型的Class对象（2）获取构造器对象（3）创建对象</p>
<blockquote>
<p>如果构造器的权限修饰符修饰的范围不可见，也可以调用setAccessible(true)</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNewInstance</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//(1)获取Class对象</span></span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.atguigu.test.Student&quot;</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 获取Student类型中的有参构造</span></span><br><span class="line"><span class="comment">		 * 如果构造器有多个，我们通常是根据形参【类型】列表来获取指定的一个构造器的</span></span><br><span class="line"><span class="comment">		 * 例如：public Student(int id, String name) </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//(2)获取构造器对象</span></span><br><span class="line">		Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class,String.class);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(3)创建实例对象</span></span><br><span class="line">		<span class="comment">// T newInstance(Object... initargs)  这个Object...是在创建对象时，给有参构造的实参列表</span></span><br><span class="line">		Object obj = constructor.newInstance(<span class="number">2</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作任意类型的属性"><a href="#操作任意类型的属性" class="headerlink" title="操作任意类型的属性"></a>操作任意类型的属性</h3><p>（1）获取该类型的Class对象<br>Class clazz = Class.forName(“com.atguigu.bean.User”);</p>
<p>（2）获取属性对象<br>Field field = clazz.getDeclaredField(“username”);</p>
<p>（3）设置属性可访问</p>
<p>field.setAccessible(true);</p>
<p>（4）创建实例对象：如果操作的是非静态属性，需要创建实例对象<br>Object obj = clazz.newInstance();</p>
<p>（4）设置属性值</p>
<p>field.set(obj,”chai”);<br>（5）获取属性值<br>Object value = field.get(obj);</p>
<blockquote>
<p>如果操作静态变量，那么实例对象可以省略，用null表示</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1、获取Student的Class对象</span></span><br><span class="line">		Class clazz = Class.forName(<span class="string">&quot;com.atguigu.test.Student&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、获取属性对象，例如：id属性</span></span><br><span class="line">		Field idField = clazz.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、如果id是私有的等在当前类中不可访问access的，我们需要做如下操作</span></span><br><span class="line">		idField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4、创建实例对象，即，创建Student对象</span></span><br><span class="line">		Object stu = clazz.newInstance();</span><br><span class="line">				</span><br><span class="line">		<span class="comment">//5、获取属性值</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 以前：int 变量= 学生对象.getId()</span></span><br><span class="line"><span class="comment">		 * 现在：Object id属性对象.get(学生对象)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Object value = idField.get(stu);</span><br><span class="line">		System.out.println(<span class="string">&quot;id = &quot;</span>+ value);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//6、设置属性值</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 以前：学生对象.setId(值)</span></span><br><span class="line"><span class="comment">		 * 现在：id属性对象.set(学生对象,值)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		idField.set(stu, <span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">		value = idField.get(stu);</span><br><span class="line">		System.out.println(<span class="string">&quot;id = &quot;</span>+ value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用任意类型的方法"><a href="#调用任意类型的方法" class="headerlink" title="调用任意类型的方法"></a>调用任意类型的方法</h3><p>（1）获取该类型的Class对象<br>Class clazz = Class.forName(“com.atguigu.service.UserService”);<br>（2）获取方法对象<br>Method method = clazz.getDeclaredMethod(“login”,String.class,String.class);<br>（3）创建实例对象<br>Object obj = clazz.newInstance();<br>（4）调用方法<br>Object result = method.invoke(obj,”chai”,”123);</p>
<blockquote>
<p>如果方法的权限修饰符修饰的范围不可见，也可以调用setAccessible(true)</p>
<p>如果方法是静态方法，实例对象也可以省略，用null代替</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMethod</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 1、获取Student的Class对象</span></span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.atguigu.test.Student&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、获取方法对象</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 在一个类中，唯一定位到一个方法，需要：（1）方法名（2）形参列表，因为方法可能重载</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 例如：void setName(String name)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Method method = clazz.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、创建实例对象</span></span><br><span class="line">		Object stu = clazz.newInstance();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4、调用方法</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 以前：学生对象.setName(值)</span></span><br><span class="line"><span class="comment">		 * 现在：方法对象.invoke(学生对象，值)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		method.invoke(stu, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(stu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取泛型父类信息"><a href="#获取泛型父类信息" class="headerlink" title="获取泛型父类信息"></a>获取泛型父类信息</h3><p>示例代码获取泛型父类信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Type：</span></span><br><span class="line"><span class="comment"> * （1）Class</span></span><br><span class="line"><span class="comment"> * （2）ParameterizedType   </span></span><br><span class="line"><span class="comment"> * 		例如：Father&lt;String,Integer&gt;</span></span><br><span class="line"><span class="comment"> * 			ArrayList&lt;String&gt;</span></span><br><span class="line"><span class="comment"> * （3）TypeVariable</span></span><br><span class="line"><span class="comment"> * 		例如：T，U,E,K,V</span></span><br><span class="line"><span class="comment"> * （4）WildcardType</span></span><br><span class="line"><span class="comment"> * 		例如：</span></span><br><span class="line"><span class="comment"> * 		ArrayList&lt;?&gt;</span></span><br><span class="line"><span class="comment"> * 		ArrayList&lt;? super 下限&gt;</span></span><br><span class="line"><span class="comment"> * 		ArrayList&lt;? extends 上限&gt;</span></span><br><span class="line"><span class="comment"> * （5）GenericArrayType</span></span><br><span class="line"><span class="comment"> * 		例如：T[]</span></span><br><span class="line"><span class="comment"> * 	</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//需求：在运行时，获取Son类型的泛型父类的泛型实参&lt;String,Integer&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//（1）还是先获取Class对象</span></span><br><span class="line">		Class clazz = Son.class;<span class="comment">//四种形式任意一种都可以</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//（2）获取泛型父类</span></span><br><span class="line"><span class="comment">//		Class sc = clazz.getSuperclass();</span></span><br><span class="line"><span class="comment">//		System.out.println(sc);</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * getSuperclass()只能得到父类名，无法得到父类的泛型实参列表</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Type type = clazz.getGenericSuperclass();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Father&lt;String,Integer&gt;属于ParameterizedType</span></span><br><span class="line">		ParameterizedType pt = (ParameterizedType) type;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//（3）获取泛型父类的泛型实参列表</span></span><br><span class="line">		Type[] typeArray = pt.getActualTypeArguments();</span><br><span class="line">		<span class="keyword">for</span> (Type type2 : typeArray) &#123;</span><br><span class="line">			System.out.println(type2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型形参：&lt;T,U&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型实参：&lt;String,Integer&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取注解信息"><a href="#读取注解信息" class="headerlink" title="读取注解信息"></a>读取注解信息</h3><p>示例代码读取注解信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnotation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//需求：可以获取MyClass类型上面配置的注解@MyAnnotation的value值</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//读取注解</span></span><br><span class="line"><span class="comment">//		（1）获取Class对象</span></span><br><span class="line">		Class&lt;MyClass&gt; clazz = MyClass.class;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//（2）获取注解对象</span></span><br><span class="line">		<span class="comment">//获取指定注解对象</span></span><br><span class="line">		MyAnnotation my = clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//（3）获取配置参数值</span></span><br><span class="line">		String value = my.value();</span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>  <span class="comment">//说明这个注解可以保留到运行时</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span> <span class="comment">//说明这个注解只能用在类型上面，包括类，接口，枚举等</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">	<span class="comment">//配置参数，如果只有一个配置参数，并且名称是value，在赋值时可以省略value=</span></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用注解</span></span><br><span class="line"><span class="meta">@MyAnnotation(&quot;/login&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取内部类或外部类信息"><a href="#获取内部类或外部类信息" class="headerlink" title="获取内部类或外部类信息"></a>获取内部类或外部类信息</h3><p>public Class&lt;?&gt;[] getClasses()：返回所有公共内部类和内部接口。包括从超类继承的公共类和接口成员以及该类声明的公共类和接口成员。</p>
<p>public Class&lt;?&gt;[] getDeclaredClasses()：返回 Class 对象的一个数组，这些对象反映声明为此 Class 对象所表示的类的成员的所有类和接口。包括该类所声明的公共、保护、默认（包）访问及私有类和接口，但不包括继承的类和接口。</p>
<p>public Class&lt;?&gt; getDeclaringClass()：如果此 Class 对象所表示的类或接口是一个内部类或内部接口，则返回它的外部类或外部接口，否则返回null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Class&lt;?&gt; clazz = Map.class;</span><br><span class="line">	Class&lt;?&gt;[] inners = clazz.getDeclaredClasses();</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; inner : inners) &#123;</span><br><span class="line">		System.out.println(inner);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Class&lt;?&gt; ec = Map.Entry.class;</span><br><span class="line">	Class&lt;?&gt; outer = ec.getDeclaringClass();</span><br><span class="line">	System.out.println(outer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态创建和操作任意类型的数组"><a href="#动态创建和操作任意类型的数组" class="headerlink" title="动态创建和操作任意类型的数组"></a>动态创建和操作任意类型的数组</h3><p>在java.lang.reflect包下还提供了一个Array类，Array对象可以代表所有的数组。程序可以通过使用Array类来动态的创建数组，操作数组元素等。</p>
<p>Array类提供了如下几个方法：</p>
<p>public static Object newInstance(Class&lt;?&gt; componentType, int… dimensions)：创建一个具有指定的组件类型和维度的新数组。</p>
<p>public static void setXxx(Object array,int index,xxx value)：将array数组中[index]元素的值修改为value。此处的Xxx对应8种基本数据类型，如果该属性的类型是引用数据类型，则直接使用set(Object array,int index, Object value)方法。</p>
<p>public static xxx getXxx(Object array,int index,xxx value)：将array数组中[index]元素的值返回。此处的Xxx对应8种基本数据类型，如果该属性的类型是引用数据类型，则直接使用get(Object array,int index)方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArray</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object arr = Array.newInstance(String.class, <span class="number">5</span>);</span><br><span class="line">		Array.set(arr, <span class="number">0</span>, <span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		Array.set(arr, <span class="number">1</span>, <span class="string">&quot;佟刚&quot;</span>);</span><br><span class="line">		System.out.println(Array.get(arr, <span class="number">0</span>));</span><br><span class="line">		System.out.println(Array.get(arr, <span class="number">1</span>));</span><br><span class="line">		System.out.println(Array.get(arr, <span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://andice-cream.github.io/post/251291a.html">https://andice-cream.github.io/post/251291a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://andice-cream.github.io" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javase%E5%9F%BA%E7%A1%80/">javase基础</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212025.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/9559cc75.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212035.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">XML和Dom4j、正则表达式</div></div></a></div><div class="next-post pull-right"><a href="/post/9b5878a0.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212025.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaSE基础-1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/9b5878a0.html" title="JavaSE基础-1"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212025.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-08</div><div class="title">JavaSE基础-1</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">异常概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.1.</span> <span class="toc-text">引入异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">异常体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">异常分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.1.</span> <span class="toc-text">演示常见的错误和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VirtualMachineError"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">VirtualMachineError</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">运行时异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">编译时异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">异常的抛出机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">异常的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8throw"><span class="toc-number">1.5.1.</span> <span class="toc-text">异常throw</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A01"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">练习1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A02"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">练习2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8throws"><span class="toc-number">1.5.2.</span> <span class="toc-text">声明异常throws</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8try%E2%80%A6catch"><span class="toc-number">1.5.3.</span> <span class="toc-text">捕获异常try…catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally%E5%9D%97"><span class="toc-number">1.5.4.</span> <span class="toc-text">finally块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally%E4%B8%8Ereturn"><span class="toc-number">1.5.5.</span> <span class="toc-text">finally与return</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F%E4%B8%80%EF%BC%9A%E4%BB%8Etry%E5%9B%9E%E6%9D%A5"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">形式一：从try回来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BB%8Ecatch%E5%9B%9E%E6%9D%A5"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">形式二：从catch回来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F%E4%B8%89%EF%BC%9A%E4%BB%8Efinally%E5%9B%9E%E6%9D%A5"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">形式三：从finally回来</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.6.</span> <span class="toc-text">异常注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.7.</span> <span class="toc-text">自定义异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">并发与并行（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">线程与进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">每个应用程序的运行都是一个进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%9A%E6%AC%A1%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">一个应用程序的多次运行，就是多个进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">一个进程中包含多个线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.1.3.</span> <span class="toc-text">线程调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A6%E8%A1%8C%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">另行创建和启动线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">继承Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.2.</span> <span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">使用匿名内部类对象来实现线程的创建和启动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">Thread类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%B3%BB%E5%88%971"><span class="toc-number">2.3.2.</span> <span class="toc-text">常用方法系列1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%B3%BB%E5%88%972"><span class="toc-number">2.3.3.</span> <span class="toc-text">9.3.3 常用方法系列2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%80%92%E8%AE%A1%E6%97%B6"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">示例代码：倒计时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%BC%BA%E8%A1%8C%E5%8A%A0%E5%A1%9E"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">示例代码：强行加塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-4-volatile%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">2.3.4.</span> <span class="toc-text">9.3.4 volatile保证线程间的数据的可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-5%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.3.5.</span> <span class="toc-text">9.3.5守护线程（了解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">2.4.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.1.</span> <span class="toc-text">同一个资源问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8D%E8%83%BD%E5%85%B1%E4%BA%AB"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">局部变量不能共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E4%B8%8D%E5%85%B1%E4%BA%AB"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">不同对象的实例变量不共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">静态变量是共享的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%85%B1%E4%BA%AB"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">同一个对象的实例变量共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96%E8%B5%84%E6%BA%90%E7%B1%BB%EF%BC%8C%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.1.5.</span> <span class="toc-text">抽取资源类，共享同一个资源对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.2.</span> <span class="toc-text">尝试解决线程安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%AF%B9%E8%B1%A1%E9%80%89%E6%8B%A9"><span class="toc-number">2.4.3.</span> <span class="toc-text">锁对象选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E9%94%81%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">1、同步方法的锁对象问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80%EF%BC%9A"><span class="toc-number">2.4.3.1.1.</span> <span class="toc-text">示例代码一：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BA%8C%EF%BC%9A"><span class="toc-number">2.4.3.1.2.</span> <span class="toc-text">示例代码二：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%89%EF%BC%9A"><span class="toc-number">2.4.3.1.3.</span> <span class="toc-text">示例代码三：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E9%94%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">2、同步代码块的锁对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80%EF%BC%9Athis%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.3.2.1.</span> <span class="toc-text">示例代码一：this对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BA%8C%EF%BC%9Athis%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.3.2.2.</span> <span class="toc-text">示例代码二：this对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%89%EF%BC%9A%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.3.2.3.</span> <span class="toc-text">示例代码三：其他对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E8%8C%83%E5%9B%B4%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.4.</span> <span class="toc-text">锁的范围问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80%EF%BC%9A%E9%94%81%E8%8C%83%E5%9B%B4%E5%A4%AA%E5%B0%8F"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">示例代码一：锁范围太小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BA%8C%EF%BC%9A%E9%94%81%E8%8C%83%E5%9B%B4%E5%A4%AA%E5%B0%8F"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">示例代码二：锁范围太小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%89%EF%BC%9A%E9%94%81%E8%8C%83%E5%9B%B4%E5%A4%AA%E5%A4%A7"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">示例代码三：锁范围太大</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9B%9B%EF%BC%9A%E9%94%81%E8%8C%83%E5%9B%B4%E5%A4%AA%E5%A4%A7"><span class="toc-number">2.4.4.4.</span> <span class="toc-text">示例代码四：锁范围太大</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%A2%EF%BC%9F"><span class="toc-number">2.4.5.</span> <span class="toc-text">如何编写多线程的程序呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.6.</span> <span class="toc-text">单例设计模式的线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%A5%BF%E6%B1%89%E5%BC%8F%E6%B2%A1%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">1、饿汉式没有线程安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%87%92%E6%B1%89%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.6.2.</span> <span class="toc-text">2、懒汉式线程安全问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">等待唤醒机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">2.5.1.</span> <span class="toc-text">线程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6-1"><span class="toc-number">2.5.2.</span> <span class="toc-text">等待唤醒机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.3.</span> <span class="toc-text">生产者与消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%8E%A8%E5%B8%88%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%91%98%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">一个厨师一个服务员问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%8E%A8%E5%B8%88%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%91%98%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">多个厨师多个服务员问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1"><span class="toc-number">2.5.4.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.6.</span> <span class="toc-text">线程生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E7%82%B91%EF%BC%9A5%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.6.1.</span> <span class="toc-text">观点1：5种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E7%82%B92%EF%BC%9A6%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.6.2.</span> <span class="toc-text">观点2：6种状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="toc-number">2.7.</span> <span class="toc-text">释放锁操作与死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.1.</span> <span class="toc-text">释放锁的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.2.</span> <span class="toc-text">不会释放锁的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">2.7.3.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Asleep-%E5%92%8Cwait-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.4.</span> <span class="toc-text">面试题：sleep()和wait()方法的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80API%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">基础API与常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">和数学相关的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-Math"><span class="toc-number">3.1.1.</span> <span class="toc-text">java.lang.Math</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-2"><span class="toc-number">3.1.1.0.1.</span> <span class="toc-text">练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-math%E5%8C%85"><span class="toc-number">3.1.2.</span> <span class="toc-text">java.math包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BigInteger"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">BigInteger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RoundingMode%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">RoundingMode枚举类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BigDecimal"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">BigDecimal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-Random"><span class="toc-number">3.1.3.</span> <span class="toc-text">java.util.Random</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-number">3.2.</span> <span class="toc-text">日期时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-8%E4%B9%8B%E5%89%8D"><span class="toc-number">3.2.1.</span> <span class="toc-text">JDK1.8之前</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-Date"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">java.util.Date</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-TimeZone"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">java.util.TimeZone</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-Calendar"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">java.util.Calendar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-text-SimpleDateFormat"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">java.text.SimpleDateFormat</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-8%E4%B9%8B%E5%90%8E"><span class="toc-number">3.2.2.</span> <span class="toc-text">JDK1.8之后</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%EF%BC%9ALocalDate%E3%80%81LocalTime%E3%80%81LocalDateTime"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">本地日期时间：LocalDate、LocalTime、LocalDateTime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%97%B6%E5%8C%BA%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%EF%BC%9AZonedDateTime"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">指定时区日期时间：ZonedDateTime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4%EF%BC%9APeriod%E5%92%8CDuration"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">持续日期&#x2F;时间：Period和Duration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DateTimeFormatter%EF%BC%9A%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">DateTimeFormatter：日期时间格式化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">系统相关类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-System%E7%B1%BB"><span class="toc-number">3.3.1.</span> <span class="toc-text">java.lang.System类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-Runtime%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">java.lang.Runtime类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%AE%97%E6%B3%95%E5%8D%87%E5%8D%8E"><span class="toc-number">3.4.</span> <span class="toc-text">数组的算法升华</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%AE%97%E6%B3%95%E5%8D%87%E5%8D%8E-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">数组的算法升华</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%8D%E8%BD%AC"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">数组的反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">数组的扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">数组元素的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">数组元素的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.4.1.5.</span> <span class="toc-text">数组的二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">3.4.1.6.</span> <span class="toc-text">数组的直接选择排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">3.4.2.</span> <span class="toc-text">数组工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.4.3.</span> <span class="toc-text">数组面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%981"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">编程题1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%982"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">编程题2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%983"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">编程题3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%984"><span class="toc-number">3.4.3.4.</span> <span class="toc-text">编程题4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%985"><span class="toc-number">3.4.3.5.</span> <span class="toc-text">编程题5</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0"><span class="toc-number">3.4.4.</span> <span class="toc-text">附加</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">1、折半插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">快速排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.5.1.</span> <span class="toc-text">字符串的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.2.</span> <span class="toc-text">构造字符串对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">使用构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">使用静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E2%80%9D%E2%80%9D"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">使用””+</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">3.5.3.</span> <span class="toc-text">字符串的对象的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">3.5.4.</span> <span class="toc-text">字符串对象的内存分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.5.</span> <span class="toc-text">字符串拼接问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E7%BB%93%E6%9E%9C%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%AF%94%E8%BE%83%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.5.1.</span> <span class="toc-text">拼接结果的存储和比较问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.5.2.</span> <span class="toc-text">拼接效率问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%8B%BC%E6%8E%A5"><span class="toc-number">3.5.5.3.</span> <span class="toc-text">两种拼接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.5.6.</span> <span class="toc-text">字符串对象的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%AD%97%E7%AC%A6%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.5.7.</span> <span class="toc-text">空字符的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.8.</span> <span class="toc-text">字符串的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E5%88%971"><span class="toc-number">3.5.8.1.</span> <span class="toc-text">系列1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E5%88%972%EF%BC%9A%E6%9F%A5%E6%89%BE"><span class="toc-number">3.5.8.2.</span> <span class="toc-text">系列2：查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E5%88%973%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96"><span class="toc-number">3.5.8.3.</span> <span class="toc-text">系列3：字符串截取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E5%88%974%EF%BC%9A%E5%92%8C%E5%AD%97%E7%AC%A6%E7%9B%B8%E5%85%B3"><span class="toc-number">3.5.8.4.</span> <span class="toc-text">系列4：和字符相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E5%88%975%EF%BC%9A%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81"><span class="toc-number">3.5.8.5.</span> <span class="toc-text">系列5：编码与解码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%8F%91%E5%B1%95"><span class="toc-number">3.5.8.5.1.</span> <span class="toc-text">字符编码发展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ASCII%E7%A0%81"><span class="toc-number">3.5.8.5.2.</span> <span class="toc-text">ASCII码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OEM%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E8%A1%8D%E7%94%9F"><span class="toc-number">3.5.8.5.3.</span> <span class="toc-text">OEM字符集的衍生</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%88MBCS%EF%BC%89%E5%92%8C%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">3.5.8.5.4.</span> <span class="toc-text">多字节字符集（MBCS）和中文字符集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ANSI%E6%A0%87%E5%87%86%E3%80%81%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E3%80%81ISO%E6%A0%87%E5%87%86"><span class="toc-number">3.5.8.5.5.</span> <span class="toc-text">ANSI标准、国家标准、ISO标准</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unicode%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-number">3.5.8.5.6.</span> <span class="toc-text">Unicode的出现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E5%88%976%EF%BC%9A%E5%BC%80%E5%A4%B4%E4%B8%8E%E7%BB%93%E5%B0%BE"><span class="toc-number">3.5.8.6.</span> <span class="toc-text">系列6：开头与结尾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E5%88%977%EF%BC%9A%E6%9B%BF%E6%8D%A2"><span class="toc-number">3.5.8.7.</span> <span class="toc-text">系列7：替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E5%88%978%EF%BC%9A%E6%8B%86%E5%88%86"><span class="toc-number">3.5.8.8.</span> <span class="toc-text">系列8：拆分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97"><span class="toc-number">3.6.</span> <span class="toc-text">可变字符序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.1.</span> <span class="toc-text">String与可变字符序列的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder%E3%80%81StringBuffer%E7%9A%84API"><span class="toc-number">3.6.2.</span> <span class="toc-text">StringBuilder、StringBuffer的API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E6%B5%8B%E8%AF%95"><span class="toc-number">3.6.3.</span> <span class="toc-text">效率测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%89%B9%E7%82%B9%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.7.</span> <span class="toc-text">字符串特点相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84length%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84length%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">3.7.1.</span> <span class="toc-text">1、面试题：字符串的length和数组的length有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">3.7.2.</span> <span class="toc-text">字符串对象不可变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E4%B8%AA%E6%95%B0"><span class="toc-number">3.7.3.</span> <span class="toc-text">字符串对象个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83"><span class="toc-number">3.7.4.</span> <span class="toc-text">字符串对象比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.7.5.</span> <span class="toc-text">空字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.8.</span> <span class="toc-text">字符串算法相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98"><span class="toc-number">3.8.1.</span> <span class="toc-text">编程题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98-1"><span class="toc-number">3.8.2.</span> <span class="toc-text">编程题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98-2"><span class="toc-number">3.8.3.</span> <span class="toc-text">编程题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98-3"><span class="toc-number">3.8.4.</span> <span class="toc-text">编程题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98-4"><span class="toc-number">3.8.5.</span> <span class="toc-text">编程题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98-5"><span class="toc-number">3.8.6.</span> <span class="toc-text">编程题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98-6"><span class="toc-number">3.8.7.</span> <span class="toc-text">编程题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98-7"><span class="toc-number">3.8.8.</span> <span class="toc-text">编程题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">4.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection"><span class="toc-number">4.1.</span> <span class="toc-text">Collection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">Iterator迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.1.</span> <span class="toc-text">Iterator接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.2.</span> <span class="toc-text">迭代器的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.3.</span> <span class="toc-text">使用Iterator迭代器删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor"><span class="toc-number">4.2.4.</span> <span class="toc-text">增强for</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A01%EF%BC%9A%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">练习1：遍历数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A02%EF%BC%9A%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">练习2：遍历集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-Iterable%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.5.</span> <span class="toc-text">java.lang.Iterable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%ADmodCount%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%8C%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%EF%BC%88fail-fast%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.6.</span> <span class="toc-text">Java中modCount的用法，快速失败（fail-fast）机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">4.3.</span> <span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.3.1.</span> <span class="toc-text">List接口介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">List接口中常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BB%AC"><span class="toc-number">4.3.3.</span> <span class="toc-text">List接口的实现类们</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ListIterator"><span class="toc-number">4.3.4.</span> <span class="toc-text">ListIterator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88"><span class="toc-number">4.4.</span> <span class="toc-text">Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet"><span class="toc-number">4.4.1.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">4.4.2.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet"><span class="toc-number">4.4.3.</span> <span class="toc-text">TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">自然顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">定制排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E7%B3%BB%E5%88%97%E7%9A%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE"><span class="toc-number">4.5.</span> <span class="toc-text">Collection系列的集合框架图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">4.6.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">4.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.2.</span> <span class="toc-text">Map常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.6.3.</span> <span class="toc-text">Map集合的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BB%AC"><span class="toc-number">4.6.4.</span> <span class="toc-text">Map的实现类们</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">4.6.4.1.</span> <span class="toc-text">HashMap和Hashtable的区别与联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">4.6.4.2.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap"><span class="toc-number">4.6.4.3.</span> <span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties"><span class="toc-number">4.6.4.4.</span> <span class="toc-text">Properties</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88%E4%B8%8EMap%E9%9B%86%E5%90%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.6.5.</span> <span class="toc-text">Set集合与Map集合的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">4.7.</span> <span class="toc-text">集合框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.8.</span> <span class="toc-text">Collections工具类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">泛型的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">5.1.1.</span> <span class="toc-text">泛型的引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">5.1.2.</span> <span class="toc-text">泛型的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D"><span class="toc-number">5.1.3.</span> <span class="toc-text">泛型的相关名词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%93%AA%E9%87%8C%E5%8F%AF%E4%BB%A5%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F-lt-T-gt"><span class="toc-number">5.1.4.</span> <span class="toc-text">在哪里可以声明类型变量&lt;T&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.2.</span> <span class="toc-text">参数类型：泛型类与泛型接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.2.1.</span> <span class="toc-text">声明泛型类与泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.2.2.</span> <span class="toc-text">使用泛型类与泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%8A%E9%99%90"><span class="toc-number">5.2.3.</span> <span class="toc-text">类型变量的上限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">5.2.4.</span> <span class="toc-text">泛型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-3"><span class="toc-number">5.2.5.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A01-1"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">练习1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A02-1"><span class="toc-number">5.2.5.2.</span> <span class="toc-text">练习2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A03"><span class="toc-number">5.2.5.3.</span> <span class="toc-text">练习3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">5.4.</span> <span class="toc-text">类型通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-gt-%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.4.1.</span> <span class="toc-text">&lt;?&gt;任意类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-extends-%E4%B8%8A%E9%99%90-gt"><span class="toc-number">5.4.2.</span> <span class="toc-text">&lt;? extends 上限&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-super-%E4%B8%8B%E9%99%90-gt"><span class="toc-number">5.4.3.</span> <span class="toc-text">&lt;? super 下限&gt;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">6.2.</span> <span class="toc-text">动态数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">6.2.1.</span> <span class="toc-text">动态数组的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.2.</span> <span class="toc-text">动态数组的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.3.</span> <span class="toc-text">动态数组实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E6%B5%8B%E8%AF%95"><span class="toc-number">6.2.4.</span> <span class="toc-text">动态数组测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">6.2.5.</span> <span class="toc-text">Java核心类库中的动态数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E4%B8%8EVector%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.2.5.1.</span> <span class="toc-text">ArrayList与Vector的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.2.5.2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Vector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.2.5.2.1.</span> <span class="toc-text">Vector源码分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.2.5.2.2.</span> <span class="toc-text">ArrayList源码分析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.</span> <span class="toc-text">链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">6.3.1.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">双链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.3.2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">二叉树实现基本结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%86%E7%B1%BB"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">二叉树分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.2.3.</span> <span class="toc-text">二叉树的遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8-1"><span class="toc-number">6.4.</span> <span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.4.1.</span> <span class="toc-text">单链表的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">6.4.2.</span> <span class="toc-text">单链表的测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8-1"><span class="toc-number">6.5.</span> <span class="toc-text">双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.5.1.</span> <span class="toc-text">LinkedList源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.5.2.</span> <span class="toc-text">链表与动态数组的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">6.6.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack%E7%B1%BB"><span class="toc-number">6.6.1.</span> <span class="toc-text">Stack类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue%E5%92%8CDeque%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.6.2.</span> <span class="toc-text">Queue和Deque接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">6.7.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode%E5%80%BC"><span class="toc-number">6.7.1.</span> <span class="toc-text">hashCode值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">6.7.2.</span> <span class="toc-text">哈希表的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%EF%BC%9AMap-Entry"><span class="toc-number">6.7.2.1.</span> <span class="toc-text">数组元素类型：Map.Entry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6%E5%A7%8B%E7%BB%88%E6%98%AF2%E7%9A%84n%E6%AC%A1%E5%B9%82"><span class="toc-number">6.7.2.2.</span> <span class="toc-text">数组的长度始终是2的n次幂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E4%B9%88HashMap%E6%98%AF%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E6%9F%90%E4%B8%AA%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E5%AD%98%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%A1%B6%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">6.7.2.3.</span> <span class="toc-text">那么HashMap是如何决定某个映射关系存在哪个桶的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E6%98%AFhashCode%E7%9A%84%E5%86%8D%E8%BF%90%E7%AE%97"><span class="toc-number">6.7.2.4.</span> <span class="toc-text">hash是hashCode的再运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-index-%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-number">6.7.2.5.</span> <span class="toc-text">解决[index]冲突问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88JDK1-8%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8C%E9%93%BE%E8%A1%A8%E5%85%B1%E5%AD%98%E5%91%A2%EF%BC%9F"><span class="toc-number">6.7.2.6.</span> <span class="toc-text">为什么JDK1.8会出现红黑树和链表共存呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%A0%91%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%8D%E6%A0%91%E5%8C%96%EF%BC%9F"><span class="toc-number">6.7.2.7.</span> <span class="toc-text">什么时候树化？什么时候反树化？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-7%E7%9A%84put%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.7.3.</span> <span class="toc-text">JDK1.7的put方法源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-8%E7%9A%84put%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.7.4.</span> <span class="toc-text">JDK1.8的put方法源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E7%9A%84key%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%EF%BC%9F"><span class="toc-number">6.7.5.</span> <span class="toc-text">关于映射关系的key是否可以修改？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#File%E7%B1%BB%E4%B8%8EIO%E6%B5%81"><span class="toc-number">7.</span> <span class="toc-text">File类与IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-io-File%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">java.io.File类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">7.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">7.1.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">7.1.3.</span> <span class="toc-text">常用方法（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">获取文件和目录基本信息的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">各种路径问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.3.3.</span> <span class="toc-text">判断功能的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.3.4.</span> <span class="toc-text">创建删除功能的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%8C%E6%9C%89%E6%97%B6%E9%97%B4%E4%BD%9C%E4%B8%BA%E5%A4%8D%E4%B9%A0%E9%80%92%E5%BD%92%E7%BB%83%E4%B9%A0%E7%94%A8%EF%BC%89"><span class="toc-number">7.1.4.</span> <span class="toc-text">递归实现多级目录操作（了解，有时间作为复习递归练习用）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%89%93%E5%8D%B0%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95"><span class="toc-number">7.1.4.1.</span> <span class="toc-text">递归打印多级目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%89%93%E5%8D%B0%E6%9F%90%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%88%E5%8C%85%E6%8B%AC%E5%AD%90%E7%9B%AE%E5%BD%95%EF%BC%89%E4%B8%AD%E6%89%80%E6%9C%89%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">7.1.4.2.</span> <span class="toc-text">递归打印某目录下（包括子目录）中所有满足条件的文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B1%82%E7%9B%AE%E5%BD%95%E6%80%BB%E5%A4%A7%E5%B0%8F"><span class="toc-number">7.1.4.3.</span> <span class="toc-text">递归求目录总大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E9%9D%9E%E7%A9%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">7.1.4.4.</span> <span class="toc-text">递归删除非空目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%A6%82%E8%BF%B0"><span class="toc-number">7.2.</span> <span class="toc-text">IO概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFIO"><span class="toc-number">7.2.1.</span> <span class="toc-text">什么是IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.2.2.</span> <span class="toc-text">IO的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%A4%A7%E9%A1%B6%E7%BA%A7%E6%8A%BD%E8%B1%A1%E7%88%B6%E7%B1%BB%E4%BB%AC"><span class="toc-number">7.2.3.</span> <span class="toc-text">4大顶级抽象父类们</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">7.3.</span> <span class="toc-text">字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%88%87%E7%9A%86%E4%B8%BA%E5%AD%97%E8%8A%82"><span class="toc-number">7.3.1.</span> <span class="toc-text">一切皆为字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%E3%80%90OutputStream%E3%80%91"><span class="toc-number">7.3.2.</span> <span class="toc-text">字节输出流【OutputStream】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileOutputStream%E7%B1%BB"><span class="toc-number">7.3.3.</span> <span class="toc-text">FileOutputStream类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%87%BA%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE"><span class="toc-number">7.3.3.2.</span> <span class="toc-text">写出字节数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%BD%E5%8A%A0%E7%BB%AD%E5%86%99"><span class="toc-number">7.3.3.3.</span> <span class="toc-text">数据追加续写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%87%BA%E6%8D%A2%E8%A1%8C"><span class="toc-number">7.3.3.4.</span> <span class="toc-text">写出换行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%E3%80%90InputStream%E3%80%91"><span class="toc-number">7.3.4.</span> <span class="toc-text">字节输入流【InputStream】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileInputStream%E7%B1%BB"><span class="toc-number">7.3.5.</span> <span class="toc-text">FileInputStream类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-3"><span class="toc-number">7.3.5.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE"><span class="toc-number">7.3.5.2.</span> <span class="toc-text">读取字节数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%9B%BE%E7%89%87%E5%A4%8D%E5%88%B6"><span class="toc-number">7.3.6.</span> <span class="toc-text">字节流练习：图片复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">7.4.</span> <span class="toc-text">字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81%E3%80%90Reader%E3%80%91"><span class="toc-number">7.4.1.</span> <span class="toc-text">字符输入流【Reader】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileReader%E7%B1%BB"><span class="toc-number">7.4.2.</span> <span class="toc-text">FileReader类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-4"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6%E6%95%B0%E6%8D%AE"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">读取字符数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81%E3%80%90Writer%E3%80%91"><span class="toc-number">7.4.3.</span> <span class="toc-text">字符输出流【Writer】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileWriter%E7%B1%BB"><span class="toc-number">7.4.4.</span> <span class="toc-text">FileWriter类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-5"><span class="toc-number">7.4.4.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%99%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">7.4.4.2.</span> <span class="toc-text">基本写出数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E5%92%8C%E5%88%B7%E6%96%B0"><span class="toc-number">7.4.4.3.</span> <span class="toc-text">关闭和刷新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%87%BA%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE"><span class="toc-number">7.4.4.4.</span> <span class="toc-text">写出其他数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">7.5.</span> <span class="toc-text">缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">7.5.1.</span> <span class="toc-text">字节缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-6"><span class="toc-number">7.5.1.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E6%B5%8B%E8%AF%95-1"><span class="toc-number">7.5.1.2.</span> <span class="toc-text">效率测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">7.5.2.</span> <span class="toc-text">字符缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-7"><span class="toc-number">7.5.2.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">7.5.2.2.</span> <span class="toc-text">特有方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">7.6.</span> <span class="toc-text">转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">7.6.1.</span> <span class="toc-text">字符编码和字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">7.6.1.1.</span> <span class="toc-text">字符编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">7.6.1.2.</span> <span class="toc-text">字符集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%BC%95%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.6.2.</span> <span class="toc-text">编码引出的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStreamReader%E7%B1%BB"><span class="toc-number">7.6.3.</span> <span class="toc-text">InputStreamReader类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-8"><span class="toc-number">7.6.3.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%BC%96%E7%A0%81%E8%AF%BB%E5%8F%96"><span class="toc-number">7.6.3.2.</span> <span class="toc-text">指定编码读取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputStreamWriter%E7%B1%BB"><span class="toc-number">7.6.4.</span> <span class="toc-text">OutputStreamWriter类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-9"><span class="toc-number">7.6.4.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%BC%96%E7%A0%81%E5%86%99%E5%87%BA"><span class="toc-number">7.6.4.2.</span> <span class="toc-text">指定编码写出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%90%86%E8%A7%A3%E5%9B%BE%E8%A7%A3"><span class="toc-number">7.6.5.</span> <span class="toc-text">转换流理解图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A%E8%BD%AC%E6%8D%A2%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81"><span class="toc-number">7.6.6.</span> <span class="toc-text">练习：转换文件编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">7.6.6.1.</span> <span class="toc-text">案例分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.6.6.2.</span> <span class="toc-text">案例实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">7.7.</span> <span class="toc-text">数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">7.8.</span> <span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">7.8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectOutputStream%E7%B1%BB"><span class="toc-number">7.8.2.</span> <span class="toc-text">ObjectOutputStream类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-10"><span class="toc-number">7.8.2.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">7.8.2.2.</span> <span class="toc-text">序列化操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectInputStream%E7%B1%BB"><span class="toc-number">7.8.3.</span> <span class="toc-text">ObjectInputStream类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-11"><span class="toc-number">7.8.3.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C1"><span class="toc-number">7.8.3.2.</span> <span class="toc-text">反序列化操作1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C2"><span class="toc-number">7.8.3.3.</span> <span class="toc-text">反序列化操作2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E9%9B%86%E5%90%88"><span class="toc-number">7.8.4.</span> <span class="toc-text">练习：序列化集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-1"><span class="toc-number">7.8.4.1.</span> <span class="toc-text">案例分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">7.8.4.2.</span> <span class="toc-text">案例实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-io-Externalizable%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.8.5.</span> <span class="toc-text">java.io.Externalizable接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86PrintStream%E5%92%8CScanner%E3%80%81System-in%E5%92%8Cout"><span class="toc-number">7.9.</span> <span class="toc-text">重新认识PrintStream和Scanner、System.in和out</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PrintStream%E7%B1%BB"><span class="toc-number">7.9.1.</span> <span class="toc-text">PrintStream类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-12"><span class="toc-number">7.9.1.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E6%89%93%E5%8D%B0%E6%B5%81%E5%90%91"><span class="toc-number">7.9.1.2.</span> <span class="toc-text">改变打印流向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scanner%E7%B1%BB"><span class="toc-number">7.9.2.</span> <span class="toc-text">Scanner类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-13"><span class="toc-number">7.9.2.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">7.9.2.2.</span> <span class="toc-text">常用方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK1-7%E4%B9%8B%E5%90%8E%E5%BC%95%E5%85%A5%E6%96%B0try-catch"><span class="toc-number">7.10.</span> <span class="toc-text">JDK1.7之后引入新try..catch</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">软件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">8.2.</span> <span class="toc-text">网络通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.2.1.</span> <span class="toc-text">TCP&#x2F;IP协议参考模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE"><span class="toc-number">8.2.2.</span> <span class="toc-text">TCP与UDP协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">8.3.</span> <span class="toc-text">网络编程三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">8.3.1.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-number">8.3.2.</span> <span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">8.3.3.</span> <span class="toc-text">端口号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InetAddress%E7%B1%BB"><span class="toc-number">8.4.</span> <span class="toc-text">InetAddress类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket"><span class="toc-number">8.5.</span> <span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">8.6.</span> <span class="toc-text">TCP网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.6.1.</span> <span class="toc-text">通信模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-number">8.6.2.</span> <span class="toc-text">开发步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-number">8.6.2.1.</span> <span class="toc-text">服务器端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">8.6.2.2.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3API"><span class="toc-number">8.6.3.</span> <span class="toc-text">相关API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%8D%95%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%95%E6%AC%A1%E9%80%9A%E4%BF%A1"><span class="toc-number">8.6.4.</span> <span class="toc-text">示例一：单个客户端与服务器单次通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">8.6.4.1.</span> <span class="toc-text">客户端示例代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">8.6.4.2.</span> <span class="toc-text">服务器端示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%9A%E6%AC%A1%E9%80%9A%E4%BF%A1"><span class="toc-number">8.6.5.</span> <span class="toc-text">示例二：多个客户端与服务器之间的多次通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="toc-number">8.6.5.1.</span> <span class="toc-text">客户端示例代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="toc-number">8.6.5.2.</span> <span class="toc-text">服务器端示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">8.7.</span> <span class="toc-text">UDP网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3API-1"><span class="toc-number">8.7.1.</span> <span class="toc-text">相关API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">8.7.2.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AB%AF%EF%BC%9A"><span class="toc-number">8.7.2.1.</span> <span class="toc-text">发送端：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E7%AB%AF%EF%BC%9A"><span class="toc-number">8.7.2.2.</span> <span class="toc-text">接收端：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%EF%BC%88Reflect%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">反射（Reflect）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">9.1.</span> <span class="toc-text">类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">9.1.1.</span> <span class="toc-text">类的加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">9.1.2.</span> <span class="toc-text">类初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">9.1.3.</span> <span class="toc-text">类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javalang-Class%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">javalang.Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.2.1.</span> <span class="toc-text">哪些类型可以获取Class对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">9.2.2.</span> <span class="toc-text">获取Class对象的四种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.2.3.</span> <span class="toc-text">查看某个类的类加载器对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">反射的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-number">9.3.1.</span> <span class="toc-text">获取类型的详细信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%BB%E6%84%8F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.3.2.</span> <span class="toc-text">创建任意引用类型的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">9.3.3.</span> <span class="toc-text">操作任意类型的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.4.</span> <span class="toc-text">调用任意类型的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%88%B6%E7%B1%BB%E4%BF%A1%E6%81%AF"><span class="toc-number">9.3.5.</span> <span class="toc-text">获取泛型父类信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%B3%A8%E8%A7%A3%E4%BF%A1%E6%81%AF"><span class="toc-number">9.3.6.</span> <span class="toc-text">读取注解信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%86%85%E9%83%A8%E7%B1%BB%E6%88%96%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BF%A1%E6%81%AF"><span class="toc-number">9.3.7.</span> <span class="toc-text">获取内部类或外部类信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">9.3.8.</span> <span class="toc-text">动态创建和操作任意类型的数组</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>