<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>SpringBoot-缓存管理 | 小肥龙吃大冰淇淋</title><meta name="keywords" content="SpringBoot"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="默认缓存管理Spring框架支持透明地向应用程序添加缓存对缓存进行管理，其管理缓存的核心是将缓存应用于操作数据的方法，从而减少操作数据的执行次数，同时不会对程序本身造成任何干扰。Spring Boot继承了Spring框架的缓存管理功能，通过使用@EnableCaching注解开启基于注解的缓存支持，Spring Boot就可以启动缓存管理的自动化配置。 接下来针对Spring Boot支持的默认">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot-缓存管理">
<meta property="og:url" content="https://pengdanhua.github.io/post/10f0fa46.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="默认缓存管理Spring框架支持透明地向应用程序添加缓存对缓存进行管理，其管理缓存的核心是将缓存应用于操作数据的方法，从而减少操作数据的执行次数，同时不会对程序本身造成任何干扰。Spring Boot继承了Spring框架的缓存管理功能，通过使用@EnableCaching注解开启基于注解的缓存支持，Spring Boot就可以启动缓存管理的自动化配置。 接下来针对Spring Boot支持的默认">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165213.jpg">
<meta property="article:published_time" content="2021-08-07T07:45:00.000Z">
<meta property="article:modified_time" content="2022-11-27T09:16:41.180Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165213.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://pengdanhua.github.io/post/10f0fa46"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SpringBoot-缓存管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">179</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">41</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165213.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringBoot-缓存管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-07T07:45:00.000Z" title="发表于 2021-08-07 15:45:00">2021-08-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:41.180Z" title="更新于 2022-11-27 17:16:41">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SpringBoot-缓存管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="默认缓存管理"><a href="#默认缓存管理" class="headerlink" title="默认缓存管理"></a>默认缓存管理</h2><p>Spring框架支持透明地向应用程序添加缓存对缓存进行管理，其管理缓存的核心是将缓存应用于操作数据的方法，从而减少操作数据的执行次数，同时不会对程序本身造成任何干扰。Spring Boot继承了Spring框架的缓存管理功能，通过使用@EnableCaching注解开启基于注解的缓存支持，Spring Boot就可以启动缓存管理的自动化配置。</p>
<p>接下来针对Spring Boot支持的默认缓存管理进行讲解</p>
<h3 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h3><p><strong>准备数据</strong></p>
<p>使用创建的springbootdata的数据库，该数据库有两个表t_article和t_comment</p>
<p><strong>创建项目,功能编写</strong></p>
<p>（1）在Dependencies依赖选择项中添加SQL模块中的JPA依赖、MySQL依赖和Web模块中的Web依赖</p>
<p>（2）编写数据库表对应的实体类，并使用JPA相关注解配置映射关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">importjavax.persistence.*;</span><br><span class="line">@Entity(name=&quot;t_comment&quot;) //设置ORM实体类，并指定映射的表名</span><br><span class="line">public class Comment&#123;</span><br><span class="line">    	@Id //表明映射对应的主键id</span><br><span class="line">    	@GeneratedValue(strategy=GenerationType.IDENTITY)//设置主键自增策略</span><br><span class="line">        private Integer id;</span><br><span class="line">        private String content;</span><br><span class="line">        private String author;</span><br><span class="line">        @Column(name=&quot;a_id&quot;)//指定映射的表字段名</span><br><span class="line">    	private Integer aId;</span><br><span class="line">    	// 省略属性getXX()和setXX()方法</span><br><span class="line">       // 省略toString()方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）编写数据库操作的Repository接口文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface CommentRepository extends JpaRepository&lt;Comment,Integer&gt; &#123;</span><br><span class="line">    // 根据评论id修改评论作者author</span><br><span class="line">    @Transactional</span><br><span class="line">    @Modifying</span><br><span class="line">    @Query(&quot;update t_comment c set c.author = ?1 where c.id=?2&quot;)</span><br><span class="line">    public int updateComment(String author,Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）编写service层 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class CommentService &#123;</span><br><span class="line">	@Autowired</span><br><span class="line">    private CommentRepository commentRepository;</span><br><span class="line">    public Comment findCommentById(Integer id)&#123;</span><br><span class="line">	Optional&lt;Comment&gt; comment = commentRepository.findById(id);</span><br><span class="line">    if(comment.isPresent())&#123;</span><br><span class="line">    Comment comment1 = comment.get();</span><br><span class="line">    	return comment1;</span><br><span class="line">    &#125; </span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）编写Controller层 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class CommentController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CommentService commentService;</span><br><span class="line">    @RequestMapping(value = &quot;/findCommentById&quot;)</span><br><span class="line">    public Comment findCommentById(Integer id)&#123;</span><br><span class="line">        Comment comment = commentService.findCommentById(id);</span><br><span class="line">        return comment;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）编写配置文件<br>在项目全局配置文件application.properties中编写对应的数据库连接配置 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># MySQL数据库连接配置</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/springbootdata?serverTimezone=UTC</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">#显示使用JPA进行数据库查询的SQL语句</span><br><span class="line">spring.jpa.show-sql=true</span><br><span class="line">#开启驼峰命名匹配映射</span><br><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br><span class="line">#解决乱码</span><br><span class="line">spring.http.encoding.force-response=true</span><br></pre></td></tr></table></figure>

<p>（7）测试</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619162453.png" alt="img"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619162435.png" alt="img"></p>
<p>上图情况，是因为没有在Spring Boot项目中开启缓存管理。在没有缓存管理的情况下，虽然数据表中<br>的数据没有发生变化，但是每执行一次查询操作（本质是执行同样的SQL语句），都会访问一次数据库<br>并执行一次SQL语句 。</p>
<h3 id="默认缓存体验"><a href="#默认缓存体验" class="headerlink" title="默认缓存体验"></a>默认缓存体验</h3><p>在前面搭建的Web应用基础上，开启Spring Boot默认支持的缓存，体验Spring Boot默认缓存的使用效<br>果<br><strong>1）使用@EnableCaching注解开启基于注解的缓存支持 。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableCaching // 开启Spring Boot基于注解的缓存管理支持</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Springboot04CacheApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	SpringApplication.run(Springboot04CacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）使用@Cacheable注解对数据操作方法进行缓存管理。将@Cacheable注解标注在Service类的查<br>询方法上，对查询结果进行缓存</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 根据评论id查询评论信息</span><br><span class="line">@Cacheable(cacheNames = &quot;comment&quot;)</span><br><span class="line">public Comment findById(int comment_id)&#123;</span><br><span class="line">    Optional&lt;Comment&gt; optional = commentRepository.findCommentById(comment_id);</span><br><span class="line">    if(optional.isPresent())&#123;</span><br><span class="line">    	return optional.get();</span><br><span class="line">	&#125; </span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，在CommentService类中的findCommentById(int comment_id)方法上添加了查询缓存注<br>解@Cacheable，该注解的作用是将查询结果Comment存放在Spring Boot默认缓存中名称为comment<br>的名称空间（namespace）中，对应缓存唯一标识。<br>（即缓存数据对应的主键k）默认为方法参数comment_id的值 。<br> <strong>（3）测试访问</strong> </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619162926.png" alt="img"></p>
<p>可以看出，再次 执行findCommentById()方法正确查询出用户评论信息Comment，在配置了Spring<br>Boot默认注解后，重复进行同样的查询操作，数据库只执行了一次SQL查询语句，说明项目开启的默认<br>缓存支持已经生效。<br>底层结构：在诸多的缓存自动配置类中, SpringBoot默认装配的是 SimpleCacheConfiguration ,<br>他使用的 CacheManager 是 ConcurrentMapCacheManager, 使用 ConcurrentMap 当底层的数据<br> 结构,按照Cache的名字查询出Cache, 每一个Cache中存在多个k-v键值对,缓存值。<br><strong>（4）缓存注解介绍</strong><br>刚刚通过使用@EnableCaching、@Cacheable注解实现了Spring Boot默认的基于注解的缓存管<br>理，除此之外，还有更多的缓存注解及注解属性可以配置优化缓存管理。<br><strong>1．@EnableCaching注解</strong><br>@EnableCaching是由spring框架提供的，springboot框架对该注解进行了继承，该注解需要配置在类<br>上（在中，通常配置在项目启动类上），用于开启基于注解的缓存支持。<br><strong>2．@Cacheable注解</strong><br>@Cacheable注解也是由spring框架提供的，可以作用于类或方法（通常用在数据查询方法上），用于<br>对方法结果进行缓存存储。注解的执行顺序是，先进行缓存查询，如果为空则进行方法查询，并将结果<br>进行缓存；如果缓存中有数据，不进行方法查询，而是直接使用缓存数据。<br>@Cacheable注解提供了多个属性，用于对缓存存储进行相关配置 。</p>
<table>
<thead>
<tr>
<th><strong>属性名</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>value/cacheNames</td>
<td>指定缓存空间的名称，必配属性。这两个属性二选一使用</td>
</tr>
<tr>
<td>key</td>
<td>指定缓存数据的key，默认使用方法参数值，可以使用SpEL表达式</td>
</tr>
<tr>
<td>keyGenerator</td>
<td>指定缓存数据的key的生成器，与key属性二选一使用</td>
</tr>
<tr>
<td>cacheManager</td>
<td>指定缓存管理器</td>
</tr>
<tr>
<td>cacheResolver</td>
<td>指定缓存解析器，与cacheManager属性二选一使用</td>
</tr>
<tr>
<td>condition</td>
<td>指定在符合某条件下，进行数据缓存</td>
</tr>
<tr>
<td>unless</td>
<td>指定在符合某条件下，不进行数据缓存</td>
</tr>
<tr>
<td>sync</td>
<td>指定是否使用异步缓存。默认false</td>
</tr>
</tbody></table>
<p> <strong>执行流程&amp;时机</strong><br>方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取，（CacheManager<br>先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建；<br>去Cache中查找缓存的内容，使用一个key，默认就是方法的参数，如果多个参数或者没有参数，是按<br>照某种策略生成的，默认是使用KeyGenerator生成的，使用SimpleKeyGenerator生成key，<br>SimpleKeyGenerator生成key的默认策略： </p>
<table>
<thead>
<tr>
<th><strong>参数个数</strong></th>
<th><strong>key</strong></th>
</tr>
</thead>
<tbody><tr>
<td>没有参数</td>
<td>new SimpleKey()</td>
</tr>
<tr>
<td>有一个参数</td>
<td>参数值</td>
</tr>
<tr>
<td>多个参数</td>
<td>new SimpleKey(params)</td>
</tr>
</tbody></table>
<p> 常用的SPEL表达式 </p>
<table>
<thead>
<tr>
<th><strong>描述</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>当前被调用的方法名</td>
<td>#root.mathodName</td>
</tr>
<tr>
<td>当前被调用的方法</td>
<td>#root.mathod</td>
</tr>
<tr>
<td>当前被调用的目标对象</td>
<td>#root.target</td>
</tr>
<tr>
<td>当前被调用的目标对象类</td>
<td>#root.targetClass</td>
</tr>
<tr>
<td>当前被调用的方法的参数列表</td>
<td>#root.args[0] 第一个参数, #root.args[1] 第二个参数…</td>
</tr>
<tr>
<td>根据参数名字取出值</td>
<td>#参数名, 也可以使用 #p0 #a0 0是参数的下标索引</td>
</tr>
<tr>
<td>当前方法的返回值</td>
<td>#result</td>
</tr>
</tbody></table>
<p> <strong>3．@CachePut注解</strong><br>目标方法执行完之后生效, @CachePut被使用于修改操作比较多,哪怕缓存中已经存在目标值了,但是这个<br>注解保证这个方法依然会执行,执行之后的结果被保存在缓存中。<br>@CachePut注解也提供了多个属性，这些属性与@Cacheable注解的属性完全相同。<br>更新操作,前端会把id+实体传递到后端使用,我们就直接指定方法的返回值从新存进缓存时的<br>key=”#id” , 如果前端只是给了实体,我们就使用 key=”#实体.id” 获取key. 同时,他的执行时机是目标<br>方法结束后执行, 所以也可以使用 key=”#result.id” , 拿出返回值的id。<br><strong>4．@CacheEvict注解</strong><br>@CacheEvict注解是由Spring框架提供的，可以作用于类或方法（通常用在数据删除方法上），该注解<br>的作用是删除缓存数据。@CacheEvict注解的默认执行顺序是，先进行方法调用，然后将缓存进行清<br>除。 </p>
<h2 id="整合Redis缓存实现"><a href="#整合Redis缓存实现" class="headerlink" title="整合Redis缓存实现"></a>整合Redis缓存实现</h2><h3 id="Spring-Boot支持的缓存组件"><a href="#Spring-Boot支持的缓存组件" class="headerlink" title="Spring Boot支持的缓存组件"></a>Spring Boot支持的缓存组件</h3><p>在Spring Boot中，数据的缓存管理存储依赖于Spring框架中cache相关的<br>org.springframework.cache.Cache和org.springframework.cache.CacheManager缓存管理器接口。<br>如果程序中没有定义类型为CacheManager的Bean组件或者是名为cacheResolver的CacheResolver缓<br>存解析器，Spring Boot将尝试选择并启用以下缓存组件（按照指定的顺序）：<br>（1）Generic<br>（2）JCache (JSR-107) (EhCache 3、Hazelcast、Infinispan等)<br>（3）EhCache 2.x<br>（4）Hazelcast<br>（5）Infinispan<br>（6）Couchbase<br>（7）Redis<br>（8）Caffeine<br> （9）Simple<br>上面按照Spring Boot缓存组件的加载顺序，列举了支持的9种缓存组件，在项目中添加某个缓存管理<br>组件（例如Redis）后，Spring Boot项目会选择并启用对应的缓存管理器。如果项目中同时添加了多个<br>缓存组件，且没有指定缓存管理器或者缓存解析器（CacheManager或者cacheResolver），那么<br>Spring Boot会按照上述顺序在添加的多个缓存中优先启用指定的缓存组件进行缓存管理。<br>刚刚讲解的Spring Boot默认缓存管理中，没有添加任何缓存管理组件能实现缓存管理。这是因为开<br>启缓存管理后，Spring Boot会按照上述列表顺序查找有效的缓存组件进行缓存管理，如果没有任何缓<br>存组件，会默认使用最后一个Simple缓存组件进行管理。Simple缓存组件是Spring Boot默认的缓存管<br>理组件，它默认使用内存中的ConcurrentMap进行缓存存储，所以在没有添加任何第三方缓存组件的<br>情况下，可以实现内存中的缓存管理，但是我们不推荐使用这种缓存管理方式 。</p>
<h3 id="基于注解的Redis缓存实现"><a href="#基于注解的Redis缓存实现" class="headerlink" title="基于注解的Redis缓存实现"></a>基于注解的Redis缓存实现</h3><p>在Spring Boot默认缓存管理的基础上引入Redis缓存组件，使用基于注解的方式讲解Spring Boot<br>整合Redis缓存的具体实现<br><strong>（1）添加Spring Data Redis依赖启动器。在pom.xml文件中添加Spring Data Redis依赖启动器。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>当我们添加进redis相关的启动器之后, SpringBoot会使用 RedisCacheConfigratioin 当做生效的自动<br>配置类进行缓存相关的自动装配,容器中使用的缓存管理器是<br>RedisCacheManager , 这个缓存管理器创建的Cache为 RedisCache , 进而操控redis进行数据的缓存<br><strong>（2）Redis服务连接配置</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Redis服务地址</span><br><span class="line">spring.redis.host=127.0.0.1</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br></pre></td></tr></table></figure>

<p><strong>（3）对CommentService类中的方法进行修改使用@Cacheable、@CachePut、@CacheEvict三个注<br>解定制缓存管理，分别进行缓存存储、缓存更新和缓存删除的演示 。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class CommentService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CommentRepository commentRepository;</span><br><span class="line"></span><br><span class="line">    // 根据评论id查询评论信息</span><br><span class="line">    @Cacheable(cacheNames = &quot;comment&quot;,unless = &quot;#result=null&quot;)</span><br><span class="line">    public Comment findCommentById(Integer id)&#123;</span><br><span class="line">        Optional&lt;Comment&gt; comment = commentRepository.findById(id);</span><br><span class="line">        if(comment.isPresent())&#123;</span><br><span class="line">            Comment comment1 = comment.get();</span><br><span class="line">            return comment1;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CachePut(cacheNames = &quot;comment&quot;,key = &quot;#result.id&quot;)</span><br><span class="line">    public Comment updateComment(Comment comment)&#123;</span><br><span class="line">        commentRepository.updateComment(comment.getAuthor(),comment.getId());</span><br><span class="line">        return comment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CacheEvict(cacheNames = &quot;comment&quot;)</span><br><span class="line">    public void deleteComment(int comment_id)&#123;</span><br><span class="line">        commentRepository.deleteById(comment_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上 使用@Cacheable、@CachePut、@CacheEvict注解在数据查询、更新和删除方法上进行了缓存<br>管理。<br>其中，查询缓存@Cacheable注解中没有标记key值，将会使用默认参数值comment_id作为key进行<br>数据保存，在进行缓存更新时必须使用同样的key；同时在查询缓存@Cacheable注解中，定义了<br>“unless = “#result==null””表示查询结果为空不进行缓存。<br><strong>（4） 基于注解的Redis查询缓存测试</strong> </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619164009.png" alt="img"></p>
<p>可以看出，查询用户评论信息Comment时执行了相应的SQL语句，但是在进行缓存存储时出现了<br>IllegalArgumentException非法参数异常，提示信息要求对应Comment实体类必须实现序列化<br>（“DefaultSerializer requires a Serializable payload but received an object of type”）。<br> <strong>（5）将缓存对象实现序列化。</strong><br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619201852.png" alt="img"></p>
<p><strong>（6）再次启动测试</strong><br> 访问“<a target="_blank" rel="noopener" href="http://localhost:8080/findCommentById?id=1%E2%80%9D%E6%9F%A5%E8%AF%A2id%E4%B8%BA1%E7%9A%84%E7%94%A8%E6%88%B7%E8%AF%84%E8%AE%BA%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%B9%B6%E9%87%8D%E5%A4%8D%E5%88%B7%E6%96%B0%E6%B5%8F">http://localhost:8080/findCommentById?id=1”查询id为1的用户评论信息，并重复刷新浏</a><br>览器查询同一条数据信息，查询结果 。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619164102.png" alt="img"></p>
<p>查看控制台打印的SQL查询语句 </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619202034.png" alt="img"></p>
<p>还可以打开Redis客户端可视化管理工具Redis Desktop Manager连接本地启用的Redis服务，查看具体<br>的数据缓存效果 。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619164142.png" alt="img"></p>
<p>执行findById()方法查询出的用户评论信息Comment正确存储到了Redis缓存库中名为comment的<br>名称空间下。其中缓存数据的唯一标识key值是以“名称空间comment::+参数值（comment::1）”的字<br>符串形式体现的，而value值则是经过JDK默认序列格式化后的HEX格式存储。这种JDK默认序列格式化<br>后的数据显然不方便缓存数据的可视化查看和管理，所以在实际开发中，通常会自定义数据的序列化格<br>式 </p>
<p><strong>（7） 基于注解的Redis缓存更新测试。</strong> </p>
<p>先通过浏览器访问“<a target="_blank" rel="noopener" href="http://localhost:8080/updateComment?id=1&amp;author=shitou%E2%80%9D%E6%9B%B4%E6%96%B0id%E4%B8%BA1%E7%9A%84%E8%AF%84%E8%AE%BA%E4%BD%9C%E8%80%85%E5%90%8D%E4%B8%BAshitou%EF%BC%9B">http://localhost:8080/updateComment?id=1&amp;author=shitou”更新id为1的评论作者名为shitou；</a></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619170214.png" alt="img"></p>
<p>可以看出，执行updateComment()方法更新id为1的数据时执行了一条更新SQL语句，后续调用<br>findById()方法查询id为1的用户评论信息时没有执行查询SQL语句，且浏览器正确返回了更新后的结<br>果，表明@CachePut缓存更新配置成功<br> <strong>（8）基于注解的Redis缓存删除测试</strong><br>通过浏览器访问“<a target="_blank" rel="noopener" href="http://localhost:8080/deleteComment?id=1%E2%80%9D%E5%88%A0%E9%99%A4id%E4%B8%BA1%E7%9A%84%E7%94%A8%E6%88%B7%E8%AF%84%E8%AE%BA%E4%BF%A1%E6%81%AF%EF%BC%9B">http://localhost:8080/deleteComment?id=1”删除id为1的用户评论信息；</a> </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619170417.png" alt="img"></p>
<p>执行deleteComment()方法删除id为1的数据后查询结果为空，之前存储在Redis数据库的<br>comment相关数据也被删除，表明@CacheEvict缓存删除成功实现<br>通过上面的案例可以看出，使用基于注解的Redis缓存实现只需要添加Redis依赖并使用几个注解<br>可以实现对数据的缓存管理。另外，还可以在Spring Boot全局配置文件中配置Redis有效期，示例代码<br>如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 对基于注解的Redis缓存数据统一设置有效期为1分钟，单位毫秒</span><br><span class="line">spring.cache.redis.time-to-live=60000</span><br></pre></td></tr></table></figure>

<p>上述代码中，在Spring Boot全局配置文件中添加了“spring.cache.redis.time-to-live”属性统一配<br>置Redis数据的有效期（单位为毫秒），但这种方式相对来说不够灵活 。</p>
<h3 id="基于API的Redis缓存实现"><a href="#基于API的Redis缓存实现" class="headerlink" title="基于API的Redis缓存实现"></a>基于API的Redis缓存实现</h3><p>在Spring Boot整合Redis缓存实现中，除了基于注解形式的Redis缓存实现外，还有一种开发中常用<br>的方式——基于API的Redis缓存实现。这种基于API的Redis缓存实现，需要在某种业务需求下通过<br>Redis提供的API调用相关方法实现数据缓存管理；同时，这种方法还可以手动管理缓存的有效期。<br># 对基于注解的Redis缓存数据统一设置有效期为1分钟，单位毫秒<br><code>spring.cache.redis.time-to-live=60000</code><br>下面，通过Redis API的方式讲解Spring Boot整合Redis缓存的具体实现<br>（1）使用Redis API进行业务数据缓存管理。在yang.org.service包下编写一个进行业务处理的<br>类ApiCommentService 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ApiCommentService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CommentRepository commentRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    public Comment findCommentById(Integer id)&#123;</span><br><span class="line">        Object o = redisTemplate.opsForValue().get(&quot;comment_&quot; + id);</span><br><span class="line">        if(o != null)&#123;</span><br><span class="line">            return ((Comment) o);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 缓存中没有从数据库查询</span><br><span class="line">            Optional&lt;Comment&gt; byId = commentRepository.findById(id);</span><br><span class="line">            if(byId.isPresent())&#123;</span><br><span class="line">                Comment comment = byId.get();</span><br><span class="line">                // 将查询结果放入缓存中并设置有效期限为1天</span><br><span class="line">                redisTemplate.opsForValue().set(&quot;comment_&quot; + id,comment,1, TimeUnit.DAYS);</span><br><span class="line">                return comment;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Comment updateComment(Comment comment)&#123;</span><br><span class="line">        commentRepository.updateComment(comment.getAuthor(),comment.getaId());</span><br><span class="line">        // 更新数据后缓存处理</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;comment_&quot; + comment.getaId(),comment);</span><br><span class="line">        return comment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteComment(int comment_id)&#123;</span><br><span class="line">        commentRepository.deleteById(comment_id);</span><br><span class="line">        redisTemplate.delete(&quot;comment_&quot; + comment_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）编写Web访问层Controller文件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;api&quot;)</span><br><span class="line">public class ApiCommentController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ApiCommentService commentService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/findCommentById&quot;)</span><br><span class="line">    public Comment findCommentById(Integer id)&#123;</span><br><span class="line">        Comment comment = commentService.findCommentById(id);</span><br><span class="line">        return  comment;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/updateComment&quot;)</span><br><span class="line">    public Comment updateComment(Comment comment)&#123;</span><br><span class="line">        Comment commentById = commentService.findCommentById(comment.getId());</span><br><span class="line">        commentById.setAuthor(comment.getAuthor());</span><br><span class="line">        Comment comment1 = commentService.updateComment(commentById);</span><br><span class="line">        return comment1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/deleteComment&quot;)</span><br><span class="line">    public void deleteComment(Integer id)&#123;</span><br><span class="line">        commentService.deleteComment(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于API的Redis缓存实现的相关配置。基于API的Redis缓存实现不需要@EnableCaching注解开启<br>基于注解的缓存支持，所以这里可以选择将添加在项目启动类上的@EnableCaching进行删除或者<br>注释 。</p>
<h2 id="自定义Redis缓存序列化机制"><a href="#自定义Redis缓存序列化机制" class="headerlink" title="自定义Redis缓存序列化机制"></a>自定义Redis缓存序列化机制</h2><p>刚刚完成了Spring Boot整合Redis进行了数据的缓存管理，但缓存管理的实体类数据使用的是JDK<br>序列化方式，不便于使用可视化管理工具进行查看和管理。 </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619195114.png" alt="img"></p>
<p>接下来分别针对基于注解的Redis缓存实现和基于API的Redis缓存实现中的数据序列化机制进行介绍，<br>并自定义JSON格式的数据序列化方式进行数据缓存管理 。</p>
<h3 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h3><p><strong>1．Redis API默认序列化机制</strong><br>基于API的Redis缓存实现是使用RedisTemplate模板进行数据缓存操作的，这里打开<br>RedisTemplate类，查看该类的源码信息 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RedisTemplate&lt;K, V&gt; extends RedisAccessor implements RedisOperations&lt;K, V&gt;,</span><br><span class="line">BeanClassLoaderAware &#123;</span><br><span class="line">    // 声明了key、value的各种序列化方式，初始值为空</span><br><span class="line">    @Nullable</span><br><span class="line">    private RedisSerializer keySerializer = null;</span><br><span class="line">    @Nullable</span><br><span class="line">	private RedisSerializer valueSerializer = null;</span><br><span class="line">    @Nullable</span><br><span class="line">    private RedisSerializer hashKeySerializer = null;</span><br><span class="line">    @Nullable</span><br><span class="line">    private RedisSerializer hashValueSerializer = null;</span><br><span class="line">    ...</span><br><span class="line">    // 进行默认序列化方式设置，设置为JDK序列化方式</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        super.afterPropertiesSet();</span><br><span class="line">        boolean defaultUsed = false;</span><br><span class="line">        if(this.defaultSerializer == null) &#123;</span><br><span class="line">        this.defaultSerializer = new JdkSerializationRedisSerializer(</span><br><span class="line">        this.classLoader != null?</span><br><span class="line">        this.classLoader:this.getClass().getClassLoader());</span><br><span class="line">	&#125; .</span><br><span class="line">	..</span><br><span class="line">	&#125; .</span><br><span class="line">	..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述RedisTemplate核心源码可以看出，在RedisTemplate内部声明了缓存数据key、value的各<br>种序列化方式，且初始值都为空；在afterPropertiesSet()方法中，判断如果默认序列化参数<br>defaultSerializer为空，将数据的默认序列化方式设置为JdkSerializationRedisSerializer<br>根据上述源码信息的分析，可以得到以下两个重要的结论：<br>（1）使用RedisTemplate进行Redis数据缓存操作时，内部默认使用的是<br>JdkSerializationRedisSerializer序列化方式，所以进行数据缓存的实体类必须实现JDK自带的序列化接<br>口（例如Serializable）；<br>（2）使用RedisTemplate进行Redis数据缓存操作时，如果自定义了缓存序列化方式<br>defaultSerializer，那么将使用自定义的序列化方式。<br>另外，在RedisTemplate类源码中，看到的缓存数据key、value的各种序列化类型都是<br>RedisSerializer。进入RedisSerializer源码查看RedisSerializer支持的序列化方式（进入该类后，使用<br>Ctrl+Alt+左键单击类名查看）<br> 可以看出，RedisSerializer是一个Redis序列化接口，默认有6个实现类，这6个实现类代表了6种<br>不同的数据序列化方式。其中，JdkSerializationRedisSerializer是JDK自带的，也是RedisTemplate内<br>部默认使用的数据序列化方式，开发者可以根据需要选择其他支持的序列化方式（例如JSON方式）<br> <strong>自定义RedisTemplate序列化机制</strong><br>在项目中引入Redis依赖后，Spring Boot提供的RedisAutoConfiguration自动配置会生效。打开<br>RedisAutoConfiguration类，查看内部源码中关于RedisTemplate的定义方式 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(name = &#123;&quot;redisTemplate&quot;&#125;)	 </span><br><span class="line">    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactor redisConnectionFactory) throws</span><br><span class="line">    UnknownHostException &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        return template;</span><br><span class="line">    &#125; .</span><br><span class="line">    ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述RedisAutoConfiguration核心源码中可以看出，在Redis自动配置类中，通过Redis连接工厂<br>RedisConnectionFactory初始化了一个RedisTemplate；该类上方添加了<br>@ConditionalOnMissingBean注解（顾名思义，当某个Bean不存在时生效），用来表明如果开发者自<br>定义了一个名为redisTemplate的Bean，则该默认初始化的RedisTemplate不会生效。<br>如果想要使用自定义序列化方式的RedisTemplate进行数据缓存操作，可以参考上述核心代码创建<br>一个名为redisTemplate的Bean组件，并在该组件中设置对应的序列化方式即可<br>接下来，在项目中创建名为yang.org.config的包，在该包下创建一个Redis自定义配置类<br>RedisConfig，并按照上述思路自定义名为redisTemplate的Bean组件 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;Object,Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        // 创建JSON格式序列化对象，对缓存数据的key和value进行转换</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 解决查询缓存转换异常的问题</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        //设置redisTemplate模板API的序列化方式为json</span><br><span class="line">        template.setDefaultSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过@Configuration注解定义了一个RedisConfig配置类，并使用@Bean注解注入了一个默认名<br>称为方法名的redisTemplate组件（注意，该Bean组件名称必须是redisTemplate）。在定义的Bean组<br>件中，自定义了一个RedisTemplate，使用自定义的Jackson2JsonRedisSerializer数据序列化方式；在<br>定制序列化方式中，定义了一个ObjectMapper用于进行数据转换设置。<br><strong>3．效果测试</strong><br> 启动项目，项目启动成功后，通过浏览器访问“<a target="_blank" rel="noopener" href="http://localhost:8080/api/findCommentById?id=">http://localhost:8080/api/findCommentById?id=</a><br>3”查询id为3的用户评论信息，并重复刷新浏览器查看同一条数据信息 。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619195849.png" alt="img"></p>
<p>查看控制台打印的SQL查询语句 。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619203854.png" alt="img"></p>
<p>可以看出，执行findById()方法正确查询出用户评论信息Comment，重复进行同样的查询操作，数据库<br>只执行了一次SQL语句，这说明定制的Redis缓存生效。<br>使用Redis客户端可视化管理工具Redis Desktop Manager查看缓存数据 ： </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210619195914.png" alt="img"></p>
<p>执行findById()方法查询出用户评论信息Comment正确存储到了Redis缓存库中，且缓存到Redis<br>服务的数据已经使用了JSON格式存储展示，查看和管理也非常方便，说明自定义的Redis API模板工具<br>RedisTemplate生效。</p>
<h3 id="自定义RedisCacheManager"><a href="#自定义RedisCacheManager" class="headerlink" title="自定义RedisCacheManager"></a>自定义RedisCacheManager</h3><p>刚刚针对基于 API方式的RedisTemplate进行了自定义序列化方式的改进，从而实现了JSON序列化<br>方式缓存数据，但是这种自定义的RedisTemplate对于基于注解的Redis缓存来说，是没有作用的。<br>接下来，针对基于注解的Redis缓存机制和自定义序列化方式进行讲解<br><strong>1．Redis注解默认序列化机制</strong><br>打开Spring Boot整合Redis组件提供的缓存自动配置类<br>RedisCacheConfiguration（org.springframework.boot.autoconfigure.cache包下的），查看该类的<br>源码信息，其核心代码如下 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">class RedisCacheConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisCacheManager cacheManager(RedisConnectionFactoryredisConnectionFactory,</span><br><span class="line">                                          ResourceLoader resourceLoader) &#123;</span><br><span class="line">    RedisCacheManagerBuilder builder =RedisCacheManager.builder(redisConnectionFactory)</span><br><span class="line">    .cacheDefaults(this.determineConfiguration(resourceLoader.getClassLoader()));</span><br><span class="line">    List&lt;String&gt; cacheNames = this.cacheProperties.getCacheNames();</span><br><span class="line">    if(!cacheNames.isEmpty()) &#123;</span><br><span class="line">    	builder.initialCacheNames(new LinkedHashSet(cacheNames));</span><br><span class="line">    &#125;</span><br><span class="line">    	return (RedisCacheManager)this.customizerInvoker.customize(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line">    private org.springframework.data.redis.cache.RedisCacheConfiguration</span><br><span class="line">    determineConfiguration(ClassLoader classLoader)&#123;</span><br><span class="line">    if(this.redisCacheConfiguration != null) &#123;</span><br><span class="line">    	return this.redisCacheConfiguration;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Redis redisProperties = this.cacheProperties.getRedis();</span><br><span class="line">        org.springframework.data.redis.cache.RedisCacheConfiguration config</span><br><span class="line">        =org.springframework.data.redis.cache.RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        config = config.serializeValuesWith(SerializationPair.fromSerializer(</span><br><span class="line">        new JdkSerializationRedisSerializer(classLoader)));</span><br><span class="line">        ...</span><br><span class="line">        return config;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述核心源码中可以看出，同RedisTemplate核心源码类似，RedisCacheConfiguration内部同样通<br>过Redis连接工厂RedisConnectionFactory定义了一个缓存管理器RedisCacheManager；同时定制<br>RedisCacheManager时，也默认使用了JdkSerializationRedisSerializer序列化方式。<br>如果想要使用自定义序列化方式的RedisCacheManager进行数据缓存操作，可以参考上述核心代<br>码创建一个名为cacheManager的Bean组件，并在该组件中设置对应的序列化方式即可<br>注意，在Spring Boot 2.X版本中，RedisCacheManager是单独进行构建的。因此，在Spring<br>Boot 2.X版本中，对RedisTemplate进行自定义序列化机制构建后，仍然无法对<br>RedisCacheManager内部默认序列化机制进行覆盖（这也就解释了基 于注解的Redis缓存实现仍<br>然会使用JDK默认序列化机制的原因），想要基于注解的Redis缓存实现也使用自定义序列化机<br>制，需要自定义RedisCacheManager。<br><strong>2．自定义RedisCacheManager</strong><br>在项目的Redis配置类RedisConfig中，按照上一步分析的定制方法自定义名为cacheManager的<br>Bean组件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">        // 分别创建String和JSON格式序列化对象，对缓存数据key和value进行转换</span><br><span class="line">        RedisSerializer&lt;String&gt; strSerializer = new StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jacksonSeial =</span><br><span class="line">                new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"></span><br><span class="line">        // 解决查询缓存转换异常的问题</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jacksonSeial.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        // 定制缓存数据序列化方式及时效</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofDays(1))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair</span><br><span class="line">                        .fromSerializer(strSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair</span><br><span class="line">                        .fromSerializer(jacksonSeial))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager</span><br><span class="line">                .builder(redisConnectionFactory).cacheDefaults(config).build();</span><br><span class="line">        return cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，在RedisConfig配置类中使用@Bean注解注入了一个默认名称为方法名的<br>cacheManager组件。在定义的Bean组件中，通过RedisCacheConfiguration对缓存数据的key和value<br>分别进行了序列化方式的定制，其中缓存数据的key定制为StringRedisSerializer（即String格式），而<br>value定制为了Jackson2JsonRedisSerializer（即JSON格式），同时还使用<br>entryTtl(Duration.ofDays(1))方法将缓存数据有效期设置为1天。<br>完成基于注解的Redis缓存管理器RedisCacheManager定制后，可以对该缓存管理器的效果进行<br>测试（使用自定义序列化机制的RedisCacheManager测试时，实体类可以不用实现序列化接口）。 </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pengdanhua.github.io/post/10f0fa46.html">https://pengdanhua.github.io/post/10f0fa46.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pengdanhua.github.io" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringBoot/">SpringBoot</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165213.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/7f8710c1.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringBoot-web</div></div></a></div><div class="next-post pull-right"><a href="/post/e85cf01d.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165214.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot-数据访问</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/d5933ce9.html" title="SpringBoot-基本使用"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082319.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">SpringBoot-基本使用</div></div></a></div><div><a href="/post/be649375.html" title="SpringBoot-指标监控"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">SpringBoot-指标监控</div></div></a></div><div><a href="/post/e85cf01d.html" title="SpringBoot-数据访问"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165214.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">SpringBoot-数据访问</div></div></a></div><div><a href="/post/7f8710c1.html" title="SpringBoot-web"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">SpringBoot-web</div></div></a></div><div><a href="/post/7b97cc4c.html" title="SpringBoot之Test"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165209.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">SpringBoot之Test</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">默认缓存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.1.</span> <span class="toc-text">基础环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%BC%93%E5%AD%98%E4%BD%93%E9%AA%8C"><span class="toc-number">1.2.</span> <span class="toc-text">默认缓存体验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%90%88Redis%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">整合Redis缓存实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot%E6%94%AF%E6%8C%81%E7%9A%84%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">Spring Boot支持的缓存组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84Redis%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">基于注解的Redis缓存实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EAPI%E7%9A%84Redis%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">基于API的Redis缓存实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Redis%E7%BC%93%E5%AD%98%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">自定义Redis缓存序列化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89RedisTemplate"><span class="toc-number">3.1.</span> <span class="toc-text">自定义RedisTemplate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89RedisCacheManager"><span class="toc-number">3.2.</span> <span class="toc-text">自定义RedisCacheManager</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>