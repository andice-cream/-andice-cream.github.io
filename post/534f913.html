<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java原子操作CAS | 小肥龙吃大冰淇淋</title><meta name="keywords" content="CAS"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="java原子操作CAS 无锁的概念 在谈论无锁概念时，总会关联起乐观派与悲观派，对于乐观派而言，他们认为事情总会往好的方向发展，总是认为坏的情况发生的概率特别小，可以无所顾忌地做事，但对于悲观派而已，他们总会认为发展事态如果不及时控制，以后就无法挽回了，即使无法挽回的局面几乎不可能发生。这两种派系映射到并发编程中就如同加锁与无锁的策略，即加锁是一种悲观策略，无锁是一种乐观策略，因为对于加锁的并发程">
<meta property="og:type" content="article">
<meta property="og:title" content="java原子操作CAS">
<meta property="og:url" content="https://andice-cream.github.io/post/534f913.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="java原子操作CAS 无锁的概念 在谈论无锁概念时，总会关联起乐观派与悲观派，对于乐观派而言，他们认为事情总会往好的方向发展，总是认为坏的情况发生的概率特别小，可以无所顾忌地做事，但对于悲观派而已，他们总会认为发展事态如果不及时控制，以后就无法挽回了，即使无法挽回的局面几乎不可能发生。这两种派系映射到并发编程中就如同加锁与无锁的策略，即加锁是一种悲观策略，无锁是一种乐观策略，因为对于加锁的并发程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082055.jpg">
<meta property="article:published_time" content="2024-05-30T01:10:36.295Z">
<meta property="article:modified_time" content="2023-10-12T01:47:46.622Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="CAS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082055.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://andice-cream.github.io/post/534f913"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java原子操作CAS',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-12 09:47:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">178</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082055.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java原子操作CAS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-30T01:10:36.295Z" title="发表于 2024-05-30 09:10:36">2024-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-12T01:47:46.622Z" title="更新于 2023-10-12 09:47:46">2023-10-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JUC%E7%B3%BB%E5%88%97/">JUC系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java原子操作CAS"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="java原子操作CAS"><a href="#java原子操作CAS" class="headerlink" title="java原子操作CAS"></a>java原子操作CAS</h2><p><img src="https://baiyp.ren/images/thread/cas/cas04.png" alt="img"></p>
<h3 id="无锁的概念"><a href="#无锁的概念" class="headerlink" title="无锁的概念"></a>无锁的概念</h3><p> 在谈论无锁概念时，总会关联起乐观派与悲观派，对于乐观派而言，他们认为事情总会往好的方向发展，总是认为坏的情况发生的概率特别小，可以无所顾忌地做事，但对于悲观派而已，他们总会认为发展事态如果不及时控制，以后就无法挽回了，即使无法挽回的局面几乎不可能发生。这两种派系映射到并发编程中就如同加锁与无锁的策略，即加锁是一种悲观策略，无锁是一种乐观策略，因为对于加锁的并发程序来说，它们总是认为每次访问共享资源时总会发生冲突，因此必须对每一次数据操作实施加锁策略。而无锁则总是假设对共享资源的访问没有冲突，线程可以不停执行，无需加锁，无需等待，一旦发现冲突，无锁策略则采用一种称为CAS的技术来保证线程执行的安全性，这项CAS技术就是无锁策略实现的关键，下面我们进一步了解CAS技术的奇妙之处。</p>
<h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h3><blockquote>
<p>CAS（Compare and Swap），即比较并替换，是用于实现多线程同步的原子指令。</p>
<p>执行函数：CAS(V,E,N)</p>
<p>其包含3个参数</p>
<ul>
<li>V表示要更新的变量</li>
<li>E表示预期值</li>
<li>N表示新值</li>
</ul>
</blockquote>
<p> 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。</p>
<p> 实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，<strong>synchronized</strong>关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁，</p>
<p> 这里会有些问题：首先，如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一直不释放锁怎么办？（这种情况是非常糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那CPU将会花费大量的时间和资源来处理这些竞争，同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。</p>
<p> 实现原子操作还可以使用当前的<strong>处理器</strong>基本都支持CAS的指令，只不过每个厂家所实现的算法并不一样，每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p>
<p> CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环CAS就是在一个循环里不断的做cas操作，直到成功为止。</p>
<p> CAS是怎么实现线程的安全呢？语言层面不做处理，我们将其交给硬件—CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。</p>
<p><img src="https://baiyp.ren/images/thread/cas/cas01.png" alt="img"></p>
<h3 id="CPU指令对CAS的支持"><a href="#CPU指令对CAS的支持" class="headerlink" title="CPU指令对CAS的支持"></a>CPU指令对CAS的支持</h3><p> 或许我们可能会有这样的疑问，假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢？答案是否定的，因为CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</p>
<h3 id="悲观锁，乐观锁"><a href="#悲观锁，乐观锁" class="headerlink" title="悲观锁，乐观锁"></a>悲观锁，乐观锁</h3><p>说到CAS，不得不提到两个专业词语：悲观锁，乐观锁。我们先来看看什么是悲观锁，什么是乐观锁。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p> 顾名思义，就是比较悲观的锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<strong>synchronized</strong>和<strong>ReentrantLock</strong>等独占锁就是悲观锁思想的实现。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p> 反之，总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。我们今天讲的CAS就是乐观锁。</p>
<p> 由于CAS操作属于乐观派，它总认为自己可以成功完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作，这点从图中也可以看出来。基于这样的原理，CAS操作即使没有锁，同样知道其他线程对共享资源操作影响，并执行相应的处理措施。同时从这点也可以看出，由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说无锁操作天生免疫死锁。</p>
<h3 id="CAS-的优点"><a href="#CAS-的优点" class="headerlink" title="CAS 的优点"></a>CAS 的优点</h3><p> 非阻塞的轻量级乐观锁, 通过CPU指令实现, 在资源竞争不激烈的情况下性能高, 相比synchronize重量级悲观锁, synchronize有复杂的加锁, 解锁和唤醒线程操作.。</p>
<h3 id="三大问题"><a href="#三大问题" class="headerlink" title="三大问题"></a>三大问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><blockquote>
<p>假设这样一种场景，当第一个线程执行CAS(V,E,U)操作，在获取到当前变量V，准备修改为新值U前，另外两个线程已连续修改了两次变量V的值，使得该值又恢复为旧值，这样的话，我们就无法正确判断这个变量是否已被修改过，如下图</p>
</blockquote>
<p><img src="https://baiyp.ren/images/thread/cas/cas02.png" alt="img"></p>
<p> 因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p>
<p> 就像上图描述的一样，线程A原来的值是10，线程B修改为了20，但是线程C又将值修改为了10，这个时候线程A来读取了，与旧值做判断，发现还是10，没有修改过，就做了更新操作，但是我们知道，值有过变更。</p>
<p> 这就是典型的CAS的ABA问题，一般情况这种情况发现的概率比较小，可能发生了也不会造成什么问题，比如说我们对某个做加减法，不关心数字的过程，那么发生ABA问题也没啥关系。但是在某些情况下还是需要防止的，那么该如何解决呢？在Java中解决ABA问题，我们可以使用以下两个原子类</p>
<h5 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h5><blockquote>
<p>AtomicStampedReference原子类是一个带有时间戳的对象引用，在每次修改后，AtomicStampedReference不仅会设置新值而且还会记录更改的时间。当AtomicStampedReference设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境，测试demo如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ABADemo &#123;</span><br><span class="line"></span><br><span class="line">    static AtomicInteger atIn = new AtomicInteger(100);</span><br><span class="line"></span><br><span class="line">    //初始化时需要传入一个初始值和初始时间</span><br><span class="line">    static AtomicStampedReference&lt;Integer&gt; atomicStampedR =</span><br><span class="line">            new AtomicStampedReference&lt;Integer&gt;(200,0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //更新为200</span><br><span class="line">            atIn.compareAndSet(100, 200);</span><br><span class="line">            //更新为100</span><br><span class="line">            atIn.compareAndSet(200, 100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            boolean flag=atIn.compareAndSet(100,500);</span><br><span class="line">            System.out.println(&quot;flag:&quot;+flag+&quot;,newValue:&quot;+atIn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static Thread t3 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int time=atomicStampedR.getStamp();</span><br><span class="line">            //更新为200</span><br><span class="line">            atomicStampedR.compareAndSet(100, 200,time,time+1);</span><br><span class="line">            //更新为100</span><br><span class="line">            int time2=atomicStampedR.getStamp();</span><br><span class="line">            atomicStampedR.compareAndSet(200, 100,time2,time2+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static Thread t4 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int time = atomicStampedR.getStamp();</span><br><span class="line">            System.out.println(&quot;sleep 前 t4 time:&quot;+time);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            boolean flag=atomicStampedR.compareAndSet(100,500,time,time+1);</span><br><span class="line">            System.out.println(&quot;flag:&quot;+flag+&quot;,newValue:&quot;+atomicStampedR.getReference());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static  void  main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        /**</span><br><span class="line">         * 输出结果:</span><br><span class="line">         flag:true,newValue:500</span><br><span class="line">         sleep 前 t4 time:0</span><br><span class="line">         flag:false,newValue:200</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比输出结果可知，AtomicStampedReference类确实解决了ABA的问题，下面我们简单看看其内部实现原理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AtomicStampedReference&lt;V&gt; &#123;</span><br><span class="line">    //通过Pair内部类存储数据和时间戳</span><br><span class="line">    private static class Pair&lt;T&gt; &#123;</span><br><span class="line">        final T reference;</span><br><span class="line">        final int stamp;</span><br><span class="line">        private Pair(T reference, int stamp) &#123;</span><br><span class="line">            this.reference = reference;</span><br><span class="line">            this.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;</span><br><span class="line">            return new Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //存储数值和时间的内部类</span><br><span class="line">    private volatile Pair&lt;V&gt; pair;</span><br><span class="line"></span><br><span class="line">    //构造器，创建时需传入初始值和时间初始值</span><br><span class="line">    public AtomicStampedReference(V initialRef, int initialStamp) &#123;</span><br><span class="line">        pair = Pair.of(initialRef, initialStamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接着看看其compareAndSet方法的实现：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                                 V   newReference,</span><br><span class="line">                                 int expectedStamp,</span><br><span class="line">                                 int newStamp) &#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        return</span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同时对当前数据和当前时间进行比较，只有两者都相等是才会执行casPair()方法，单从该方法的名称就可知是一个CAS方法，最终调用的还是Unsafe类中的compareAndSwapObject方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123;</span><br><span class="line">        return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到这我们就很清晰AtomicStampedReference的内部实现思想了，通过一个键值对Pair存储数据和时间戳，在更新时对数据和时间戳进行比较，只有两者都符合预期才会调用Unsafe的compareAndSwapObject方法执行数值和时间戳替换，也就避免了ABA的问题。</p>
<h5 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h5><blockquote>
<p>AtomicMarkableReference与AtomicStampedReference不同的是，AtomicMarkableReference维护的是一个boolean值的标识，也就是说至于true和false两种切换状态，经过测试，这种方式并不能完全防止ABA问题的发生，只能减少ABA问题发生的概率。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ABADemo &#123;</span><br><span class="line">    static AtomicMarkableReference&lt;Integer&gt; atMarkRef =</span><br><span class="line">              new AtomicMarkableReference&lt;Integer&gt;(100,false);</span><br><span class="line"></span><br><span class="line"> static Thread t5 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            boolean mark=atMarkRef.isMarked();</span><br><span class="line">            System.out.println(&quot;mark:&quot;+mark);</span><br><span class="line">            //更新为200</span><br><span class="line">            System.out.println(&quot;t5 result:&quot;+atMarkRef.compareAndSet(atMarkRef.getReference(), 200,mark,!mark));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread t6 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            boolean mark2=atMarkRef.isMarked();</span><br><span class="line">            System.out.println(&quot;mark2:&quot;+mark2);</span><br><span class="line">            System.out.println(&quot;t6 result:&quot;+atMarkRef.compareAndSet(atMarkRef.getReference(), 100,mark2,!mark2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread t7 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            boolean mark=atMarkRef.isMarked();</span><br><span class="line">            System.out.println(&quot;sleep 前 t7 mark:&quot;+mark);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            boolean flag=atMarkRef.compareAndSet(100,500,mark,!mark);</span><br><span class="line">            System.out.println(&quot;flag:&quot;+flag+&quot;,newValue:&quot;+atMarkRef.getReference());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static  void  main(String[] args) throws InterruptedException &#123;        </span><br><span class="line">        t5.start();t5.join();</span><br><span class="line">        t6.start();t6.join();</span><br><span class="line">        t7.start();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 输出结果:</span><br><span class="line">         mark:false</span><br><span class="line">         t5 result:true</span><br><span class="line">         mark2:true</span><br><span class="line">         t6 result:true</span><br><span class="line">         sleep 前 t5 mark:false</span><br><span class="line">         flag:true,newValue:500 ----&gt;成功了.....说明还是发生ABA问题</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AtomicMarkableReference的实现原理与AtomicStampedReference类似，这里不再介绍。到此，我们也明白了如果要完全杜绝ABA问题的发生，我们应该使用AtomicStampedReference原子类更新对象，而对于AtomicMarkableReference来说只能减少ABA问题的发生概率，并不能杜绝。</p>
<h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p> 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p>
<p> 还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p>
<h3 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h3><blockquote>
<p>Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有着类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用的Unsafe类，据说Oracle正在计划从Java 9中去掉Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务，关于Unsafe类的主要功能点如下：</p>
</blockquote>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><blockquote>
<p>Unsafe类中存在直接操作内存的方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//分配内存指定大小的内存</span><br><span class="line">public native long allocateMemory(long bytes);</span><br><span class="line">//根据给定的内存地址address设置重新分配指定大小的内存</span><br><span class="line">public native long reallocateMemory(long address, long bytes);</span><br><span class="line">//用于释放allocateMemory和reallocateMemory申请的内存</span><br><span class="line">public native void freeMemory(long address);</span><br><span class="line">//将指定对象的给定offset偏移量内存块中的所有字节设置为固定值</span><br><span class="line">public native void setMemory(Object o, long offset, long bytes, byte value);</span><br><span class="line">//设置给定内存地址的值</span><br><span class="line">public native void putAddress(long address, long x);</span><br><span class="line">//获取指定内存地址的值</span><br><span class="line">public native long getAddress(long address);</span><br><span class="line"></span><br><span class="line">//设置给定内存地址的long值</span><br><span class="line">public native void putLong(long address, long x);</span><br><span class="line">//获取指定内存地址的long值</span><br><span class="line">public native long getLong(long address);</span><br><span class="line">//设置或获取指定内存的byte值</span><br><span class="line">public native byte  getByte(long address);</span><br><span class="line">public native void  putByte(long address, byte x);</span><br><span class="line">//其他基本数据类型(long,char,float,double,short等)的操作与putByte及getByte相同</span><br><span class="line"></span><br><span class="line">//操作系统的内存页大小</span><br><span class="line">public native int pageSize();</span><br></pre></td></tr></table></figure>

<h4 id="提供实例对象新途径"><a href="#提供实例对象新途径" class="headerlink" title="提供实例对象新途径"></a>提供实例对象新途径</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//传入一个对象的class并创建该实例对象，但不会调用构造方法</span><br><span class="line">public native Object allocateInstance(Class cls) throws InstantiationException;</span><br></pre></td></tr></table></figure>

<h4 id="类和实例对象以及变量的操作"><a href="#类和实例对象以及变量的操作" class="headerlink" title="类和实例对象以及变量的操作"></a>类和实例对象以及变量的操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取字段f在实例对象中的偏移量</span><br><span class="line">public native long objectFieldOffset(Field f);</span><br><span class="line">//静态属性的偏移量，用于在对应的Class对象中读写静态属性</span><br><span class="line">public native long staticFieldOffset(Field f);</span><br><span class="line">//返回值就是f.getDeclaringClass()</span><br><span class="line">public native Object staticFieldBase(Field f);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获得给定对象偏移量上的int值，所谓的偏移量可以简单理解为指针指向该变量的内存地址，</span><br><span class="line">//通过偏移量便可得到该对象的变量，进行各种操作</span><br><span class="line">public native int getInt(Object o, long offset);</span><br><span class="line">//设置给定对象上偏移量的int值</span><br><span class="line">public native void putInt(Object o, long offset, int x);</span><br><span class="line"></span><br><span class="line">//获得给定对象偏移量上的引用类型的值</span><br><span class="line">public native Object getObject(Object o, long offset);</span><br><span class="line">//设置给定对象偏移量上的引用类型的值</span><br><span class="line">public native void putObject(Object o, long offset, Object x);</span><br><span class="line">//其他基本数据类型(long,char,byte,float,double)的操作与getInthe及putInt相同</span><br><span class="line"></span><br><span class="line">//设置给定对象的int值，使用volatile语义，即设置后立马更新到内存对其他线程可见</span><br><span class="line">public native void  putIntVolatile(Object o, long offset, int x);</span><br><span class="line">//获得给定对象的指定偏移量offset的int值，使用volatile语义，总能获取到最新的int值。</span><br><span class="line">public native int getIntVolatile(Object o, long offset);</span><br><span class="line"></span><br><span class="line">//其他基本数据类型(long,char,byte,float,double)的操作与putIntVolatile及getIntVolatile相同，引用类型putObjectVolatile也一样。</span><br><span class="line"></span><br><span class="line">//与putIntVolatile一样，但要求被操作字段必须有volatile修饰</span><br><span class="line">public native void putOrderedInt(Object o,long offset,int x);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面通过一个简单的Demo来演示上述的一些方法以便加深对Unsafe类的理解</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UnSafeDemo &#123;</span><br><span class="line"></span><br><span class="line">    public  static  void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        // 通过反射得到theUnsafe对应的Field对象</span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">        // 设置该Field为可访问</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        // 通过Field得到该Field对应的具体对象，传入null是因为该Field为static的</span><br><span class="line">        Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class="line">        System.out.println(unsafe);</span><br><span class="line"></span><br><span class="line">        //通过allocateInstance直接创建对象</span><br><span class="line">        User user = (User) unsafe.allocateInstance(User.class);</span><br><span class="line"></span><br><span class="line">        Class userClass = user.getClass();</span><br><span class="line">        Field name = userClass.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        Field age = userClass.getDeclaredField(&quot;age&quot;);</span><br><span class="line">        Field id = userClass.getDeclaredField(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">        //获取实例变量name和age在对象内存中的偏移量并设置值</span><br><span class="line">        unsafe.putInt(user,unsafe.objectFieldOffset(age),18);</span><br><span class="line">        unsafe.putObject(user,unsafe.objectFieldOffset(name),&quot;android TV&quot;);</span><br><span class="line"></span><br><span class="line">        // 这里返回 User.class，</span><br><span class="line">        Object staticBase = unsafe.staticFieldBase(id);</span><br><span class="line">        System.out.println(&quot;staticBase:&quot;+staticBase);</span><br><span class="line"></span><br><span class="line">        //获取静态变量id的偏移量staticOffset</span><br><span class="line">        long staticOffset = unsafe.staticFieldOffset(userClass.getDeclaredField(&quot;id&quot;));</span><br><span class="line">        //获取静态变量的值</span><br><span class="line">        System.out.println(&quot;设置前的ID:&quot;+unsafe.getObject(staticBase,staticOffset));</span><br><span class="line">        //设置值</span><br><span class="line">        unsafe.putObject(staticBase,staticOffset,&quot;SSSSSSSS&quot;);</span><br><span class="line">        //获取静态变量的值</span><br><span class="line">        System.out.println(&quot;设置前的ID:&quot;+unsafe.getObject(staticBase,staticOffset));</span><br><span class="line">        //输出USER</span><br><span class="line">        System.out.println(&quot;输出USER:&quot;+user.toString());</span><br><span class="line"></span><br><span class="line">        long data = 1000;</span><br><span class="line">        byte size = 1;//单位字节</span><br><span class="line"></span><br><span class="line">        //调用allocateMemory分配内存,并获取内存地址memoryAddress</span><br><span class="line">        long memoryAddress = unsafe.allocateMemory(size);</span><br><span class="line">        //直接往内存写入数据</span><br><span class="line">        unsafe.putAddress(memoryAddress, data);</span><br><span class="line">        //获取指定内存地址的数据</span><br><span class="line">        long addrData=unsafe.getAddress(memoryAddress);</span><br><span class="line">        System.out.println(&quot;addrData:&quot;+addrData);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 输出结果:</span><br><span class="line">         sun.misc.Unsafe@6f94fa3e</span><br><span class="line">         staticBase:class geym.conc.ch4.atomic.User</span><br><span class="line">         设置前的ID:USER_ID</span><br><span class="line">         设置前的ID:SSSSSSSS</span><br><span class="line">         输出USER:User&#123;name=&#x27;android TV&#x27;, age=18&#x27;, id=SSSSSSSS&#x27;&#125;</span><br><span class="line">         addrData:1000</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User&#123;</span><br><span class="line">    public User()&#123;</span><br><span class="line">        System.out.println(&quot;user 构造方法被调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private static String id=&quot;USER_ID&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +&#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, id=&quot; + id +&#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然在Unsafe类中存在getUnsafe()方法，但该方法只提供给高级的Bootstrap类加载器使用，普通用户调用将抛出异常，所以我们在Demo中使用了反射技术获取了Unsafe实例对象并进行相关操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Unsafe getUnsafe() &#123;</span><br><span class="line">      Class cc = sun.reflect.Reflection.getCallerClass(2);</span><br><span class="line">      if (cc.getClassLoader() != null)</span><br><span class="line">          throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">      return theUnsafe;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取数组第一个元素的偏移地址</span><br><span class="line">public native int arrayBaseOffset(Class arrayClass);</span><br><span class="line">//数组中一个元素占据的内存空间,arrayBaseOffset与arrayIndexScale配合使用，可定位数组中每个元素在内存中的位置</span><br><span class="line">public native int arrayIndexScale(Class arrayClass);</span><br></pre></td></tr></table></figure>

<h4 id="CAS-操作相关"><a href="#CAS-操作相关" class="headerlink" title="CAS 操作相关"></a>CAS 操作相关</h4><blockquote>
<p>CAS是一些CPU直接支持的指令，也就是我们前面分析的无锁操作，在Java中无锁操作CAS基于以下3个方法实现，在稍后讲解Atomic系列内部方法是基于下述方法的实现的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，</span><br><span class="line">//expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。</span><br><span class="line">public final native boolean compareAndSwapObject(Object o, long offset,Object expected, Object x);                                                                                                  </span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapLong(Object o, long offset,long expected,long x);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里还需介绍Unsafe类中JDK 1.8新增的几个方法，它们的实现是基于上述的CAS方法，如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.8新增，给定对象o，根据获取内存偏移量指向的字段，将其增加delta，</span><br><span class="line"> //这是一个CAS操作过程，直到设置成功方能退出循环，返回旧值</span><br><span class="line"> public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">     int v;</span><br><span class="line">     do &#123;</span><br><span class="line">         //获取内存中最新值</span><br><span class="line">         v = getIntVolatile(o, offset);</span><br><span class="line">       //通过CAS操作</span><br><span class="line">     &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">     return v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">//1.8新增，方法作用同上，只不过这里操作的long类型数据</span><br><span class="line"> public final long getAndAddLong(Object o, long offset, long delta) &#123;</span><br><span class="line">     long v;</span><br><span class="line">     do &#123;</span><br><span class="line">         v = getLongVolatile(o, offset);</span><br><span class="line">     &#125; while (!compareAndSwapLong(o, offset, v, v + delta));</span><br><span class="line">     return v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //1.8新增，给定对象o，根据获取内存偏移量对于字段，将其 设置为新值newValue，</span><br><span class="line"> //这是一个CAS操作过程，直到设置成功方能退出循环，返回旧值</span><br><span class="line"> public final int getAndSetInt(Object o, long offset, int newValue) &#123;</span><br><span class="line">     int v;</span><br><span class="line">     do &#123;</span><br><span class="line">         v = getIntVolatile(o, offset);</span><br><span class="line">     &#125; while (!compareAndSwapInt(o, offset, v, newValue));</span><br><span class="line">     return v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// 1.8新增，同上，操作的是long类型</span><br><span class="line"> public final long getAndSetLong(Object o, long offset, long newValue) &#123;</span><br><span class="line">     long v;</span><br><span class="line">     do &#123;</span><br><span class="line">         v = getLongVolatile(o, offset);</span><br><span class="line">     &#125; while (!compareAndSwapLong(o, offset, v, newValue));</span><br><span class="line">     return v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //1.8新增，同上，操作的是引用类型数据</span><br><span class="line"> public final Object getAndSetObject(Object o, long offset, Object newValue) &#123;</span><br><span class="line">     Object v;</span><br><span class="line">     do &#123;</span><br><span class="line">         v = getObjectVolatile(o, offset);</span><br><span class="line">     &#125; while (!compareAndSwapObject(o, offset, v, newValue));</span><br><span class="line">     return v;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上述的方法我们在稍后的Atomic系列分析中还会见到它们的身影。</p>
<h4 id="挂起与恢复"><a href="#挂起与恢复" class="headerlink" title="挂起与恢复"></a>挂起与恢复</h4><blockquote>
<p>将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。Java对线程的挂起操作被封装在 LockSupport类中，LockSupport类中有各种版本pack方法，其底层实现最终还是使用Unsafe.park()方法和Unsafe.unpark()方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//线程调用该方法，线程将一直阻塞直到超时，或者是中断条件出现。  </span><br><span class="line">public native void park(boolean isAbsolute, long time);  </span><br><span class="line"></span><br><span class="line">//终止挂起的线程，恢复正常.java.util.concurrent包中挂起操作都是在LockSupport类实现的，其底层正是使用这两个方法，  </span><br><span class="line">public native void unpark(Object thread); </span><br></pre></td></tr></table></figure>

<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><blockquote>
<p>这里主要包括了loadFence、storeFence、fullFence等方法，这些方法是在Java 8新引入的，用于定义内存屏障，避免代码重排序。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在该方法之前的所有读操作，一定在load屏障之前执行完成</span><br><span class="line">public native void loadFence();</span><br><span class="line">//在该方法之前的所有写操作，一定在store屏障之前执行完成</span><br><span class="line">public native void storeFence();</span><br><span class="line">//在该方法之前的所有读写操作，一定在full屏障之前执行完成，这个内存屏障相当于上面两个的合体功能</span><br><span class="line">public native void fullFence();</span><br></pre></td></tr></table></figure>

<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取持有锁，已不建议使用</span><br><span class="line">@Deprecated</span><br><span class="line">public native void monitorEnter(Object var1);</span><br><span class="line">//释放锁，已不建议使用</span><br><span class="line">@Deprecated</span><br><span class="line">public native void monitorExit(Object var1);</span><br><span class="line">//尝试获取锁，已不建议使用</span><br><span class="line">@Deprecated</span><br><span class="line">public native boolean tryMonitorEnter(Object var1);</span><br><span class="line"></span><br><span class="line">//获取本机内存的页数，这个值永远都是2的幂次方  </span><br><span class="line">public native int pageSize();  </span><br><span class="line"></span><br><span class="line">//告诉虚拟机定义了一个没有安全检查的类，默认情况下这个类加载器和保护域来着调用者类  </span><br><span class="line">public native Class defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);  </span><br><span class="line"></span><br><span class="line">//加载一个匿名类</span><br><span class="line">public native Class defineAnonymousClass(Class hostClass, byte[] data, Object[] cpPatches);</span><br><span class="line">//判断是否需要加载一个类</span><br><span class="line">public native boolean shouldBeInitialized(Class&lt;?&gt; c);</span><br><span class="line">//确保类一定被加载 </span><br><span class="line">public native  void ensureClassInitialized(Class&lt;?&gt; c)</span><br></pre></td></tr></table></figure>

<h3 id="原子操作类使用"><a href="#原子操作类使用" class="headerlink" title="原子操作类使用"></a>原子操作类使用</h3><blockquote>
<p>通过前面的分析我们已基本理解了无锁CAS的原理并对Java中的指针类Unsafe类有了比较全面的认识，下面进一步分析CAS在Java中的应用，即并发包中的原子操作类(Atomic系列)，从JDK 1.5开始提供了java.util.concurrent.atomic包，在该包中提供了许多基于CAS实现的原子操作类，用法方便，性能高效，主要分以下4种类型。</p>
</blockquote>
<p><img src="https://baiyp.ren/images/thread/cas/cas03.png" alt="img"></p>
<h4 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h4><blockquote>
<p>原子更新基本类型主要包括3个类：</p>
<ul>
<li>AtomicBoolean：原子更新布尔类型</li>
<li>AtomicInteger：原子更新整型</li>
<li>AtomicLong：原子更新长整型</li>
</ul>
</blockquote>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p> 这3个类的实现原理和使用方式几乎是一样的，这里我们以AtomicInteger为例进行分析，AtomicInteger主要是针对int类型的数据执行原子操作，它提供了原子自增方法、原子自减方法以及原子赋值方法等，鉴于AtomicInteger的源码不多，我们直接看源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 6214790243416807050L;</span><br><span class="line"></span><br><span class="line">    // 获取指针类Unsafe</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    //下述变量value在AtomicInteger实例对象内的内存偏移量</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           //通过unsafe类的objectFieldOffset()方法，获取value变量在对象内存中的偏移</span><br><span class="line">           //通过该偏移量valueOffset，unsafe类的内部方法可以获取到变量value对其进行取值或赋值操作</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   //当前AtomicInteger封装的int变量value</span><br><span class="line">    private volatile int value;</span><br><span class="line"></span><br><span class="line">    public AtomicInteger(int initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    public AtomicInteger() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   //获取当前最新值，</span><br><span class="line">    public final int get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置当前值，具备volatile效果，方法用final修饰是为了更进一步的保证线程安全。</span><br><span class="line">    public final void set(int newValue) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    //最终会设置成newValue，使用该方法后可能导致其他线程在之后的一小段时间内可以获取到旧值，有点类似于延迟加载</span><br><span class="line">    public final void lazySet(int newValue) &#123;</span><br><span class="line">        unsafe.putOrderedInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">   //设置新值并获取旧值，底层调用的是CAS操作即unsafe.compareAndSwapInt()方法</span><br><span class="line">    public final int getAndSet(int newValue) &#123;</span><br><span class="line">        return unsafe.getAndSetInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">   //如果当前值为expect，则设置为update(当前值指的是value变量)</span><br><span class="line">    public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    //当前值加1返回旧值，底层CAS操作</span><br><span class="line">    public final int getAndIncrement() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    //当前值减1，返回旧值，底层CAS操作</span><br><span class="line">    public final int getAndDecrement() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, -1);</span><br><span class="line">    &#125;</span><br><span class="line">   //当前值增加delta，返回旧值，底层CAS操作</span><br><span class="line">    public final int getAndAdd(int delta) &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line">    //当前值加1，返回新值，底层CAS操作</span><br><span class="line">    public final int incrementAndGet() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //当前值减1，返回新值，底层CAS操作</span><br><span class="line">    public final int decrementAndGet() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;</span><br><span class="line">    &#125;</span><br><span class="line">   //当前值增加delta，返回新值，底层CAS操作</span><br><span class="line">    public final int addAndGet(int delta) &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;</span><br><span class="line">    &#125;</span><br><span class="line">   //省略一些不常用的方法....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通过上述的分析，可以发现AtomicInteger原子类的内部几乎是基于前面分析过Unsafe类中的CAS相关操作的方法实现的，这也同时证明AtomicInteger是基于无锁实现的，这里重点分析自增操作实现过程，其他方法自增实现原理一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//当前值加1，返回新值，底层CAS操作</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">     return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 我们发现AtomicInteger类中所有自增或自减的方法都间接调用Unsafe类中的getAndAddInt()方法实现了CAS操作，从而保证了线程安全，关于getAndAddInt其实前面已分析过，它是Unsafe类中1.8新增的方法，源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Unsafe类中的getAndAddInt方法</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">        int v;</span><br><span class="line">        do &#123;</span><br><span class="line">            v = getIntVolatile(o, offset);</span><br><span class="line">        &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 可看出getAndAddInt通过一个while循环不断的重试更新要设置的值，直到成功为止，调用的是Unsafe类中的compareAndSwapInt方法，是一个CAS操作方法。这里需要注意的是，上述源码分析是基于JDK1.8的，如果是1.8之前的方法，AtomicInteger源码实现有所不同，是基于for死循环的，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//JDK 1.7的源码，由for的死循环实现，并且直接在AtomicInteger实现该方法，</span><br><span class="line">//JDK1.8后，该方法实现已移动到Unsafe类中，直接调用getAndAddInt方法即可</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><blockquote>
<p>下面简单看个Demo，感受一下AtomicInteger使用方式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AtomicIntegerDemo &#123;</span><br><span class="line">    //创建AtomicInteger,用于自增操作</span><br><span class="line">    static AtomicInteger i=new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public static class AddThread implements Runnable&#123;</span><br><span class="line">        public void run()&#123;</span><br><span class="line">           for(int k=0;k&lt;10000;k++)</span><br><span class="line">               i.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread[] ts=new Thread[10];</span><br><span class="line">        //开启10条线程同时执行i的自增操作</span><br><span class="line">        for(int k=0;k&lt;10;k++)&#123;</span><br><span class="line">            ts[k]=new Thread(new AddThread());</span><br><span class="line">        &#125;</span><br><span class="line">        //启动线程</span><br><span class="line">        for(int k=0;k&lt;10;k++)&#123;ts[k].start();&#125;</span><br><span class="line"></span><br><span class="line">        for(int k=0;k&lt;10;k++)&#123;ts[k].join();&#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(i);//输出结果:100000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Demo中，使用原子类型AtomicInteger替换普通int类型执行自增的原子操作，保证了线程安全。至于AtomicBoolean和AtomicLong的使用方式以及实现原理是一样，大家可以自行查阅源码。</p>
<h4 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h4><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><blockquote>
<p>原子更新引用类型可以同时更新引用类型，这里主要分析一下AtomicReference原子类，即原子更新引用类型。先看看其使用方式，如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AtomicReferenceDemo2 &#123;</span><br><span class="line"></span><br><span class="line">    public static AtomicReference&lt;User&gt; atomicUserRef = new AtomicReference&lt;User&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user = new User(&quot;zejian&quot;, 18);</span><br><span class="line">        atomicUserRef.set(user);</span><br><span class="line">        User updateUser = new User(&quot;Shine&quot;, 25);</span><br><span class="line">        atomicUserRef.compareAndSet(user, updateUser);</span><br><span class="line">        //执行结果:User&#123;name=&#x27;Shine&#x27;, age=25&#125;</span><br><span class="line">              System.out.println(atomicUserRef.get().toString());  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class User &#123;</span><br><span class="line">        public String name;</span><br><span class="line">        private int age;</span><br><span class="line"></span><br><span class="line">        public User(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;User&#123;&quot; +</span><br><span class="line">                    &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                    &quot;, age=&quot; + age +</span><br><span class="line">                    &#x27;&#125;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><blockquote>
<p>那么AtomicReference原子类内部是如何实现CAS操作的呢？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123;</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //内部变量value，Unsafe类通过valueOffset内存偏移量即可获取该变量</span><br><span class="line">    private volatile V value;</span><br><span class="line"></span><br><span class="line">//CAS方法，间接调用unsafe.compareAndSwapObject(),它是一个</span><br><span class="line">//实现了CAS操作的native方法</span><br><span class="line">public final boolean compareAndSet(V expect, V update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapObject(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置并获取旧值</span><br><span class="line">public final V getAndSet(V newValue) &#123;</span><br><span class="line">        return (V)unsafe.getAndSetObject(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    //省略其他代码......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Unsafe类中的getAndSetObject方法，实际调用还是CAS操作</span><br><span class="line">public final Object getAndSetObject(Object o, long offset, Object newValue) &#123;</span><br><span class="line">      Object v;</span><br><span class="line">      do &#123;</span><br><span class="line">          v = getObjectVolatile(o, offset);</span><br><span class="line">      &#125; while (!compareAndSwapObject(o, offset, v, newValue));</span><br><span class="line">      return v;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> 从源码看来，AtomicReference与AtomicInteger的实现原理基本是一样的，最终执行的还是Unsafe类，关于AtomicReference的其他方法也是一样的，如下</p>
<p><img src="https://baiyp.ren/images/thread/cas/cas06.png" alt="img"></p>
<p>红框内的方法是Java8新增的，可以基于Lambda表达式对传递进来的期望值或要更新的值进行其他操作后再进行CAS操作，说白了就是对期望值或要更新的值进行额外修改后再执行CAS更新，在所有的Atomic原子类中几乎都存在这几个方法。</p>
<h4 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h4><blockquote>
<p>原子更新数组指的是通过原子的方式<strong>更新数组里的某个元素</strong>，主要有以下3个类</p>
<ul>
<li>AtomicIntegerArray：原子更新整数数组里的元素</li>
<li>AtomicLongArray：原子更新长整数数组里的元素</li>
<li>AtomicReferenceArray：原子更新引用类型数组里的元素</li>
</ul>
</blockquote>
<h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h5><blockquote>
<p>这里以AtomicIntegerArray为例进行分析，其余两个使用方式和实现原理基本一样，简单案例如下，</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AtomicIntegerArrayDemo &#123;</span><br><span class="line">    static AtomicIntegerArray arr = new AtomicIntegerArray(10);</span><br><span class="line"></span><br><span class="line">    public static class AddThread implements Runnable&#123;</span><br><span class="line">        public void run()&#123;</span><br><span class="line">           for(int k=0;k&lt;10000;k++)</span><br><span class="line">               //执行数组中元素自增操作,参数为index,即数组下标</span><br><span class="line">               arr.getAndIncrement(k%arr.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Thread[] ts=new Thread[10];</span><br><span class="line">        //创建10条线程</span><br><span class="line">        for(int k=0;k&lt;10;k++)&#123;</span><br><span class="line">            ts[k]=new Thread(new AddThread());</span><br><span class="line">        &#125;</span><br><span class="line">        //启动10条线程</span><br><span class="line">        for(int k=0;k&lt;10;k++)&#123;ts[k].start();&#125;</span><br><span class="line">        for(int k=0;k&lt;10;k++)&#123;ts[k].join();&#125;</span><br><span class="line">        //执行结果</span><br><span class="line">        //[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span><br><span class="line">        System.out.println(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><blockquote>
<p>启动10条线程对数组中的元素进行自增操作，执行结果符合预期。使用方式比较简单，接着看看AtomicIntegerArray内部是如何实现，先看看部分源码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AtomicIntegerArray implements java.io.Serializable &#123;</span><br><span class="line">    //获取unsafe类的实例对象</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    //获取数组的第一个元素内存起始地址</span><br><span class="line">    private static final int base = unsafe.arrayBaseOffset(int[].class);</span><br><span class="line"></span><br><span class="line">    private static final int shift;</span><br><span class="line">    //内部数组</span><br><span class="line">    private final int[] array;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //获取数组中一个元素占据的内存空间</span><br><span class="line">        int scale = unsafe.arrayIndexScale(int[].class);</span><br><span class="line">        //判断是否为2的次幂，一般为2的次幂否则抛异常</span><br><span class="line">        if ((scale &amp; (scale - 1)) != 0)</span><br><span class="line">            throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">        //</span><br><span class="line">        shift = 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long checkedByteOffset(int i) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= array.length)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;index &quot; + i);</span><br><span class="line"></span><br><span class="line">        return byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line">    //计算数组中每个元素的的内存地址</span><br><span class="line">    private static long byteOffset(int i) &#123;</span><br><span class="line">        return ((long) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br><span class="line">    //省略其他代码......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通过前面对Unsafe类的分析，我们知道arrayBaseOffset方法可以获取数组的第一个元素起始地址，而arrayIndexScale方法可以获取每个数组元素占用的内存空间，由于这里是Int类型，而Java中一个int类型占用4个字节，也就是scale的值为4，那么如何根据数组下标值计算每个元素的内存地址呢？显然应该是</p>
<blockquote>
<p>每个数组元素的内存地址=起始地址+元素下标 * 每个元素所占用的内存空间</p>
</blockquote>
<p>与该方法原理相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//计算数组中每个元素的的内存地址</span><br><span class="line">private static long byteOffset(int i) &#123;</span><br><span class="line">     return ((long) i &lt;&lt; shift) + base;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是为什么，首先来计算出shift的值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shift = 31 - Integer.numberOfLeadingZeros(scale);</span><br></pre></td></tr></table></figure>

<p> 其中Integer.numberOfLeadingZeros(scale)是计算出scale的前导零个数(必须是连续的)，scale=4，转成二进制为 <code>00000000 00000000 00000000 00000100</code><br>​ 即前导零数为29，也就是shift=2，然后利用shift来定位数组中的内存位置，在数组不越界时，计算出前3个数组元素内存地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一个数组元素，index=0 ， 其中base为起始地址，4代表int类型占用的字节数 </span><br><span class="line">address = base + 0 * 4 即address= base + 0 &lt;&lt; 2</span><br><span class="line">//第二个数组元素，index=1</span><br><span class="line">address = base + 1 * 4 即address= base + 1 &lt;&lt; 2</span><br><span class="line">//第三个数组元素，index=2</span><br><span class="line">address = base + 2 * 4 即address= base + 2 &lt;&lt; 2</span><br><span class="line">//........</span><br></pre></td></tr></table></figure>

<p>显然shift=2，替换去就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address= base + i &lt;&lt; shift</span><br></pre></td></tr></table></figure>

<p>这就是 byteOffset(int i) 方法的计算原理。因此byteOffset(int)方法可以根据数组下标计算出每个元素的内存地址。至于其他方法就比较简单了，都是间接调用Unsafe类的CAS原子操作方法，如下简单看其中几个常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//执行自增操作，返回旧值，i是指数组元素下标</span><br><span class="line">public final int getAndIncrement(int i) &#123;</span><br><span class="line">      return getAndAdd(i, 1);</span><br><span class="line">&#125;</span><br><span class="line">//指定下标元素执行自增操作，并返回新值</span><br><span class="line">public final int incrementAndGet(int i) &#123;</span><br><span class="line">    return getAndAdd(i, 1) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定下标元素执行自减操作，并返回新值</span><br><span class="line">public final int decrementAndGet(int i) &#123;</span><br><span class="line">    return getAndAdd(i, -1) - 1;</span><br><span class="line">&#125;</span><br><span class="line">//间接调用unsafe.getAndAddInt()方法</span><br><span class="line">public final int getAndAdd(int i, int delta) &#123;</span><br><span class="line">    return unsafe.getAndAddInt(array, checkedByteOffset(i), delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Unsafe类中的getAndAddInt方法，执行CAS操作</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">        int v;</span><br><span class="line">        do &#123;</span><br><span class="line">            v = getIntVolatile(o, offset);</span><br><span class="line">        &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至于AtomicLongArray和AtomicReferenceArray原子类，使用方式和实现原理基本一样。</p>
<h4 id="原子更新属性"><a href="#原子更新属性" class="headerlink" title="原子更新属性"></a>原子更新属性</h4><blockquote>
<p>如果我们只需要某个类里的某个字段，也就是说让普通的变量也享受原子操作，可以使用原子更新字段类，如在某些时候由于项目前期考虑不周全，项目需求又发生变化，使得某个类中的变量需要执行多线程操作，由于该变量多处使用，改动起来比较麻烦，而且原来使用的地方无需使用线程安全，只要求新场景需要使用时，可以借助原子更新器处理这种场景。</p>
</blockquote>
<p>Atomic并发包提供了以下三个类：</p>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li>
</ul>
<blockquote>
<p>请注意原子更新器的使用存在比较苛刻的条件如下</p>
<ul>
<li>操作的字段不能是static类型。</li>
<li>操作的字段不能是final类型的，因为final根本没法修改。</li>
<li>字段必须是volatile修饰的，也就是数据本身是读一致的。</li>
<li>属性必须对当前的Updater所在的区域是可见的，如果不是当前类内部进行原子更新器操作不能使用private，protected子类操作父类时修饰符必须是protect权限及以上，如果在同一个package下则必须是default权限及以上，也就是说无论何时都应该保证操作类与被操作类间的可见性。</li>
</ul>
</blockquote>
<h5 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h5><blockquote>
<p>下面看看AtomicIntegerFieldUpdater和AtomicReferenceFieldUpdater的简单使用方式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AtomicIntegerFieldUpdaterDemo &#123;</span><br><span class="line">    public static class Candidate&#123;</span><br><span class="line">        int id;</span><br><span class="line">        volatile int score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Game&#123;</span><br><span class="line">        int id;</span><br><span class="line">        volatile String name;</span><br><span class="line"></span><br><span class="line">        public Game(int id, String name) &#123;</span><br><span class="line">            this.id = id;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;Game&#123;&quot; +</span><br><span class="line">                    &quot;id=&quot; + id +</span><br><span class="line">                    &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                    &#x27;&#125;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static AtomicIntegerFieldUpdater&lt;Candidate&gt; atIntegerUpdater</span><br><span class="line">        = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, &quot;score&quot;);</span><br><span class="line"></span><br><span class="line">    static AtomicReferenceFieldUpdater&lt;Game,String&gt; atRefUpdate =</span><br><span class="line">            AtomicReferenceFieldUpdater.newUpdater(Game.class,String.class,&quot;name&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //用于验证分数是否正确</span><br><span class="line">    public static AtomicInteger allScore=new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Candidate stu=new Candidate();</span><br><span class="line">        Thread[] t=new Thread[10000];</span><br><span class="line">        //开启10000个线程</span><br><span class="line">        for(int i = 0 ; i &lt; 10000 ; i++) &#123;</span><br><span class="line">            t[i]=new Thread() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    if(Math.random()&gt;0.4)&#123;</span><br><span class="line">                        atIntegerUpdater.incrementAndGet(stu);</span><br><span class="line">                        allScore.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0 ; i &lt; 10000 ; i++) &#123;  t[i].join();&#125;</span><br><span class="line">        System.out.println(&quot;最终分数score=&quot;+stu.score);</span><br><span class="line">        System.out.println(&quot;校验分数allScore=&quot;+allScore);</span><br><span class="line"></span><br><span class="line">        //AtomicReferenceFieldUpdater 简单的使用</span><br><span class="line">        Game game = new Game(2,&quot;zh&quot;);</span><br><span class="line">        atRefUpdate.compareAndSet(game,game.name,&quot;JAVA-HHH&quot;);</span><br><span class="line">        System.out.println(game.toString());</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 输出结果:</span><br><span class="line">         * 最终分数score=5976</span><br><span class="line">           校验分数allScore=5976</span><br><span class="line">           Game&#123;id=2, name=&#x27;JAVA-HHH&#x27;&#125;</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 我们使用AtomicIntegerFieldUpdater更新候选人(Candidate)的分数score，开启了10000条线程投票，当随机值大于0.4时算一票，分数自增一次，其中allScore用于验证分数是否正确(其实用于验证AtomicIntegerFieldUpdater更新的字段是否线程安全)，当allScore与score相同时，则说明投票结果无误，也代表AtomicIntegerFieldUpdater能正确更新字段score的值，是线程安全的。对于AtomicReferenceFieldUpdater，我们在代码中简单演示了其使用方式，注意在AtomicReferenceFieldUpdater注明泛型时需要两个泛型参数，一个是修改的类类型，一个修改字段的类型。至于AtomicLongFieldUpdater则与AtomicIntegerFieldUpdater类似，不再介绍。</p>
<h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><blockquote>
<p>接着简单了解一下AtomicIntegerFieldUpdater的实现原理，实际就是反射和Unsafe类结合，AtomicIntegerFieldUpdater是个抽象类，实际实现类为AtomicIntegerFieldUpdaterImpl</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AtomicIntegerFieldUpdater&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass,</span><br><span class="line">                                                              String fieldName) &#123;</span><br><span class="line">         //实际实现类AtomicIntegerFieldUpdaterImpl                                          </span><br><span class="line">        return new AtomicIntegerFieldUpdaterImpl&lt;U&gt;</span><br><span class="line">            (tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看看AtomicIntegerFieldUpdaterImpl</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class AtomicIntegerFieldUpdaterImpl&lt;T&gt;</span><br><span class="line">            extends AtomicIntegerFieldUpdater&lt;T&gt; &#123;</span><br><span class="line">        private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">        private final long offset;//内存偏移量</span><br><span class="line">        private final Class&lt;T&gt; tclass;</span><br><span class="line">        private final Class&lt;?&gt; cclass;</span><br><span class="line"></span><br><span class="line">        AtomicIntegerFieldUpdaterImpl(final Class&lt;T&gt; tclass,</span><br><span class="line">                                      final String fieldName,</span><br><span class="line">                                      final Class&lt;?&gt; caller) &#123;</span><br><span class="line">            final Field field;//要修改的字段</span><br><span class="line">            final int modifiers;//字段修饰符</span><br><span class="line">            try &#123;</span><br><span class="line">                field = AccessController.doPrivileged(</span><br><span class="line">                    new PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line">                        public Field run() throws NoSuchFieldException &#123;</span><br><span class="line">                            return tclass.getDeclaredField(fieldName);//反射获取字段对象</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    //获取字段修饰符</span><br><span class="line">                modifiers = field.getModifiers();</span><br><span class="line">            //对字段的访问权限进行检查,不在访问范围内抛异常</span><br><span class="line">                sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">                    caller, tclass, null, modifiers);</span><br><span class="line">                ClassLoader cl = tclass.getClassLoader();</span><br><span class="line">                ClassLoader ccl = caller.getClassLoader();</span><br><span class="line">                if ((ccl != null) &amp;&amp; (ccl != cl) &amp;&amp;</span><br><span class="line">                    ((cl == null) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line">              sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                throw new RuntimeException(pae.getException());</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                throw new RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; fieldt = field.getType();</span><br><span class="line">            //判断是否为int类型</span><br><span class="line">            if (fieldt != int.class)</span><br><span class="line">                throw new IllegalArgumentException(&quot;Must be integer type&quot;);</span><br><span class="line">            //判断是否被volatile修饰</span><br><span class="line">            if (!Modifier.isVolatile(modifiers))</span><br><span class="line">                throw new IllegalArgumentException(&quot;Must be volatile type&quot;);</span><br><span class="line"></span><br><span class="line">            this.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                           caller != tclass) ? caller : null;</span><br><span class="line">            this.tclass = tclass;</span><br><span class="line">            //获取该字段的在对象内存的偏移量，通过内存偏移量可以获取或者修改该字段的值</span><br><span class="line">            offset = unsafe.objectFieldOffset(field);</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>从AtomicIntegerFieldUpdaterImpl的构造器也可以看出更新器为什么会有这么多限制条件了，当然最终其CAS操作肯定是通过unsafe完成的，简单看一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int incrementAndGet(T obj) &#123;</span><br><span class="line">        int prev, next;</span><br><span class="line">        do &#123;</span><br><span class="line">            prev = get(obj);</span><br><span class="line">            next = prev + 1;</span><br><span class="line">            //CAS操作</span><br><span class="line">        &#125; while (!compareAndSet(obj, prev, next));</span><br><span class="line">        return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最终调用的还是unsafe.compareAndSwapInt()方法</span><br><span class="line">public boolean compareAndSet(T obj, int expect, int update) &#123;</span><br><span class="line">            if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);</span><br><span class="line">            return unsafe.compareAndSwapInt(obj, offset, expect, update);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="再谈自旋锁"><a href="#再谈自旋锁" class="headerlink" title="再谈自旋锁"></a>再谈自旋锁</h3><blockquote>
<p>自旋锁是一种假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这种方式确实也是可以提升效率的。但问题是当线程越来越多竞争很激烈时，占用CPU的时间变长会导致性能急剧下降，因此Java虚拟机内部一般对于自旋锁有一定的次数限制，可能是50或者100次循环后就放弃，直接挂起线程，让出CPU资源。如下通过AtomicReference可实现简单的自旋锁。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpinLock &#123;</span><br><span class="line">  private AtomicReference&lt;Thread&gt; sign =new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void lock()&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    while(!sign .compareAndSet(null, current))&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void unlock ()&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    sign .compareAndSet(current, null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用CAS原子操作作为底层实现，lock()方法将要更新的值设置为当前线程，并将预期值设置为null。unlock()函数将要更新的值设置为null，并预期值设置为当前线程。然后我们通过lock()和unlock来控制自旋锁的开启与关闭，注意这是一种非公平锁。事实上AtomicInteger(或者AtomicLong)原子类内部的CAS操作也是通过不断的自循环(while循环)实现，不过这种循环的结束条件是线程成功更新对于的值，但也是自旋锁的一种。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://andice-cream.github.io/post/534f913.html">https://andice-cream.github.io/post/534f913.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://andice-cream.github.io" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CAS/">CAS</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082055.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/b5b92bc3.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082055.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">多线程概述</div></div></a></div><div class="next-post pull-right"><a href="/post/88d55383.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082110.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">伪共享</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CCAS"><span class="toc-number">1.</span> <span class="toc-text">java原子操作CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">无锁的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAS"><span class="toc-number">1.2.</span> <span class="toc-text">什么是CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E6%8C%87%E4%BB%A4%E5%AF%B9CAS%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">1.3.</span> <span class="toc-text">CPU指令对CAS的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">1.4.</span> <span class="toc-text">悲观锁，乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.4.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">乐观锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">CAS 的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">三大问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">ABA问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AtomicStampedReference"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">AtomicStampedReference</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AtomicMarkableReference"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">AtomicMarkableReference</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%A4%A7"><span class="toc-number">1.6.2.</span> <span class="toc-text">循环时间长开销大</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.3.</span> <span class="toc-text">只能保证一个共享变量的原子操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe%E7%B1%BB"><span class="toc-number">1.7.</span> <span class="toc-text">Unsafe类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.7.1.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%96%B0%E9%80%94%E5%BE%84"><span class="toc-number">1.7.2.</span> <span class="toc-text">提供实例对象新途径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.3.</span> <span class="toc-text">类和实例对象以及变量的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.4.</span> <span class="toc-text">数组操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS-%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3"><span class="toc-number">1.7.5.</span> <span class="toc-text">CAS 操作相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-number">1.7.6.</span> <span class="toc-text">挂起与恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.7.7.</span> <span class="toc-text">内存屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.8.</span> <span class="toc-text">其他操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.</span> <span class="toc-text">原子操作类使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.1.</span> <span class="toc-text">原子更新基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%BC%95%E7%94%A8"><span class="toc-number">1.8.2.</span> <span class="toc-text">原子更新引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.3.</span> <span class="toc-text">原子更新数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">1.8.4.</span> <span class="toc-text">原子更新属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-3"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.9.</span> <span class="toc-text">再谈自旋锁</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>