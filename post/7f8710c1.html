<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>SpringBoot-web | 小肥龙吃大冰淇淋</title><meta name="keywords" content="SpringBoot"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SpringMVC自动配置概览Spring Boot provides auto-configuration for Spring MVC that works well with most applications.(大多场景我们都无需自定义配置) The auto-configuration adds the following features on top of Spring’s defa">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot-web">
<meta property="og:url" content="https://andice-cream.github.io/post/7f8710c1.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="SpringMVC自动配置概览Spring Boot provides auto-configuration for Spring MVC that works well with most applications.(大多场景我们都无需自定义配置) The auto-configuration adds the following features on top of Spring’s defa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg">
<meta property="article:published_time" content="2021-08-07T07:46:00.000Z">
<meta property="article:modified_time" content="2022-11-27T09:16:40.936Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://andice-cream.github.io/post/7f8710c1"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SpringBoot-web',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">178</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringBoot-web</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-07T07:46:00.000Z" title="发表于 2021-08-07 15:46:00">2021-08-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:40.936Z" title="更新于 2022-11-27 17:16:40">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SpringBoot-web"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="SpringMVC自动配置概览"><a href="#SpringMVC自动配置概览" class="headerlink" title="SpringMVC自动配置概览"></a>SpringMVC自动配置概览</h1><p>Spring Boot provides auto-configuration for Spring MVC that <strong>works well with most applications.(大多场景我们都无需自定义配置)</strong></p>
<p>The auto-configuration adds the following features on top of Spring’s defaults:</p>
<ul>
<li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p>
</li>
<li><p>内容协商视图解析器和BeanName视图解析器</p>
</li>
<li><p>Support for serving static resources, including support for WebJars (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content">later in this document</a>)).</p>
</li>
<li><p>静态资源（包括webjars）</p>
</li>
<li><p>Automatic registration of <code>Converter</code>, <code>GenericConverter</code>, and <code>Formatter</code> beans.</p>
</li>
<li><p>自动注册 <code>Converter，GenericConverter，Formatter </code></p>
</li>
<li><p>Support for <code>HttpMessageConverters</code> (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-message-converters">later in this document</a>).</p>
</li>
<li><p>支持 <code>HttpMessageConverters</code> （后来我们配合内容协商理解原理）</p>
</li>
<li><p>Automatic registration of <code>MessageCodesResolver</code> (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-message-codes">later in this document</a>).</p>
</li>
<li><p>自动注册 <code>MessageCodesResolver</code> （国际化用）</p>
</li>
<li><p>Static <code>index.html</code> support.</p>
</li>
<li><p>静态index.html 页支持</p>
</li>
<li><p>Custom <code>Favicon</code> support (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-favicon">later in this document</a>).</p>
</li>
<li><p>自定义 <code>Favicon</code>  </p>
</li>
<li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-web-binding-initializer">later in this document</a>).</p>
</li>
<li><p>自动使用 <code>ConfigurableWebBindingInitializer</code> ，（DataBinder负责将请求数据绑定到JavaBean上）</p>
</li>
</ul>
<p>If you want to keep those Spring Boot MVC customizations and make more <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/web.html#mvc">MVC customizations</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>.</p>
<p><strong>不用@EnableWebMvc注解。使用</strong> <code>**@Configuration**</code> <strong>+</strong> <code>**WebMvcConfigurer**</code> <strong>自定义规则</strong></p>
<p>If you want to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, and still keep the Spring Boot MVC customizations, you can declare a bean of type <code>WebMvcRegistrations</code> and use it to provide custom instances of those components.</p>
<p><strong>声明</strong> <code>**WebMvcRegistrations**</code> <strong>改变默认底层组件</strong></p>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>, or alternatively add your own <code>@Configuration</code>-annotated <code>DelegatingWebMvcConfiguration</code> as described in the Javadoc of <code>@EnableWebMvc</code>.</p>
<p><strong>使用</strong> <code>**@EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC**</code></p>
<h1 id="简单功能分析"><a href="#简单功能分析" class="headerlink" title="简单功能分析"></a>简单功能分析</h1><h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><h3 id="静态资源目录"><a href="#静态资源目录" class="headerlink" title="静态资源目录"></a>静态资源目录</h3><p>只要静态资源放在类路径下： called <code>/static</code> (or <code>/public</code> or <code>/resources</code> or <code>/META-INF/resources</code></p>
<p>访问 ： 当前项目根路径/ + 静态资源名 </p>
<p>原理： 静态映射/**。</p>
<p>请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面</p>
<p>改变默认的静态资源路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">    static-path-pattern: /res/**</span><br><span class="line"></span><br><span class="line">  resources:</span><br><span class="line">    static-locations: [classpath:/haha/]</span><br></pre></td></tr></table></figure>

<h3 id="静态资源访问前缀"><a href="#静态资源访问前缀" class="headerlink" title="静态资源访问前缀"></a>静态资源访问前缀</h3><p>默认无前缀</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">    static-path-pattern: /res/**</span><br></pre></td></tr></table></figure>

<p>当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找</p>
<h3 id="webjar"><a href="#webjar" class="headerlink" title="webjar"></a>webjar</h3><p>自动映射 /<a target="_blank" rel="noopener" href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js">webjars</a>/**</p>
<p><a target="_blank" rel="noopener" href="https://www.webjars.org/">https://www.webjars.org/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.webjars&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jquery&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>访问地址：<a target="_blank" rel="noopener" href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js">http://localhost:8080/webjars/<strong>jquery/3.5.1/jquery.js</strong></a>   后面地址要按照依赖里面的包路径</p>
<h2 id="欢迎页支持"><a href="#欢迎页支持" class="headerlink" title="欢迎页支持"></a>欢迎页支持</h2><ul>
<li><p>静态资源路径下  index.html</p>
</li>
<li><p>可以配置静态资源路径</p>
</li>
<li><p>但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">#  mvc:</span><br><span class="line">#    static-path-pattern: /res/**   这个会导致welcome page功能失效</span><br><span class="line"></span><br><span class="line">  resources:</span><br><span class="line">    static-locations: [classpath:/haha/]</span><br></pre></td></tr></table></figure>

<ul>
<li>controller能处理/index</li>
</ul>
<h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p><code>Favicon</code></p>
<p>favicon.ico 放在静态资源目录下即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">#  mvc:</span><br><span class="line">#    static-path-pattern: /res/**   这个会导致 Favicon 功能失效</span><br></pre></td></tr></table></figure>

<h2 id="2-4、静态资源配置原理"><a href="#2-4、静态资源配置原理" class="headerlink" title="2.4、静态资源配置原理"></a>2.4、静态资源配置原理</h2><ul>
<li>SpringBoot启动默认加载  xxxAutoConfiguration 类（自动配置类）</li>
<li>SpringMVC功能的自动配置类 WebMvcAutoConfiguration，生效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="line">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span><br><span class="line">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br><span class="line">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span><br><span class="line">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="line">		ValidationAutoConfiguration.class &#125;)</span><br><span class="line">public class WebMvcAutoConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>给容器中配了什么。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@Import(EnableWebMvcConfiguration.class)</span><br><span class="line">@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)</span><br><span class="line">@Order(0)</span><br><span class="line">public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件的相关属性和xxx进行了绑定。WebMvcProperties==<strong>spring.mvc</strong>、ResourceProperties==<strong>spring.resources</strong></li>
</ul>
<h4 id="配置类只有一个有参构造器"><a href="#配置类只有一个有参构造器" class="headerlink" title="配置类只有一个有参构造器"></a>配置类只有一个有参构造器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	//有参构造器所有参数的值都会从容器中确定</span><br><span class="line">//ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象</span><br><span class="line">//WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象</span><br><span class="line">//ListableBeanFactory beanFactory Spring的beanFactory</span><br><span class="line">//HttpMessageConverters 找到所有的HttpMessageConverters</span><br><span class="line">//ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。=========</span><br><span class="line">//DispatcherServletPath  </span><br><span class="line">//ServletRegistrationBean   给应用注册Servlet、Filter....</span><br><span class="line">	public WebMvcAutoConfigurationAdapter(ResourceProperties resourceProperties, WebMvcProperties mvcProperties,</span><br><span class="line">				ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,</span><br><span class="line">				ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider,</span><br><span class="line">				ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath,</span><br><span class="line">				ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations) &#123;</span><br><span class="line">			this.resourceProperties = resourceProperties;</span><br><span class="line">			this.mvcProperties = mvcProperties;</span><br><span class="line">			this.beanFactory = beanFactory;</span><br><span class="line">			this.messageConvertersProvider = messageConvertersProvider;</span><br><span class="line">			this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();</span><br><span class="line">			this.dispatcherServletPath = dispatcherServletPath;</span><br><span class="line">			this.servletRegistrations = servletRegistrations;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="资源处理的默认规则"><a href="#资源处理的默认规则" class="headerlink" title="资源处理的默认规则"></a>资源处理的默认规则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">		public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">			if (!this.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">				logger.debug(&quot;Default resource handling disabled&quot;);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			Duration cachePeriod = this.resourceProperties.getCache().getPeriod();</span><br><span class="line">			CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">			//webjars的规则</span><br><span class="line">            if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123;</span><br><span class="line">				customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">						.addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)</span><br><span class="line">						.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">            //</span><br><span class="line">			String staticPathPattern = this.mvcProperties.getStaticPathPattern();</span><br><span class="line">			if (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">				customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">						.addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))</span><br><span class="line">						.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">spring:</span><br><span class="line">#  mvc:</span><br><span class="line">#    static-path-pattern: /res/**</span><br><span class="line"></span><br><span class="line">  resources:</span><br><span class="line">    add-mappings: false   禁用所有静态资源规则</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)</span><br><span class="line">public class ResourceProperties &#123;</span><br><span class="line"></span><br><span class="line">	private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;,</span><br><span class="line">			&quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Locations of static resources. Defaults to classpath:[/META-INF/resources/,</span><br><span class="line">	 * /resources/, /static/, /public/].</span><br><span class="line">	 */</span><br><span class="line">	private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br></pre></td></tr></table></figure>

<h4 id="欢迎页的处理规则"><a href="#欢迎页的处理规则" class="headerlink" title="欢迎页的处理规则"></a>欢迎页的处理规则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HandlerMapping：处理器映射。保存了每一个Handler能处理哪些请求。	</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">	public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,</span><br><span class="line">			FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123;</span><br><span class="line">		WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(</span><br><span class="line">				new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),</span><br><span class="line">				this.mvcProperties.getStaticPathPattern());</span><br><span class="line">		welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));</span><br><span class="line">		welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line">		return welcomePageHandlerMapping;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,</span><br><span class="line">		ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123;</span><br><span class="line">	if (welcomePage.isPresent() &amp;&amp; &quot;/**&quot;.equals(staticPathPattern)) &#123;</span><br><span class="line">           //要用欢迎页功能，必须是/**</span><br><span class="line">		logger.info(&quot;Adding welcome page: &quot; + welcomePage.get());</span><br><span class="line">		setRootViewName(&quot;forward:index.html&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;</span><br><span class="line">           // 调用Controller  /index</span><br><span class="line">		logger.info(&quot;Adding welcome page template: index&quot;);</span><br><span class="line">		setRootViewName(&quot;index&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="favicon"><a href="#favicon" class="headerlink" title="favicon"></a>favicon</h4><h1 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h1><h2 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h2><h3 id="rest使用与原理"><a href="#rest使用与原理" class="headerlink" title="rest使用与原理"></a>rest使用与原理</h3><ul>
<li><p>@xxxMapping；</p>
</li>
<li><p>Rest风格支持（<em>使用<strong>HTTP</strong>请求方式动词来表示对资源的操作</em>）</p>
</li>
<li><p><em>以前：</em><em>/getUser</em>  <em>获取用户</em>    <em>/deleteUser</em> <em>删除用户</em>   <em>/editUser</em>  <em>修改用户</em>      <em>/saveUser</em> <em>保存用户</em></p>
</li>
<li><p><em>现在： /user</em>    *GET-*<em>获取用户</em>    *DELETE-*<em>删除用户</em>     *PUT-*<em>修改用户</em>      *POST-*<em>保存用户</em></p>
</li>
<li><p>核心Filter；HiddenHttpMethodFilter</p>
</li>
<li><p>用法： 表单method=post，隐藏域 _method=put</p>
</li>
<li><p>SpringBoot中手动开启</p>
</li>
<li><p>扩展：如何把_method 这个名字换成我们自己喜欢的。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span><br><span class="line">    public String getUser()&#123;</span><br><span class="line">        return &quot;GET-张三&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)</span><br><span class="line">    public String saveUser()&#123;</span><br><span class="line">        return &quot;POST-张三&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)</span><br><span class="line">    public String putUser()&#123;</span><br><span class="line">        return &quot;PUT-张三&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)</span><br><span class="line">    public String deleteUser()&#123;</span><br><span class="line">        return &quot;DELETE-张三&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</span><br><span class="line">	@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false)</span><br><span class="line">	public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123;</span><br><span class="line">		return new OrderedHiddenHttpMethodFilter();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//自定义filter</span><br><span class="line">    @Bean</span><br><span class="line">    public HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123;</span><br><span class="line">        HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter();</span><br><span class="line">        methodFilter.setMethodParam(&quot;_m&quot;);</span><br><span class="line">        return methodFilter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Rest原理（表单提交要使用REST的时候）</p>
<ul>
<li><p>表单提交会带上**_method=PUT**</p>
</li>
<li><p><strong>请求过来被</strong>HiddenHttpMethodFilter拦截</p>
</li>
<li><p>请求是否正常，并且是POST</p>
</li>
<li><p>获取到**_method**的值。</p>
</li>
<li><p>兼容以下请求；<strong>PUT</strong>.<strong>DELETE</strong>.<strong>PATCH</strong></p>
</li>
<li><p><strong>原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。</strong></p>
</li>
<li><p><strong>过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用****requesWrapper的。</strong></p>
</li>
</ul>
<p><strong>Rest使用客户端工具，</strong></p>
<ul>
<li>如PostMan直接发送Put、delete等方式请求，无需Filter。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">    hiddenmethod:</span><br><span class="line">      filter:</span><br><span class="line">        enabled: true   #开启页面表单的Rest功能</span><br></pre></td></tr></table></figure>

<h3 id="请求映射原理"><a href="#请求映射原理" class="headerlink" title="请求映射原理"></a>请求映射原理</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085302.png" alt="image.png"></p>
<p>SpringMVC功能分析都从 org.springframework.web.servlet.DispatcherServlet-》doDispatch（）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		HttpServletRequest processedRequest = request;</span><br><span class="line">		HandlerExecutionChain mappedHandler = null;</span><br><span class="line">		boolean multipartRequestParsed = false;</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			ModelAndView mv = null;</span><br><span class="line">			Exception dispatchException = null;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				processedRequest = checkMultipart(request);</span><br><span class="line">				multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">				// 找到当前请求使用哪个Handler（Controller的方法）处理</span><br><span class="line">				mappedHandler = getHandler(processedRequest);</span><br><span class="line">                </span><br><span class="line">                //HandlerMapping：处理器映射。/xxx-&gt;&gt;xxxx</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085318.png" alt="image.png"></p>
<p><strong>RequestMappingHandlerMapping</strong>：保存了所有@RequestMapping 和handler的映射规则。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085338.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></p>
<p>所有的请求映射都在HandlerMapping中。</p>
<ul>
<li><p>SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 /能访问到index.html；</p>
</li>
<li><p>SpringBoot自动配置了默认 的 RequestMappingHandlerMapping</p>
</li>
<li><p>请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。</p>
</li>
<li><p>如果有就找到这个请求对应的handler</p>
</li>
<li><p>如果没有就是下一个 HandlerMapping</p>
</li>
<li><p>我们需要一些自定义的映射处理，我们也可以自己给容器中放<strong>HandlerMapping</strong>。自定义 <strong>HandlerMapping</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	if (this.handlerMappings != null) &#123;</span><br><span class="line">		for (HandlerMapping mapping : this.handlerMappings) &#123;</span><br><span class="line">			HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">			if (handler != null) &#123;</span><br><span class="line">				return handler;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="普通参数与基本注解"><a href="#普通参数与基本注解" class="headerlink" title="普通参数与基本注解"></a>普通参数与基本注解</h2><h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><p>@PathVariable、@RequestHeader、@ModelAttribute、@RequestParam、@MatrixVariable、@CookieValue、@RequestBody</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ParameterTestController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //  car/2/owner/zhangsan</span><br><span class="line">    @GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span><br><span class="line">    public Map&lt;String,Object&gt; getCar(@PathVariable(&quot;id&quot;) Integer id,</span><br><span class="line">                                     @PathVariable(&quot;username&quot;) String name,</span><br><span class="line">                                     @PathVariable Map&lt;String,String&gt; pv,</span><br><span class="line">                                     @RequestHeader(&quot;User-Agent&quot;) String userAgent,</span><br><span class="line">                                     @RequestHeader Map&lt;String,String&gt; header,</span><br><span class="line">                                     @RequestParam(&quot;age&quot;) Integer age,</span><br><span class="line">                                     @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters,</span><br><span class="line">                                     @RequestParam Map&lt;String,String&gt; params,</span><br><span class="line">                                     @CookieValue(&quot;_ga&quot;) String _ga,</span><br><span class="line">                                     @CookieValue(&quot;_ga&quot;) Cookie cookie)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">//        map.put(&quot;id&quot;,id);</span><br><span class="line">//        map.put(&quot;name&quot;,name);</span><br><span class="line">//        map.put(&quot;pv&quot;,pv);</span><br><span class="line">//        map.put(&quot;userAgent&quot;,userAgent);</span><br><span class="line">//        map.put(&quot;headers&quot;,header);</span><br><span class="line">        map.put(&quot;age&quot;,age);</span><br><span class="line">        map.put(&quot;inters&quot;,inters);</span><br><span class="line">        map.put(&quot;params&quot;,params);</span><br><span class="line">        map.put(&quot;_ga&quot;,_ga);</span><br><span class="line">        System.out.println(cookie.getName()+&quot;===&gt;&quot;+cookie.getValue());</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/save&quot;)</span><br><span class="line">    public Map postMethod(@RequestBody String content)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;content&quot;,content);</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd</span><br><span class="line">    //2、SpringBoot默认是禁用了矩阵变量的功能</span><br><span class="line">    //      手动开启：原理。对于路径的处理。UrlPathHelper进行解析。</span><br><span class="line">    //              removeSemicolonContent（移除分号内容）支持矩阵变量的</span><br><span class="line">    //3、矩阵变量必须有url路径变量才能被解析</span><br><span class="line">    @GetMapping(&quot;/cars/&#123;path&#125;&quot;)</span><br><span class="line">    public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low,</span><br><span class="line">                        @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand,</span><br><span class="line">                        @PathVariable(&quot;path&quot;) String path)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(&quot;low&quot;,low);</span><br><span class="line">        map.put(&quot;brand&quot;,brand);</span><br><span class="line">        map.put(&quot;path&quot;,path);</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // /boss/1;age=20/2;age=10</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;)</span><br><span class="line">    public Map boss(@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;) Integer bossAge,</span><br><span class="line">                    @MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;) Integer empAge)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(&quot;bossAge&quot;,bossAge);</span><br><span class="line">        map.put(&quot;empAge&quot;,empAge);</span><br><span class="line">        return map;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Servlet-API："><a href="#Servlet-API：" class="headerlink" title="Servlet API："></a>Servlet API：</h3><p>WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId</p>
<p><strong>ServletRequestMethodArgumentResolver  以上的部分参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">		Class&lt;?&gt; paramType = parameter.getParameterType();</span><br><span class="line">		return (WebRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">				ServletRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">				MultipartRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">				HttpSession.class.isAssignableFrom(paramType) ||</span><br><span class="line">				(pushBuilder != null &amp;&amp; pushBuilder.isAssignableFrom(paramType)) ||</span><br><span class="line">				Principal.class.isAssignableFrom(paramType) ||</span><br><span class="line">				InputStream.class.isAssignableFrom(paramType) ||</span><br><span class="line">				Reader.class.isAssignableFrom(paramType) ||</span><br><span class="line">				HttpMethod.class == paramType ||</span><br><span class="line">				Locale.class == paramType ||</span><br><span class="line">				TimeZone.class == paramType ||</span><br><span class="line">				ZoneId.class == paramType);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂参数："><a href="#复杂参数：" class="headerlink" title="复杂参数："></a>复杂参数：</h3><p><strong>Map</strong>、<strong>Model（map、model里面的数据会被放在request的请求域  request.setAttribute）、</strong>Errors/BindingResult、<strong>RedirectAttributes（ 重定向携带数据）</strong>、<strong>ServletResponse（response）</strong>、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Object&gt; map,  Model model, HttpServletRequest request 都是可以给request域中放数据，</span><br><span class="line">request.getAttribute();</span><br></pre></td></tr></table></figure>

<p><strong>Map、Model类型的参数</strong>，会返回 mavContainer.getModel（）；—&gt; BindingAwareModelMap 是Model 也是Map</p>
<p><strong>mavContainer</strong>.getModel(); 获取到值的</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085421.png" alt="image.png"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085431.png" alt="image.png"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085403.png" alt="img"></p>
<h3 id="自定义对象参数："><a href="#自定义对象参数：" class="headerlink" title="自定义对象参数："></a>自定义对象参数：</h3><p>可以自动类型转换与格式化，可以级联封装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *     姓名： &lt;input name=&quot;userName&quot;/&gt; &lt;br/&gt;</span><br><span class="line"> *     年龄： &lt;input name=&quot;age&quot;/&gt; &lt;br/&gt;</span><br><span class="line"> *     生日： &lt;input name=&quot;birth&quot;/&gt; &lt;br/&gt;</span><br><span class="line"> *     宠物姓名：&lt;input name=&quot;pet.name&quot;/&gt;&lt;br/&gt;</span><br><span class="line"> *     宠物年龄：&lt;input name=&quot;pet.age&quot;/&gt;</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Person &#123;</span><br><span class="line">    </span><br><span class="line">    private String userName;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Date birth;</span><br><span class="line">    private Pet pet;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Pet &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result</span><br></pre></td></tr></table></figure>

<h2 id="POJO封装过程"><a href="#POJO封装过程" class="headerlink" title="POJO封装过程"></a>POJO封装过程</h2><ul>
<li><strong>ServletModelAttributeMethodProcessor</strong></li>
</ul>
<h2 id="参数处理原理"><a href="#参数处理原理" class="headerlink" title="参数处理原理"></a>参数处理原理</h2><ul>
<li><p>HandlerMapping中找到能处理请求的Handler（Controller.method()）</p>
</li>
<li><p>为当前Handler 找一个适配器 HandlerAdapter； <strong>RequestMappingHandlerAdapter</strong></p>
</li>
<li><p>适配器执行目标方法并确定方法参数的每一个值</p>
</li>
</ul>
<h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085510.png" alt="img"></p>
<p>0 - 支持方法上标注@RequestMapping </p>
<p>1 - 支持函数式编程的</p>
<p>xxxxxx</p>
<h3 id="执行目标方法"><a href="#执行目标方法" class="headerlink" title="执行目标方法"></a>执行目标方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Actually invoke the handler.</span><br><span class="line">//DispatcherServlet -- doDispatch</span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod); //执行目标方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//ServletInvocableHandlerMethod</span><br><span class="line">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">//获取方法的参数值</span><br><span class="line">Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br></pre></td></tr></table></figure>

<h3 id="参数解析器-HandlerMethodArgumentResolver"><a href="#参数解析器-HandlerMethodArgumentResolver" class="headerlink" title="参数解析器-HandlerMethodArgumentResolver"></a>参数解析器-HandlerMethodArgumentResolver</h3><p>确定将要执行的目标方法的每一个参数的值是什么;</p>
<p>SpringMVC目标方法能写多少种参数类型。取决于参数解析器。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085515.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085523.png" alt="img"></p>
<ul>
<li>当前解析器是否支持解析这种参数</li>
<li>支持就调用 resolveArgument</li>
</ul>
<h3 id="返回值处理器"><a href="#返回值处理器" class="headerlink" title="返回值处理器"></a>返回值处理器</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085527.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<h3 id="如何确定目标方法每一个参数的值"><a href="#如何确定目标方法每一个参数的值" class="headerlink" title="如何确定目标方法每一个参数的值"></a>如何确定目标方法每一个参数的值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">============InvocableHandlerMethod==========================</span><br><span class="line">protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,</span><br><span class="line">			Object... providedArgs) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">		if (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line">			return EMPTY_ARGS;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object[] args = new Object[parameters.length];</span><br><span class="line">		for (int i = 0; i &lt; parameters.length; i++) &#123;</span><br><span class="line">			MethodParameter parameter = parameters[i];</span><br><span class="line">			parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);</span><br><span class="line">			args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">			if (args[i] != null) &#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			if (!this.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">				throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Exception ex) &#123;</span><br><span class="line">				// Leave stack trace for later, exception may actually be resolved and handled...</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					String exMsg = ex.getMessage();</span><br><span class="line">					if (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">						logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return args;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="挨个判断所有参数解析器那个支持解析这个参数"><a href="#挨个判断所有参数解析器那个支持解析这个参数" class="headerlink" title="挨个判断所有参数解析器那个支持解析这个参数"></a>挨个判断所有参数解析器那个支持解析这个参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123;</span><br><span class="line">	HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);</span><br><span class="line">	if (result == null) &#123;</span><br><span class="line">		for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) &#123;</span><br><span class="line">			if (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">				result = resolver;</span><br><span class="line">				this.argumentResolverCache.put(parameter, result);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解析这个参数的值"><a href="#解析这个参数的值" class="headerlink" title="解析这个参数的值"></a>解析这个参数的值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用各自 HandlerMethodArgumentResolver 的 resolveArgument 方法即可</span><br></pre></td></tr></table></figure>

<h4 id="自定义类型参数-封装POJO"><a href="#自定义类型参数-封装POJO" class="headerlink" title="自定义类型参数 封装POJO"></a>自定义类型参数 封装POJO</h4><p><strong>ServletModelAttributeMethodProcessor  这个参数处理器支持</strong></p>
<p> <strong>是否为简单类型。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean isSimpleValueType(Class&lt;?&gt; type) &#123;</span><br><span class="line">		return (Void.class != type &amp;&amp; void.class != type &amp;&amp;</span><br><span class="line">				(ClassUtils.isPrimitiveOrWrapper(type) ||</span><br><span class="line">				Enum.class.isAssignableFrom(type) ||</span><br><span class="line">				CharSequence.class.isAssignableFrom(type) ||</span><br><span class="line">				Number.class.isAssignableFrom(type) ||</span><br><span class="line">				Date.class.isAssignableFrom(type) ||</span><br><span class="line">				Temporal.class.isAssignableFrom(type) ||</span><br><span class="line">				URI.class == type ||</span><br><span class="line">				URL.class == type ||</span><br><span class="line">				Locale.class == type ||</span><br><span class="line">				Class.class == type));</span><br><span class="line">	&#125;</span><br><span class="line">@Override</span><br><span class="line">	@Nullable</span><br><span class="line">	public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span><br><span class="line">			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		Assert.state(mavContainer != null, &quot;ModelAttributeMethodProcessor requires ModelAndViewContainer&quot;);</span><br><span class="line">		Assert.state(binderFactory != null, &quot;ModelAttributeMethodProcessor requires WebDataBinderFactory&quot;);</span><br><span class="line"></span><br><span class="line">		String name = ModelFactory.getNameForParameter(parameter);</span><br><span class="line">		ModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class);</span><br><span class="line">		if (ann != null) &#123;</span><br><span class="line">			mavContainer.setBinding(name, ann.binding());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object attribute = null;</span><br><span class="line">		BindingResult bindingResult = null;</span><br><span class="line"></span><br><span class="line">		if (mavContainer.containsAttribute(name)) &#123;</span><br><span class="line">			attribute = mavContainer.getModel().get(name);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// Create attribute instance</span><br><span class="line">			try &#123;</span><br><span class="line">				attribute = createAttribute(name, parameter, binderFactory, webRequest);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (BindException ex) &#123;</span><br><span class="line">				if (isBindExceptionRequired(parameter)) &#123;</span><br><span class="line">					// No BindingResult parameter -&gt; fail with BindException</span><br><span class="line">					throw ex;</span><br><span class="line">				&#125;</span><br><span class="line">				// Otherwise, expose null/empty value and associated BindingResult</span><br><span class="line">				if (parameter.getParameterType() == Optional.class) &#123;</span><br><span class="line">					attribute = Optional.empty();</span><br><span class="line">				&#125;</span><br><span class="line">				bindingResult = ex.getBindingResult();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (bindingResult == null) &#123;</span><br><span class="line">			// Bean property binding and validation;</span><br><span class="line">			// skipped in case of binding failure on construction.</span><br><span class="line">			WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);</span><br><span class="line">			if (binder.getTarget() != null) &#123;</span><br><span class="line">				if (!mavContainer.isBindingDisabled(name)) &#123;</span><br><span class="line">					bindRequestParameters(binder, webRequest);</span><br><span class="line">				&#125;</span><br><span class="line">				validateIfApplicable(binder, parameter);</span><br><span class="line">				if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">					throw new BindException(binder.getBindingResult());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// Value type adaptation, also covering java.util.Optional</span><br><span class="line">			if (!parameter.getParameterType().isInstance(attribute)) &#123;</span><br><span class="line">				attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</span><br><span class="line">			&#125;</span><br><span class="line">			bindingResult = binder.getBindingResult();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Add resolved attribute and BindingResult at the end of the model</span><br><span class="line">		Map&lt;String, Object&gt; bindingResultModel = bindingResult.getModel();</span><br><span class="line">		mavContainer.removeAttributes(bindingResultModel);</span><br><span class="line">		mavContainer.addAllAttributes(bindingResultModel);</span><br><span class="line"></span><br><span class="line">		return attribute;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><strong>WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);</strong></p>
<p><strong>WebDataBinder :web数据绑定器，将请求参数的值绑定到指定的JavaBean里面</strong></p>
<p><strong>WebDataBinder 利用它里面的 Converters 将请求数据转成指定的数据类型。再次封装到JavaBean中</strong></p>
<p><strong>GenericConversionService：在设置每一个值的时候，找它里面的所有converter那个可以将这个数据类型（request带来参数的字符串）转换到指定的类型（JavaBean – Integer）</strong></p>
<p><strong>byte – &gt; file</strong></p>
<p>@FunctionalInterface<strong>public interface</strong> Converter&lt;S, T&gt;</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085538.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085632.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<p>未来我们可以给WebDataBinder里面放自己的Converter；</p>
<p><strong>private static final class</strong> StringToNumber&lt;T **extends** Number&gt; <strong>implements</strong> Converter&lt;String, T&gt;</p>
<p>自定义 Converter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1、WebMvcConfigurer定制化SpringMVC的功能</span><br><span class="line">@Bean</span><br><span class="line">public WebMvcConfigurer webMvcConfigurer()&#123;</span><br><span class="line">    return new WebMvcConfigurer() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void configurePathMatch(PathMatchConfigurer configurer) &#123;</span><br><span class="line">            UrlPathHelper urlPathHelper = new UrlPathHelper();</span><br><span class="line">            // 不移除；后面的内容。矩阵变量功能就可以生效</span><br><span class="line">            urlPathHelper.setRemoveSemicolonContent(false);</span><br><span class="line">            configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">            registry.addConverter(new Converter&lt;String, Pet&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public Pet convert(String source) &#123;</span><br><span class="line">                    // 啊猫,3</span><br><span class="line">                    if(!StringUtils.isEmpty(source))&#123;</span><br><span class="line">                        Pet pet = new Pet();</span><br><span class="line">                        String[] split = source.split(&quot;,&quot;);</span><br><span class="line">                        pet.setName(split[0]);</span><br><span class="line">                        pet.setAge(Integer.parseInt(split[1]));</span><br><span class="line">                        return pet;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="目标方法执行完成"><a href="#目标方法执行完成" class="headerlink" title="目标方法执行完成"></a>目标方法执行完成</h3><p>将所有的数据都放在 <strong>ModelAndViewContainer</strong>；包含要去的页面地址View。还包含Model数据。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085644.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<h3 id="处理派发结果"><a href="#处理派发结果" class="headerlink" title="处理派发结果"></a>处理派发结果</h3><p><strong>processDispatchResult</strong>(processedRequest, response, mappedHandler, mv, dispatchException);</p>
<p>renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InternalResourceView：</span><br><span class="line">@Override</span><br><span class="line">	protected void renderMergedOutputModel(</span><br><span class="line">			Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		// Expose the model object as request attributes.</span><br><span class="line">		exposeModelAsRequestAttributes(model, request);</span><br><span class="line"></span><br><span class="line">		// Expose helpers as request attributes, if any.</span><br><span class="line">		exposeHelpers(request);</span><br><span class="line"></span><br><span class="line">		// Determine the path for the request dispatcher.</span><br><span class="line">		String dispatcherPath = prepareForRendering(request, response);</span><br><span class="line"></span><br><span class="line">		// Obtain a RequestDispatcher for the target resource (typically a JSP).</span><br><span class="line">		RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);</span><br><span class="line">		if (rd == null) &#123;</span><br><span class="line">			throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +</span><br><span class="line">					&quot;]: Check that the corresponding file exists within your web application archive!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// If already included or response already committed, perform include, else forward.</span><br><span class="line">		if (useInclude(request, response)) &#123;</span><br><span class="line">			response.setContentType(getContentType());</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Including [&quot; + getUrl() + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			rd.include(request, response);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		else &#123;</span><br><span class="line">			// Note: The forwarded resource is supposed to determine the content type itself.</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Forwarding to [&quot; + getUrl() + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			rd.forward(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">暴露模型作为请求域属性</span><br><span class="line">// Expose the model object as request attributes.</span><br><span class="line">		exposeModelAsRequestAttributes(model, request);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void exposeModelAsRequestAttributes(Map&lt;String, Object&gt; model,</span><br><span class="line">			HttpServletRequest request) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    //model中的所有数据遍历挨个放在请求域中</span><br><span class="line">		model.forEach((name, value) -&gt; &#123;</span><br><span class="line">			if (value != null) &#123;</span><br><span class="line">				request.setAttribute(name, value);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				request.removeAttribute(name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h1 id="数据响应与内容协商"><a href="#数据响应与内容协商" class="headerlink" title="数据响应与内容协商"></a>数据响应与内容协商</h1><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085701.png" alt="img"></p>
<h2 id="响应JSON"><a href="#响应JSON" class="headerlink" title="响应JSON"></a>响应JSON</h2><h3 id="jackson-jar-ResponseBody"><a href="#jackson-jar-ResponseBody" class="headerlink" title="jackson.jar+@ResponseBody"></a>jackson.jar+@ResponseBody</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">web场景自动引入了json场景</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085707.png" alt="img"></h3><p>给前端自动返回json数据；</p>
<h4 id="返回值解析器"><a href="#返回值解析器" class="headerlink" title="返回值解析器"></a>返回值解析器</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085718.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">			this.returnValueHandlers.handleReturnValue(</span><br><span class="line">					returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">		&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,</span><br><span class="line">			ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);</span><br><span class="line">		if (handler == null) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());</span><br><span class="line">		&#125;</span><br><span class="line">		handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">RequestResponseBodyMethodProcessor  	</span><br><span class="line">@Override</span><br><span class="line">	public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,</span><br><span class="line">			ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span><br><span class="line">			throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;</span><br><span class="line"></span><br><span class="line">		mavContainer.setRequestHandled(true);</span><br><span class="line">		ServletServerHttpRequest inputMessage = createInputMessage(webRequest);</span><br><span class="line">		ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);</span><br><span class="line"></span><br><span class="line">		// Try even with null return value. ResponseBodyAdvice could get involved.</span><br><span class="line">        // 使用消息转换器进行写出操作</span><br><span class="line">		writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="返回值解析器原理"><a href="#返回值解析器原理" class="headerlink" title="返回值解析器原理"></a>返回值解析器原理</h4><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085726.png" alt="img"></h3><ul>
<li><p>1、返回值处理器判断是否支持这种类型返回值 supportsReturnType</p>
</li>
<li><p>2、返回值处理器调用 handleReturnValue 进行处理</p>
</li>
<li><p>3、RequestResponseBodyMethodProcessor 可以处理返回值标了@ResponseBody 注解的。</p>
</li>
<li><p>\1.  利用 MessageConverters 进行处理 将数据写为json</p>
</li>
<li><p>1、内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型）</p>
</li>
<li><p>2、服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据，</p>
</li>
<li><p>3、SpringMVC会挨个遍历所有容器底层的 HttpMessageConverter ，看谁能处理？</p>
</li>
<li><p>1、得到MappingJackson2HttpMessageConverter可以将对象写为json</p>
</li>
<li><p>2、利用MappingJackson2HttpMessageConverter将对象转为json再写出去。</p>
</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085743.png" alt="img"></p>
<h3 id="SpringMVC到底支持哪些返回值"><a href="#SpringMVC到底支持哪些返回值" class="headerlink" title="SpringMVC到底支持哪些返回值"></a>SpringMVC到底支持哪些返回值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModelAndView</span><br><span class="line">Model</span><br><span class="line">View</span><br><span class="line">ResponseEntity </span><br><span class="line">ResponseBodyEmitter</span><br><span class="line">StreamingResponseBody</span><br><span class="line">HttpEntity</span><br><span class="line">HttpHeaders</span><br><span class="line">Callable</span><br><span class="line">DeferredResult</span><br><span class="line">ListenableFuture</span><br><span class="line">CompletionStage</span><br><span class="line">WebAsyncTask</span><br><span class="line">有 @ModelAttribute 且为对象类型的</span><br><span class="line">@ResponseBody 注解 ---&gt; RequestResponseBodyMethodProcessor；</span><br></pre></td></tr></table></figure>

<h3 id="HTTPMessageConverter原理"><a href="#HTTPMessageConverter原理" class="headerlink" title="HTTPMessageConverter原理"></a>HTTPMessageConverter原理</h3><h4 id="MessageConverter规范"><a href="#MessageConverter规范" class="headerlink" title="MessageConverter规范"></a>MessageConverter规范</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085748.png" alt="img"></p>
<p>HttpMessageConverter: 看是否支持将 此 Class类型的对象，转为MediaType类型的数据。</p>
<p>例子：Person对象转为JSON。或者 JSON转为Person</p>
<h4 id="默认的MessageConverter"><a href="#默认的MessageConverter" class="headerlink" title="默认的MessageConverter"></a>默认的MessageConverter</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085753.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<p>0 - 只支持Byte类型的</p>
<p>1 - String</p>
<p>2 - String</p>
<p>3 - Resource</p>
<p>4 - ResourceRegion</p>
<p>5 - DOMSource.*<em>class *</em> SAXSource.<strong>class</strong>) \ StAXSource.**class **StreamSource.**class **Source.<strong>class</strong></p>
<p><strong>6 -</strong> MultiValueMap</p>
<p>7 - <strong>true</strong> </p>
<p><strong>8 - true</strong></p>
<p><strong>9 - 支持注解方式xml处理的。</strong></p>
<p>最终 MappingJackson2HttpMessageConverter  把对象转为JSON（利用底层的jackson的objectMapper转换的）</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085800.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>根据客户端接收能力不同，返回不同媒体类型的数据。</p>
<h3 id="引入xml依赖"><a href="#引入xml依赖" class="headerlink" title="引入xml依赖"></a>引入xml依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="postman分别测试返回json和xml"><a href="#postman分别测试返回json和xml" class="headerlink" title="postman分别测试返回json和xml"></a>postman分别测试返回json和xml</h3><p>只需要改变请求头中Accept字段。Http协议中规定的，告诉服务器本客户端可以接收的数据类型。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085809.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<h3 id="开启浏览器参数方式内容协商功能"><a href="#开启浏览器参数方式内容协商功能" class="headerlink" title="开启浏览器参数方式内容协商功能"></a>开启浏览器参数方式内容协商功能</h3><p>为了方便内容协商，开启基于请求参数的内容协商功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    contentnegotiation:</span><br><span class="line">      favor-parameter: true  #开启请求参数内容协商模式</span><br></pre></td></tr></table></figure>

<p>发请求： <a target="_blank" rel="noopener" href="http://localhost:8080/test/person?format=json">http://localhost:8080/test/person?format=json</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/test/person?format=json">http://localhost:8080/test/person?format=</a>xml</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085822.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<p>确定客户端接收什么样的内容类型；</p>
<p>1、Parameter策略优先确定是要返回json数据（获取请求头中的format的值）</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210807155059.png" alt="img"></p>
<p>2、最终进行内容协商返回给客户端json即可。</p>
<h3 id="内容协商原理"><a href="#内容协商原理" class="headerlink" title="内容协商原理"></a>内容协商原理</h3><ul>
<li><p>1、判断当前响应头中是否已经有确定的媒体类型。MediaType</p>
</li>
<li><p><strong>2、获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段）【application/xml】</strong></p>
</li>
<li><p><strong>contentNegotiationManager 内容协商管理器 默认使用基于请求头的策略</strong></p>
</li>
<li><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085828.png" alt="img"></p>
</li>
<li><p><strong>HeaderContentNegotiationStrategy  确定客户端可以接收的内容类型</strong> </p>
</li>
<li><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085830.png" alt="img"></p>
</li>
<li><p>3、遍历循环所有当前系统的 <strong>MessageConverter</strong>，看谁支持操作这个对象（Person）</p>
</li>
<li><p>4、找到支持操作Person的converter，把converter支持的媒体类型统计出来。</p>
</li>
<li><p>5、客户端需要【application/xml】。服务端能力【10种、json、xml】</p>
</li>
<li><p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085834.png" alt="img"></p>
</li>
<li><p>6、进行内容协商的最佳匹配媒体类型</p>
</li>
<li><p>7、用 支持 将对象转为 最佳匹配媒体类型 的converter。调用它进行转化 。</p>
</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085840.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<p>导入了jackson处理xml的包，xml的converter就会自动进来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebMvcConfigurationSupport</span><br><span class="line">jackson2XmlPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader);</span><br><span class="line"></span><br><span class="line">if (jackson2XmlPresent) &#123;</span><br><span class="line">			Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.xml();</span><br><span class="line">			if (this.applicationContext != null) &#123;</span><br><span class="line">				builder.applicationContext(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			messageConverters.add(new MappingJackson2XmlHttpMessageConverter(builder.build()));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义-MessageConverter"><a href="#自定义-MessageConverter" class="headerlink" title="自定义 MessageConverter"></a>自定义 MessageConverter</h3><p><strong>实现多协议数据兼容。json、xml、x-guigu</strong></p>
<p><strong>0、</strong>@ResponseBody 响应数据出去 调用 <strong>RequestResponseBodyMethodProcessor</strong> 处理</p>
<p>1、Processor 处理方法返回值。通过 <strong>MessageConverter</strong> 处理</p>
<p>2、所有 <strong>MessageConverter</strong> 合起来可以支持各种媒体类型数据的操作（读、写）</p>
<p>3、内容协商找到最终的 <strong>messageConverter</strong>；</p>
<p>SpringMVC的什么功能。一个入口给容器中添加一个  WebMvcConfigurer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">   public WebMvcConfigurer webMvcConfigurer()&#123;</span><br><span class="line">       return new WebMvcConfigurer() &#123;</span><br><span class="line"></span><br><span class="line">           @Override</span><br><span class="line">           public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085852.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085859.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<p><strong>有可能我们添加的自定义的功能会覆盖默认很多功能，导致一些默认的功能失效。</strong></p>
<p><strong>大家考虑，上述功能除了我们完全自定义外？SpringBoot有没有为我们提供基于配置文件的快速修改媒体类型功能？怎么配置呢？</strong></p>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="HandlerInterceptor-接口"><a href="#HandlerInterceptor-接口" class="headerlink" title="HandlerInterceptor 接口"></a>HandlerInterceptor 接口</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 登录检查</span><br><span class="line"> * 1、配置好拦截器要拦截哪些请求</span><br><span class="line"> * 2、把这些配置放在容器中</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 目标方法执行之前</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param handler</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        String requestURI = request.getRequestURI();</span><br><span class="line">        log.info(&quot;preHandle拦截的请求路径是&#123;&#125;&quot;,requestURI);</span><br><span class="line"></span><br><span class="line">        //登录检查逻辑</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">        Object loginUser = session.getAttribute(&quot;loginUser&quot;);</span><br><span class="line"></span><br><span class="line">        if(loginUser != null)&#123;</span><br><span class="line">            //放行</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //拦截住。未登录。跳转到登录页</span><br><span class="line">        request.setAttribute(&quot;msg&quot;,&quot;请先登录&quot;);</span><br><span class="line">//        re.sendRedirect(&quot;/&quot;);</span><br><span class="line">        request.getRequestDispatcher(&quot;/&quot;).forward(request,response);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 目标方法执行完成以后</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param handler</span><br><span class="line">     * @param modelAndView</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        log.info(&quot;postHandle执行&#123;&#125;&quot;,modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 页面渲染以后</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param handler</span><br><span class="line">     * @param ex</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        log.info(&quot;afterCompletion执行异常&#123;&#125;&quot;,ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 1、编写一个拦截器实现HandlerInterceptor接口</span><br><span class="line"> * 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）</span><br><span class="line"> * 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class AdminWebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new LoginInterceptor())</span><br><span class="line">                .addPathPatterns(&quot;/**&quot;)  //所有请求都被拦截包括静态资源</span><br><span class="line">                .excludePathPatterns(&quot;/&quot;,&quot;/login&quot;,&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/images/**&quot;,&quot;/js/**&quot;); //放行的请求</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h2><p>1、根据当前请求，找到<strong>HandlerExecutionChain【</strong>可以处理请求的handler以及handler的所有 拦截器】</p>
<p>2、先来<strong>顺序执行</strong> 所有拦截器的 preHandle方法</p>
<ul>
<li>1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle</li>
<li>2、如果当前拦截器返回为false。直接    倒序执行所有已经执行了的拦截器的  afterCompletion；</li>
</ul>
<p><strong>3、如果任何一个拦截器返回false。直接跳出不执行目标方法</strong></p>
<p><strong>4、所有拦截器都返回True。执行目标方法</strong></p>
<p><strong>5、倒序执行所有拦截器的postHandle方法。</strong></p>
<p><strong>6、前面的步骤有任何异常都会直接倒序触发</strong> afterCompletion</p>
<p>7、页面成功渲染完成以后，也会倒序触发 afterCompletion</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627090102.png" alt="img"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627090100.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="页面表单"><a href="#页面表单" class="headerlink" title="页面表单"></a>页面表单</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot; action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h2 id="文件上传代码"><a href="#文件上传代码" class="headerlink" title="文件上传代码"></a>文件上传代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * MultipartFile 自动封装上传过来的文件</span><br><span class="line"> * @param email</span><br><span class="line"> * @param username</span><br><span class="line"> * @param headerImg</span><br><span class="line"> * @param photos</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@PostMapping(&quot;/upload&quot;)</span><br><span class="line">public String upload(@RequestParam(&quot;email&quot;) String email,</span><br><span class="line">                     @RequestParam(&quot;username&quot;) String username,</span><br><span class="line">                     @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg,</span><br><span class="line">                     @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;上传的信息：email=&#123;&#125;，username=&#123;&#125;，headerImg=&#123;&#125;，photos=&#123;&#125;&quot;,</span><br><span class="line">            email,username,headerImg.getSize(),photos.length);</span><br><span class="line"></span><br><span class="line">    if(!headerImg.isEmpty())&#123;</span><br><span class="line">        //保存到文件服务器，OSS服务器</span><br><span class="line">        String originalFilename = headerImg.getOriginalFilename();</span><br><span class="line">        headerImg.transferTo(new File(&quot;H:\\cache\\&quot;+originalFilename));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(photos.length &gt; 0)&#123;</span><br><span class="line">        for (MultipartFile photo : photos) &#123;</span><br><span class="line">            if(!photo.isEmpty())&#123;</span><br><span class="line">                String originalFilename = photo.getOriginalFilename();</span><br><span class="line">                photo.transferTo(new File(&quot;H:\\cache\\&quot;+originalFilename));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return &quot;main&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><p>**文件上传自动配置类-MultipartAutoConfiguration-**<strong>MultipartProperties</strong></p>
<ul>
<li><p>自动配置好了 <strong>StandardServletMultipartResolver   【文件上传解析器】</strong></p>
</li>
<li><p><strong>原理步骤</strong></p>
</li>
<li><p><strong>1、请求进来使用文件上传解析器判断（</strong>isMultipart<strong>）并封装（</strong>resolveMultipart，<strong>返回</strong>MultipartHttpServletRequest<strong>）文件上传请求</strong></p>
</li>
<li><p><strong>2、参数解析器来解析请求中的文件内容封装成MultipartFile</strong></p>
</li>
<li><p><strong>3、将request中文件信息封装为一个Map；</strong>MultiValueMap&lt;String, MultipartFile&gt;</p>
</li>
</ul>
<p><strong>FileCopyUtils</strong>。实现文件流的拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/upload&quot;)</span><br><span class="line">public String upload(@RequestParam(&quot;email&quot;) String email,</span><br><span class="line">                     @RequestParam(&quot;username&quot;) String username,</span><br><span class="line">                     @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg,</span><br><span class="line">                     @RequestPart(&quot;photos&quot;) MultipartFile[] photos)</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627090052.png" alt="img"></p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h4 id="默认规则"><a href="#默认规则" class="headerlink" title="默认规则"></a>默认规则</h4><ul>
<li><p>默认情况下，Spring Boot提供<code>/error</code>处理所有错误的映射</p>
</li>
<li><p>对于机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据</p>
</li>
<li><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210807155154.png" alt="img"></p>
</li>
<li><p><strong>要对其进行自定义，添加</strong><code>**View**</code><strong>解析为</strong><code>**error**</code></p>
</li>
<li><p>要完全替换默认行为，可以实现 <code>ErrorController </code>并注册该类型的Bean定义，或添加<code>ErrorAttributes类型的组件</code>以使用现有机制但替换其内容。</p>
</li>
<li><p>error/下的4xx，5xx页面会被自动解析；</p>
</li>
<li><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627090036.png" alt="img"></p>
</li>
</ul>
<h4 id="定制错误处理逻辑"><a href="#定制错误处理逻辑" class="headerlink" title="定制错误处理逻辑"></a>定制错误处理逻辑</h4><ul>
<li><p>自定义错误页</p>
</li>
<li><p>error/404.html   error/5xx.html；有精确的错误状态码页面就匹配精确，没有就找 4xx.html；如果都没有就触发白页</p>
</li>
<li><p>@ControllerAdvice+@ExceptionHandler处理全局异常；底层是 <strong>ExceptionHandlerExceptionResolver 支持的</strong></p>
</li>
<li><p>@ResponseStatus+自定义异常 ；底层是 <strong>ResponseStatusExceptionResolver ，把responsestatus注解的信息底层调用</strong> <strong>response.sendError(statusCode, resolvedReason)；tomcat发送的/error</strong></p>
</li>
<li><p>Spring底层的异常，如 参数类型转换异常；<strong>DefaultHandlerExceptionResolver 处理框架底层的异常。</strong></p>
</li>
<li><p>response.sendError(HttpServletResponse.<strong>SC_BAD_REQUEST</strong>, ex.getMessage()); </p>
</li>
<li><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627090032.png" alt="img"></p>
</li>
<li><p>自定义实现 HandlerExceptionResolver 处理异常；可以作为默认的全局异常处理规则</p>
</li>
<li><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627090030.png" alt="img"></p>
</li>
<li><p><strong>ErrorViewResolver</strong>  实现自定义处理异常；</p>
</li>
<li><p>response.sendError 。error请求就会转给controller</p>
</li>
<li><p>你的异常没有任何人能处理。tomcat底层 response.sendError。error请求就会转给controller</p>
</li>
<li><p><strong>basicErrorController 要去的页面地址是</strong> <strong>ErrorViewResolver</strong>  ；</p>
</li>
</ul>
<h4 id="异常处理自动配置原理"><a href="#异常处理自动配置原理" class="headerlink" title="异常处理自动配置原理"></a>异常处理自动配置原理</h4><ul>
<li><p><strong>ErrorMvcAutoConfiguration  自动配置异常处理规则</strong></p>
</li>
<li><p><strong>容器中的组件：类型：DefaultErrorAttributes -&gt;</strong> <strong>id：errorAttributes</strong></p>
</li>
<li><p><strong>public class</strong> <strong>DefaultErrorAttributes</strong> <strong>implements</strong> <strong>ErrorAttributes</strong>, <strong>HandlerExceptionResolver</strong></p>
</li>
<li><p><strong>DefaultErrorAttributes</strong>：定义错误页面中可以包含哪些数据。</p>
</li>
<li><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210807155240.png" alt="img"></p>
</li>
<li><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210807155305.png" alt="img"></p>
</li>
<li><p><strong>容器中的组件：类型：****BasicErrorController –&gt; id：basicErrorController（json+白页 适配响应）</strong></p>
</li>
<li><p><strong>处理默认</strong> <strong>/error 路径的请求；页面响应</strong> <strong>new</strong> ModelAndView(<strong>“error”</strong>, model)；</p>
</li>
<li><p><strong>容器中有组件 View</strong>-&gt;<strong>id是error</strong>；（响应默认错误页）</p>
</li>
<li><p>容器中放组件 <strong>BeanNameViewResolver（视图解析器）；按照返回的视图名作为组件的id去容器中找View对象。</strong></p>
</li>
<li><p><strong>容器中的组件：</strong>类型：<strong>DefaultErrorViewResolver -&gt; id：</strong>conventionErrorViewResolver</p>
</li>
<li><p>如果发生错误，会以HTTP的状态码 作为视图页地址（viewName），找到真正的页面</p>
</li>
<li><p>error/404、5xx.html</p>
</li>
</ul>
<p>如果想要返回页面；就会找error视图【<strong>StaticView</strong>】。(默认是一个白页)</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210807155414.png" alt="img">写出去json</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627090012.png" alt="img"> 错误页</p>
<h4 id="异常处理步骤流程"><a href="#异常处理步骤流程" class="headerlink" title="异常处理步骤流程"></a>异常处理步骤流程</h4><p>1、执行目标方法，目标方法运行期间有任何异常都会被catch、而且标志当前请求结束；并且用 <strong>dispatchException</strong> </p>
<p>2、进入视图解析流程（页面渲染？） </p>
<p>processDispatchResult(processedRequest, response, mappedHandler, <strong>mv</strong>, <strong>dispatchException</strong>);</p>
<p>3、<strong>mv</strong> = <strong>processHandlerException</strong>；处理handler发生的异常，处理完成返回ModelAndView；</p>
<ul>
<li><p>1、遍历所有的 <strong>handlerExceptionResolvers，看谁能处理当前异常【<strong><strong>HandlerExceptionResolver处理器异常解析器</strong></strong>】</strong></p>
</li>
<li><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627090009.png" alt="img"></p>
</li>
<li><p><strong>2、系统默认的  异常解析器；</strong></p>
</li>
<li><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627090005.png" alt="img"></p>
</li>
<li><p><strong>1、DefaultErrorAttributes先来处理异常。把异常信息保存到rrequest域，并且返回null；</strong></p>
</li>
<li><p><strong>2、默认没有任何人能处理异常，所以异常会被抛出</strong></p>
</li>
<li><p><strong>1、如果没有任何人能处理最终底层就会发送 /error 请求。会被底层的BasicErrorController处理</strong></p>
</li>
<li><p><strong>2、解析错误视图；遍历所有的</strong>  <strong>ErrorViewResolver  看谁能解析。</strong></p>
</li>
<li><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627090001.png" alt="img"></p>
</li>
<li><p><strong>3、默认的</strong> <strong>DefaultErrorViewResolver ,作用是把响应状态码作为错误页的地址，error/500.html</strong> </p>
</li>
<li><p><strong>4、模板引擎最终响应这个页面</strong> <strong>error/500.html</strong> </p>
</li>
</ul>
<h1 id="Web原生组件注入（Servlet、Filter、Listener）"><a href="#Web原生组件注入（Servlet、Filter、Listener）" class="headerlink" title="Web原生组件注入（Servlet、Filter、Listener）"></a>Web原生组件注入（Servlet、Filter、Listener）</h1><h2 id="使用Servlet-API"><a href="#使用Servlet-API" class="headerlink" title="使用Servlet API"></a>使用Servlet API</h2><p>@ServletComponentScan(basePackages = <strong>“com.atguigu.admin”</strong>) :指定原生Servlet组件都放在那里</p>
<p>@WebServlet(urlPatterns = <strong>“/my”</strong>)：效果：直接响应，<strong>没有经过Spring的拦截器？</strong></p>
<p>@WebFilter(urlPatterns={<strong>“/css/*“</strong>,<strong>“/images/*“</strong>})</p>
<p>@WebListener</p>
<p>推荐可以这种方式；</p>
<p>扩展：DispatchServlet 如何注册进来</p>
<ul>
<li><p>容器中自动配置了  DispatcherServlet  属性绑定到 WebMvcProperties；对应的配置文件配置项是 <strong>spring.mvc。</strong></p>
</li>
<li><p><strong>通过</strong> <strong>ServletRegistrationBean</strong><DispatcherServlet> 把 DispatcherServlet  配置进来。</p>
</li>
<li><p>默认映射的是 / 路径。</p>
</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085947.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<p>Tomcat-Servlet；</p>
<p>多个Servlet都能处理到同一层路径，精确优选原则</p>
<p>A： /my/</p>
<p>B： /my/1</p>
<h2 id="使用RegistrationBean"><a href="#使用RegistrationBean" class="headerlink" title="使用RegistrationBean"></a>使用RegistrationBean</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServletRegistrationBean`, `FilterRegistrationBean`, and `ServletListenerRegistrationBean</span><br><span class="line">@Configuration</span><br><span class="line">public class MyRegistConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean myServlet()&#123;</span><br><span class="line">        MyServlet myServlet = new MyServlet();</span><br><span class="line"></span><br><span class="line">        return new ServletRegistrationBean(myServlet,&quot;/my&quot;,&quot;/my02&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean myFilter()&#123;</span><br><span class="line"></span><br><span class="line">        MyFilter myFilter = new MyFilter();</span><br><span class="line">//        return new FilterRegistrationBean(myFilter,myServlet());</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(myFilter);</span><br><span class="line">        filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/my&quot;,&quot;/css/*&quot;));</span><br><span class="line">        return filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletListenerRegistrationBean myListener()&#123;</span><br><span class="line">        MySwervletContextListener mySwervletContextListener = new MySwervletContextListener();</span><br><span class="line">        return new ServletListenerRegistrationBean(mySwervletContextListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="嵌入式Servlet容器"><a href="#嵌入式Servlet容器" class="headerlink" title="嵌入式Servlet容器"></a>嵌入式Servlet容器</h1><h2 id="切换嵌入式Servlet容器"><a href="#切换嵌入式Servlet容器" class="headerlink" title="切换嵌入式Servlet容器"></a>切换嵌入式Servlet容器</h2><ul>
<li><p>默认支持的webServer</p>
</li>
<li><p><code>Tomcat</code>, <code>Jetty</code>, or <code>Undertow</code></p>
</li>
<li><p><code>ServletWebServerApplicationContext 容器启动寻找ServletWebServerFactory 并引导创建服务器</code></p>
</li>
<li><p>切换服务器</p>
</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210627085942.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>原理</p>
</li>
<li><p>SpringBoot应用启动发现当前是Web应用。web场景包-导入tomcat</p>
</li>
<li><p>web应用会创建一个web版的ioc容器 <code>ServletWebServerApplicationContext</code> </p>
</li>
<li><p><code>ServletWebServerApplicationContext</code> 启动的时候寻找 <code>**ServletWebServerFactory**``（Servlet 的web服务器工厂---&gt; Servlet 的web服务器）</code> </p>
</li>
<li><p>SpringBoot底层默认有很多的WebServer工厂；<code>TomcatServletWebServerFactory</code>, <code>JettyServletWebServerFactory</code>, or <code>UndertowServletWebServerFactory</code></p>
</li>
<li><p><code>底层直接会有一个自动配置类。ServletWebServerFactoryAutoConfiguration</code></p>
</li>
<li><p><code>ServletWebServerFactoryAutoConfiguration导入了ServletWebServerFactoryConfiguration（配置类）</code></p>
</li>
<li><p><code>ServletWebServerFactoryConfiguration 配置类 根据动态判断系统中到底导入了那个Web服务器的包。（默认是web-starter导入tomcat包），容器中就有 TomcatServletWebServerFactory</code></p>
</li>
<li><p><code>TomcatServletWebServerFactory 创建出Tomcat服务器并启动；TomcatWebServer 的构造器拥有初始化方法initialize---this.tomcat.start();</code></p>
</li>
<li><p><code>内嵌服务器，就是手动把启动服务器的代码调用（tomcat核心jar包存在）</code></p>
</li>
<li><p>``</p>
</li>
</ul>
<h2 id="2、定制Servlet容器"><a href="#2、定制Servlet容器" class="headerlink" title="2、定制Servlet容器"></a>2、定制Servlet容器</h2><ul>
<li><p>实现  <strong>WebServerFactoryCu</strong>stomizer<ConfigurableServletWebServerFactory> </p>
</li>
<li><p>把配置文件的值和<code>**ServletWebServerFactory 进行绑定**</code></p>
</li>
<li><p>修改配置文件 <strong>server.xxx</strong></p>
</li>
<li><p>直接自定义 <strong>ConfigurableServletWebServerFactory</strong> </p>
</li>
</ul>
<p><strong>xxxxx<strong><strong>Customizer</strong></strong>：定制化器，可以改变xxxx的默认规则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class="line">import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void customize(ConfigurableServletWebServerFactory server) &#123;</span><br><span class="line">        server.setPort(9000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="定制化原理"><a href="#定制化原理" class="headerlink" title="定制化原理"></a>定制化原理</h1><h2 id="定制化的常见方式"><a href="#定制化的常见方式" class="headerlink" title="定制化的常见方式"></a>定制化的常见方式</h2><ul>
<li><p>修改配置文件；</p>
</li>
<li><p><strong>xxxxxCustomizer；</strong></p>
</li>
<li><p><strong>编写自定义的配置类   xxxConfiguration；+</strong> <strong>@Bean替换、增加容器中默认组件；视图解析器</strong> </p>
</li>
<li><p><strong>Web应用 编写一个配置类实现</strong> <strong>WebMvcConfigurer 即可定制化web功能；+ @Bean给容器中再扩展一些组件</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AdminWebConfig implements WebMvcConfigurer</span><br></pre></td></tr></table></figure>

<ul>
<li><p>@EnableWebMvc + WebMvcConfigurer —— @Bean  可以全面接管SpringMVC，所有规则全部自己重新配置； 实现定制和扩展功能</p>
</li>
<li><p>原理</p>
</li>
<li><p>1、WebMvcAutoConfiguration  默认的SpringMVC的自动配置功能类。静态资源、欢迎页…..</p>
</li>
<li><p>2、一旦使用 @EnableWebMvc 、。会 @Import(DelegatingWebMvcConfiguration.<strong>class</strong>)</p>
</li>
<li><p>3、<strong>DelegatingWebMvcConfiguration</strong> 的 作用，只保证SpringMVC最基本的使用</p>
</li>
<li><p>把所有系统中的 WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer  合起来一起生效</p>
</li>
<li><p>自动配置了一些非常底层的组件。<strong>RequestMappingHandlerMapping</strong>、这些组件依赖的组件都是从容器中获取</p>
</li>
<li><p><strong>public class</strong> DelegatingWebMvcConfiguration <strong>extends</strong> <strong>WebMvcConfigurationSupport</strong></p>
</li>
<li><p>4、<strong>WebMvcAutoConfiguration</strong> 里面的配置要能生效 必须  @ConditionalOnMissingBean(<strong>WebMvcConfigurationSupport</strong>.<strong>class</strong>)</p>
</li>
<li><p>5、@EnableWebMvc  导致了 <strong>WebMvcAutoConfiguration  没有生效。</strong></p>
</li>
<li><p>… …</p>
</li>
</ul>
<h2 id="原理分析套路"><a href="#原理分析套路" class="headerlink" title="原理分析套路"></a>原理分析套路</h2><p><strong>场景starter</strong> <strong>- xxxxAutoConfiguration - 导入xxx组件 - 绑定xxxProperties –</strong> <strong>绑定配置文件项</strong> </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://andice-cream.github.io/post/7f8710c1.html">https://andice-cream.github.io/post/7f8710c1.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://andice-cream.github.io" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringBoot/">SpringBoot</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/be649375.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringBoot-指标监控</div></div></a></div><div class="next-post pull-right"><a href="/post/10f0fa46.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165213.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot-缓存管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/d5933ce9.html" title="SpringBoot-基本使用"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212100.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">SpringBoot-基本使用</div></div></a></div><div><a href="/post/be649375.html" title="SpringBoot-指标监控"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">SpringBoot-指标监控</div></div></a></div><div><a href="/post/e85cf01d.html" title="SpringBoot-数据访问"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165214.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">SpringBoot-数据访问</div></div></a></div><div><a href="/post/7b97cc4c.html" title="SpringBoot之Test"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165209.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">SpringBoot之Test</div></div></a></div><div><a href="/post/10f0fa46.html" title="SpringBoot-缓存管理"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165213.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">SpringBoot-缓存管理</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%A6%82%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">SpringMVC自动配置概览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">简单功能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE"><span class="toc-number">2.1.</span> <span class="toc-text">静态资源访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">静态资源目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%89%8D%E7%BC%80"><span class="toc-number">2.1.2.</span> <span class="toc-text">静态资源访问前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webjar"><span class="toc-number">2.1.3.</span> <span class="toc-text">webjar</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A2%E8%BF%8E%E9%A1%B5%E6%94%AF%E6%8C%81"><span class="toc-number">2.2.</span> <span class="toc-text">欢迎页支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.</span> <span class="toc-text">自定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">2.4、静态资源配置原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">2.4.0.1.</span> <span class="toc-text">配置类只有一个有参构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99"><span class="toc-number">2.4.0.2.</span> <span class="toc-text">资源处理的默认规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AC%A2%E8%BF%8E%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-number">2.4.0.3.</span> <span class="toc-text">欢迎页的处理规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#favicon"><span class="toc-number">2.4.0.4.</span> <span class="toc-text">favicon</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">请求参数处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84"><span class="toc-number">3.1.</span> <span class="toc-text">请求映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rest%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">rest使用与原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">请求映射原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%8F%82%E6%95%B0%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">普通参数与基本注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">注解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-API%EF%BC%9A"><span class="toc-number">3.2.2.</span> <span class="toc-text">Servlet API：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-number">3.2.3.</span> <span class="toc-text">复杂参数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-number">3.2.4.</span> <span class="toc-text">自定义对象参数：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POJO%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">POJO封装过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">参数处理原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HandlerAdapter"><span class="toc-number">3.4.1.</span> <span class="toc-text">HandlerAdapter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">执行目标方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8-HandlerMethodArgumentResolver"><span class="toc-number">3.4.3.</span> <span class="toc-text">参数解析器-HandlerMethodArgumentResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">3.4.4.</span> <span class="toc-text">返回值处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC"><span class="toc-number">3.4.5.</span> <span class="toc-text">如何确定目标方法每一个参数的值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%A8%E4%B8%AA%E5%88%A4%E6%96%AD%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8%E9%82%A3%E4%B8%AA%E6%94%AF%E6%8C%81%E8%A7%A3%E6%9E%90%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">挨个判断所有参数解析器那个支持解析这个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC"><span class="toc-number">3.4.5.2.</span> <span class="toc-text">解析这个参数的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0-%E5%B0%81%E8%A3%85POJO"><span class="toc-number">3.4.5.3.</span> <span class="toc-text">自定义类型参数 封装POJO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.4.6.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90"><span class="toc-number">3.4.7.</span> <span class="toc-text">目标方法执行完成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B4%BE%E5%8F%91%E7%BB%93%E6%9E%9C"><span class="toc-number">3.4.8.</span> <span class="toc-text">处理派发结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E4%B8%8E%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86"><span class="toc-number">4.</span> <span class="toc-text">数据响应与内容协商</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94JSON"><span class="toc-number">4.1.</span> <span class="toc-text">响应JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jackson-jar-ResponseBody"><span class="toc-number">4.1.1.</span> <span class="toc-text">jackson.jar+@ResponseBody</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">4.1.2.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">返回值解析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%A3%E6%9E%90%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">返回值解析器原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-2"><span class="toc-number">4.1.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E5%88%B0%E5%BA%95%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.1.4.</span> <span class="toc-text">SpringMVC到底支持哪些返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPMessageConverter%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.5.</span> <span class="toc-text">HTTPMessageConverter原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MessageConverter%E8%A7%84%E8%8C%83"><span class="toc-number">4.1.5.1.</span> <span class="toc-text">MessageConverter规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84MessageConverter"><span class="toc-number">4.1.5.2.</span> <span class="toc-text">默认的MessageConverter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86"><span class="toc-number">4.2.</span> <span class="toc-text">内容协商</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5xml%E4%BE%9D%E8%B5%96"><span class="toc-number">4.2.1.</span> <span class="toc-text">引入xml依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#postman%E5%88%86%E5%88%AB%E6%B5%8B%E8%AF%95%E8%BF%94%E5%9B%9Ejson%E5%92%8Cxml"><span class="toc-number">4.2.2.</span> <span class="toc-text">postman分别测试返回json和xml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E5%8A%9F%E8%83%BD"><span class="toc-number">4.2.3.</span> <span class="toc-text">开启浏览器参数方式内容协商功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.4.</span> <span class="toc-text">内容协商原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-MessageConverter"><span class="toc-number">4.2.5.</span> <span class="toc-text">自定义 MessageConverter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HandlerInterceptor-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.</span> <span class="toc-text">HandlerInterceptor 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">配置拦截器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">拦截器原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">6.</span> <span class="toc-text">文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E8%A1%A8%E5%8D%95"><span class="toc-number">6.1.</span> <span class="toc-text">页面表单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81"><span class="toc-number">6.2.</span> <span class="toc-text">文件上传代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">自动配置原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">7.1.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99"><span class="toc-number">7.1.0.1.</span> <span class="toc-text">默认规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-number">7.1.0.2.</span> <span class="toc-text">定制错误处理逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">7.1.0.3.</span> <span class="toc-text">异常处理自动配置原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4%E6%B5%81%E7%A8%8B"><span class="toc-number">7.1.0.4.</span> <span class="toc-text">异常处理步骤流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Web%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%85%A5%EF%BC%88Servlet%E3%80%81Filter%E3%80%81Listener%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">Web原生组件注入（Servlet、Filter、Listener）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Servlet-API"><span class="toc-number">8.1.</span> <span class="toc-text">使用Servlet API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8RegistrationBean"><span class="toc-number">8.2.</span> <span class="toc-text">使用RegistrationBean</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">嵌入式Servlet容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8"><span class="toc-number">9.1.</span> <span class="toc-text">切换嵌入式Servlet容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AE%9A%E5%88%B6Servlet%E5%AE%B9%E5%99%A8"><span class="toc-number">9.2.</span> <span class="toc-text">2、定制Servlet容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">定制化原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E5%8C%96%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F"><span class="toc-number">10.1.</span> <span class="toc-text">定制化的常见方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%A5%97%E8%B7%AF"><span class="toc-number">10.2.</span> <span class="toc-text">原理分析套路</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>